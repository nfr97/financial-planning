<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transaction Analyzer - See Your Spending Reality</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f5f7fa;
            border-radius: 8px;
        }

        .section h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        .section h3 {
            margin-bottom: 10px;
            color: #555;
            font-size: 1.1em;
        }

        /* Upload Section */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .upload-area:hover {
            background: #f0f4ff;
            border-color: #5568d3;
        }

        .upload-area.dragover {
            background: #e8edff;
            border-color: #4455c7;
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 5px;
        }

        .upload-hint {
            font-size: 0.9em;
            color: #999;
        }

        /* Bank Format Selection */
        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .format-option {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s;
        }

        .format-option:hover {
            border-color: #667eea;
        }

        .format-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Targets Section */
        .targets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .target-input {
            display: flex;
            flex-direction: column;
        }

        .target-input label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .target-input input {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
        }

        .target-input input:focus {
            outline: none;
            border-color: #667eea;
        }

        /* Results Section */
        .results-hidden {
            display: none;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid;
        }

        .summary-card.fixed-costs { border-left-color: #ef4444; }
        .summary-card.short-term { border-left-color: #f59e0b; }
        .summary-card.long-term { border-left-color: #10b981; }
        .summary-card.guilt-free { border-left-color: #8b5cf6; }
        .summary-card.uncategorized { border-left-color: #6b7280; }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .card-percentage {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .card-amount {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .card-comparison {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .comparison-target {
            color: #666;
        }

        .comparison-diff {
            font-weight: 600;
        }

        .comparison-diff.over { color: #ef4444; }
        .comparison-diff.under { color: #10b981; }
        .comparison-diff.neutral { color: #6b7280; }

        /* Progress Bar */
        .progress-container {
            margin-top: 10px;
        }

        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .progress-target {
            position: absolute;
            top: -4px;
            width: 2px;
            height: 16px;
            background: #333;
        }

        /* Transactions Table */
        .transactions-container {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .transactions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
        }

        .transactions-table {
            width: 100%;
            border-collapse: collapse;
        }

        .transactions-table th,
        .transactions-table td {
            padding: 12px 20px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transactions-table tr:hover {
            background: #f9fafb;
        }

        .amount-cell {
            font-weight: 600;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .amount-cell.expense { color: #ef4444; }
        .amount-cell.income { color: #10b981; }

        .category-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .category-badge.fixed-costs { background: #fee2e2; color: #dc2626; }
        .category-badge.short-term { background: #fef3c7; color: #d97706; }
        .category-badge.long-term { background: #d1fae5; color: #059669; }
        .category-badge.guilt-free { background: #ede9fe; color: #7c3aed; }
        .category-badge.uncategorized { background: #f3f4f6; color: #6b7280; }
        .category-badge.income { background: #dbeafe; color: #2563eb; }

        .category-select {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* Comparison Chart */
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .chart-title {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 20px;
            text-align: center;
        }

        .comparison-bars {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .comparison-row {
            display: grid;
            grid-template-columns: 150px 1fr 80px;
            gap: 15px;
            align-items: center;
        }

        .comparison-label {
            font-weight: 500;
            text-align: right;
        }

        .comparison-bar-container {
            position: relative;
            height: 30px;
        }

        .comparison-bar {
            position: absolute;
            height: 12px;
            border-radius: 6px;
            transition: width 0.5s;
        }

        .comparison-bar.target {
            top: 0;
            background: #e0e0e0;
        }

        .comparison-bar.actual {
            top: 16px;
        }

        .comparison-bar.actual.fixed-costs { background: #ef4444; }
        .comparison-bar.actual.short-term { background: #f59e0b; }
        .comparison-bar.actual.long-term { background: #10b981; }
        .comparison-bar.actual.guilt-free { background: #8b5cf6; }

        .comparison-value {
            font-weight: 600;
            font-size: 0.9em;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover {
            background: #f0f4ff;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        /* Footer */
        footer {
            background: #f5f5f5;
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Info Box */
        .info-box {
            background: #dbeafe;
            border: 1px solid #93c5fd;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #1e40af;
            font-size: 0.95em;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        /* Privacy Notice */
        .privacy-notice {
            background: #d1fae5;
            border: 1px solid #6ee7b7;
            border-radius: 6px;
            padding: 12px 15px;
            margin-top: 15px;
            color: #065f46;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .privacy-icon {
            font-size: 1.2em;
        }

        /* API Key Section */
        .api-key-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .api-key-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            font-family: monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .ai-status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            display: none;
        }

        .ai-status.show {
            display: block;
        }

        .ai-status.processing {
            background: #dbeafe;
            color: #1e40af;
        }

        .ai-status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .ai-status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5em;
            }

            .content {
                padding: 20px;
            }

            .comparison-row {
                grid-template-columns: 1fr;
                gap: 5px;
            }

            .comparison-label {
                text-align: left;
            }

            .transactions-table th,
            .transactions-table td {
                padding: 10px;
                font-size: 0.9em;
            }

            .filter-controls {
                flex-direction: column;
            }
        }

        /* Scrollable table container */
        .table-scroll {
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }

        /* Date range display */
        .date-range {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }

        /* Stats row */
        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: #333;
        }

        .stat-value.expense { color: #ef4444; }
        .stat-value.income { color: #10b981; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Transaction Analyzer</h1>
            <p>Upload your bank transactions to see your actual spending vs. your goals</p>
        </header>

        <div class="content">
            <!-- Privacy Notice -->
            <div class="privacy-notice">
                <span class="privacy-icon">&#128274;</span>
                <span><strong>Your data stays private.</strong> All processing happens in your browser. No data is uploaded to any server.</span>
            </div>

            <!-- Step 1: Set Targets -->
            <div class="section">
                <h2>Step 1: Set Your Target Allocations</h2>
                <p style="color: #666; margin-bottom: 15px;">Enter your monthly income and target percentages (from your Income Allocation plan)</p>

                <div class="targets-grid">
                    <div class="target-input">
                        <label for="monthlyIncome">Monthly Income</label>
                        <input type="number" id="monthlyIncome" value="5000" min="0" step="100">
                    </div>
                    <div class="target-input">
                        <label for="targetFixed">Fixed Costs %</label>
                        <input type="number" id="targetFixed" value="50" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetShortTerm">Short-Term Savings %</label>
                        <input type="number" id="targetShortTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetLongTerm">Long-Term Savings %</label>
                        <input type="number" id="targetLongTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetGuiltFree">Guilt-Free Spending %</label>
                        <input type="number" id="targetGuiltFree" value="10" min="0" max="100">
                    </div>
                </div>
            </div>

            <!-- AI Categorization (Optional) -->
            <div class="section" id="aiSection">
                <h2>AI-Powered Categorization (Optional)</h2>
                <p style="color: #666; margin-bottom: 15px;">Enter your Claude API key to automatically categorize transactions using AI. Your key is stored locally and never sent anywhere except Anthropic's API.</p>
                <div class="api-key-wrapper">
                    <input type="password" id="apiKey" placeholder="sk-ant-api..." class="api-key-input">
                    <button class="btn btn-secondary" onclick="analyzer.toggleApiKeyVisibility()">Show</button>
                    <button class="btn btn-primary" id="aiCategorizeBtn" onclick="analyzer.aiCategorize()" disabled>AI Categorize</button>
                </div>
                <div id="aiStatus" class="ai-status"></div>
            </div>

            <!-- Step 2: Select Format -->
            <div class="section">
                <h2>Step 2: Select Your Bank Format</h2>
                <div class="format-grid">
                    <div class="format-option selected" data-format="chase">Chase</div>
                    <div class="format-option" data-format="bofa">Bank of America</div>
                    <div class="format-option" data-format="wells">Wells Fargo</div>
                    <div class="format-option" data-format="citi">Citi</div>
                    <div class="format-option" data-format="amex">American Express</div>
                    <div class="format-option" data-format="capital-one">Capital One</div>
                    <div class="format-option" data-format="discover">Discover</div>
                    <div class="format-option" data-format="generic">Generic CSV</div>
                </div>
            </div>

            <!-- Step 3: Upload -->
            <div class="section">
                <h2>Step 3: Upload Your Transactions</h2>
                <div class="upload-area" id="uploadArea">
                    <input type="file" id="fileInput" accept=".csv" multiple>
                    <div class="upload-icon">&#128196;</div>
                    <div class="upload-text">Drop CSV files here or click to upload</div>
                    <div class="upload-hint">You can upload multiple files from different accounts</div>
                </div>
            </div>

            <!-- Results Section (hidden until data uploaded) -->
            <div id="resultsSection" class="results-hidden">
                <!-- Date Range and Stats -->
                <div class="section">
                    <h2>Analysis Summary</h2>
                    <div class="date-range" id="dateRange"></div>
                    <div class="stats-row">
                        <div class="stat-box">
                            <div class="stat-label">Total Transactions</div>
                            <div class="stat-value" id="totalTransactions">0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Income</div>
                            <div class="stat-value income" id="totalIncome">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Spending</div>
                            <div class="stat-value expense" id="totalSpending">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Net</div>
                            <div class="stat-value" id="netAmount">$0</div>
                        </div>
                    </div>
                </div>

                <!-- Comparison Chart -->
                <div class="section">
                    <h2>Goal vs Reality</h2>
                    <div class="chart-container">
                        <div class="chart-title">Target Allocation vs Actual Spending (Monthly Average)</div>
                        <div class="comparison-bars" id="comparisonChart"></div>
                    </div>
                </div>

                <!-- Category Cards -->
                <div class="summary-cards" id="summaryCards"></div>

                <!-- Transactions Table -->
                <div class="section">
                    <h2>Transaction Details</h2>
                    <div class="transactions-container">
                        <div class="transactions-header">
                            <span class="transactions-title">All Transactions</span>
                            <div class="filter-controls">
                                <select class="filter-select" id="categoryFilter">
                                    <option value="all">All Categories</option>
                                    <option value="fixed-costs">Fixed Costs</option>
                                    <option value="short-term">Short-Term Savings</option>
                                    <option value="long-term">Long-Term Savings</option>
                                    <option value="guilt-free">Guilt-Free Spending</option>
                                    <option value="income">Income</option>
                                    <option value="uncategorized">Uncategorized</option>
                                </select>
                                <select class="filter-select" id="sortOrder">
                                    <option value="date-desc">Date (Newest)</option>
                                    <option value="date-asc">Date (Oldest)</option>
                                    <option value="amount-desc">Amount (High to Low)</option>
                                    <option value="amount-asc">Amount (Low to High)</option>
                                </select>
                            </div>
                        </div>
                        <div class="table-scroll">
                            <table class="transactions-table">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Description</th>
                                        <th>Amount</th>
                                        <th>Category</th>
                                    </tr>
                                </thead>
                                <tbody id="transactionsBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="action-buttons">
                    <button class="btn btn-secondary" onclick="analyzer.exportSummary()">Export Summary</button>
                    <button class="btn btn-primary" onclick="analyzer.saveRules()">Save Categorization Rules</button>
                    <a href="income-allocation.html" class="btn btn-success">Adjust Your Allocation Plan</a>
                </div>
            </div>
        </div>

        <footer>
            <a href="income-allocation.html">Income Allocation Calculator</a> |
            <a href="index.html">Retirement Simulator</a>
        </footer>
    </div>

    <script>
        class TransactionAnalyzer {
            constructor() {
                this.transactions = [];
                this.selectedFormat = 'chase';
                this.targets = {
                    income: 5000,
                    fixedCosts: 50,
                    shortTerm: 20,
                    longTerm: 20,
                    guiltFree: 10
                };

                // Category patterns for auto-categorization
                this.categoryPatterns = {
                    'fixed-costs': [
                        // Housing
                        /rent|mortgage|hoa|property.*tax|home.*insurance/i,
                        // Utilities
                        /electric|gas.*company|water.*bill|sewage|trash|waste|pge|con.*ed|duke.*energy|xcel/i,
                        /comcast|xfinity|spectrum|at&t|verizon|t-mobile|sprint|cricket|internet|cable/i,
                        // Insurance
                        /geico|allstate|state.*farm|progressive|liberty.*mutual|insurance|health.*plan/i,
                        // Car
                        /car.*payment|auto.*loan|toyota.*financial|honda.*financial|ford.*credit/i,
                        // Debt payments
                        /student.*loan|nelnet|navient|fedloan|sofi|earnest|loan.*payment/i,
                        /credit.*card.*payment|minimum.*payment/i,
                        // Groceries (essential)
                        /grocery|safeway|kroger|publix|trader.*joe|whole.*foods|aldi|costco|walmart.*grocery|target.*grocery|wegmans|heb|albertsons/i,
                        // Healthcare essentials
                        /pharmacy|cvs|walgreens|rite.*aid|prescription|doctor|medical|copay|hospital/i,
                        // Childcare
                        /daycare|childcare|preschool|tuition/i,
                        // Transportation essentials
                        /gas.*station|shell|chevron|exxon|mobil|bp|arco|speedway|wawa|parking|toll/i,
                        /uber(?!.*eats)|lyft|transit|metro|subway.*fare|bus.*pass/i
                    ],
                    'short-term': [
                        // Savings transfers
                        /transfer.*to.*savings|savings.*deposit|marcus|ally.*savings|hysa/i,
                        /emergency.*fund|vacation.*fund|sinking.*fund/i
                    ],
                    'long-term': [
                        // Retirement & Investments
                        /401k|403b|ira|roth|vanguard|fidelity|schwab|etrade|robinhood|wealthfront|betterment/i,
                        /investment|brokerage|stock.*purchase|dividend/i
                    ],
                    'guilt-free': [
                        // Dining & Drinks
                        /restaurant|cafe|coffee|starbucks|dunkin|mcdonald|burger|pizza|chipotle|taco.*bell|wendy|chick-fil-a|panera|subway|panda.*express/i,
                        /doordash|uber.*eats|grubhub|postmates|instacart|seamless/i,
                        /bar|brewery|pub|tavern|wine|liquor/i,
                        // Entertainment
                        /netflix|hulu|disney|hbo|amazon.*prime.*video|spotify|apple.*music|youtube.*premium|paramount|peacock/i,
                        /movie|cinema|amc|regal|concert|ticket|eventbrite|stubhub|ticketmaster/i,
                        /gaming|playstation|xbox|nintendo|steam|twitch/i,
                        // Shopping
                        /amazon(?!.*prime.*member)|ebay|etsy|target(?!.*grocery)|walmart(?!.*grocery)|best.*buy|home.*depot|lowes|ikea/i,
                        /nordstrom|macy|kohls|tj.*maxx|marshalls|ross|old.*navy|gap|h&m|zara|uniqlo/i,
                        /sephora|ulta|beauty|salon|spa|haircut|barber|nail/i,
                        // Hobbies & Fitness
                        /gym|fitness|peloton|planet.*fitness|orange.*theory|crossfit|yoga/i,
                        /golf|ski|sports|hobby|craft|book|audible/i,
                        // Subscriptions
                        /subscription|membership|patreon|substack/i,
                        // Travel & Leisure
                        /hotel|airbnb|vrbo|airline|flight|united|delta|american.*air|southwest|jetblue|expedia|booking|kayak/i
                    ],
                    'income': [
                        /payroll|direct.*deposit|salary|wage|employer|paycheck/i,
                        /irs|tax.*refund|refund/i,
                        /dividend|interest.*payment|interest.*earned/i,
                        /venmo.*from|zelle.*from|paypal.*from|cash.*app.*from/i,
                        /reimbursement|expense.*reimburse/i
                    ]
                };

                // Bank format configurations
                this.bankFormats = {
                    'chase': {
                        dateCol: 'Transaction Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        negativeIsExpense: true
                    },
                    'bofa': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        negativeIsExpense: true
                    },
                    'wells': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        negativeIsExpense: true
                    },
                    'citi': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Debit',
                        creditCol: 'Credit',
                        dateFormat: 'MM/DD/YYYY',
                        separateDebitCredit: true
                    },
                    'amex': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        positiveIsExpense: true
                    },
                    'capital-one': {
                        dateCol: 'Transaction Date',
                        descCol: 'Description',
                        amountCol: 'Debit',
                        creditCol: 'Credit',
                        dateFormat: 'YYYY-MM-DD',
                        separateDebitCredit: true
                    },
                    'discover': {
                        dateCol: 'Trans. Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        positiveIsExpense: true
                    },
                    'generic': {
                        dateCol: ['Date', 'Transaction Date', 'Trans Date', 'Posted Date'],
                        descCol: ['Description', 'Memo', 'Name', 'Merchant'],
                        amountCol: ['Amount', 'Transaction Amount', 'Debit', 'Credit'],
                        dateFormat: 'auto',
                        autoDetect: true
                    }
                };

                // Load saved rules from localStorage
                this.loadSavedRules();
                this.init();
            }

            init() {
                // Format selection
                document.querySelectorAll('.format-option').forEach(option => {
                    option.addEventListener('click', (e) => {
                        document.querySelectorAll('.format-option').forEach(o => o.classList.remove('selected'));
                        e.target.classList.add('selected');
                        this.selectedFormat = e.target.dataset.format;
                    });
                });

                // File upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });
                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                // Target inputs
                document.getElementById('monthlyIncome').addEventListener('input', (e) => {
                    this.targets.income = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetFixed').addEventListener('input', (e) => {
                    this.targets.fixedCosts = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetShortTerm').addEventListener('input', (e) => {
                    this.targets.shortTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetLongTerm').addEventListener('input', (e) => {
                    this.targets.longTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetGuiltFree').addEventListener('input', (e) => {
                    this.targets.guiltFree = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });

                // Filters
                document.getElementById('categoryFilter').addEventListener('change', () => this.renderTransactions());
                document.getElementById('sortOrder').addEventListener('change', () => this.renderTransactions());
            }

            handleFiles(files) {
                const promises = Array.from(files).map(file => this.parseCSV(file));

                Promise.all(promises).then(results => {
                    this.transactions = results.flat();
                    this.transactions.sort((a, b) => new Date(b.date) - new Date(a.date));

                    // Auto-categorize
                    this.transactions.forEach(t => {
                        if (!t.category) {
                            t.category = this.categorizeTransaction(t);
                        }
                    });

                    this.updateDisplay();
                    document.getElementById('resultsSection').classList.remove('results-hidden');
                }).catch(error => {
                    console.error('Error parsing files:', error);
                    alert('Error parsing CSV file. Please check the format and try again.');
                });
            }

            parseCSV(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result;
                            const transactions = this.parseCSVText(text);
                            resolve(transactions);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            parseCSVText(text) {
                const lines = text.trim().split('\n');
                if (lines.length < 2) return [];

                // Parse header
                const header = this.parseCSVLine(lines[0]);
                const format = this.bankFormats[this.selectedFormat];

                // Find column indices
                let dateIdx, descIdx, amountIdx, creditIdx;

                if (format.autoDetect) {
                    // Auto-detect columns for generic format
                    dateIdx = this.findColumnIndex(header, format.dateCol);
                    descIdx = this.findColumnIndex(header, format.descCol);
                    amountIdx = this.findColumnIndex(header, format.amountCol);
                } else {
                    dateIdx = header.findIndex(h => h.toLowerCase().trim() === format.dateCol.toLowerCase());
                    descIdx = header.findIndex(h => h.toLowerCase().trim() === format.descCol.toLowerCase());
                    amountIdx = header.findIndex(h => h.toLowerCase().trim() === format.amountCol.toLowerCase());

                    if (format.separateDebitCredit) {
                        creditIdx = header.findIndex(h => h.toLowerCase().trim() === format.creditCol.toLowerCase());
                    }
                }

                // Parse transactions
                const transactions = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = this.parseCSVLine(line);
                    if (values.length < Math.max(dateIdx, descIdx, amountIdx) + 1) continue;

                    const dateStr = values[dateIdx];
                    const description = values[descIdx];
                    let amount;

                    if (format.separateDebitCredit) {
                        const debit = parseFloat(values[amountIdx]?.replace(/[,$]/g, '')) || 0;
                        const credit = parseFloat(values[creditIdx]?.replace(/[,$]/g, '')) || 0;
                        amount = credit - debit;
                    } else {
                        amount = parseFloat(values[amountIdx]?.replace(/[,$]/g, '')) || 0;

                        if (format.positiveIsExpense) {
                            amount = -amount;
                        }
                    }

                    const date = this.parseDate(dateStr, format.dateFormat);
                    if (!date || isNaN(amount)) continue;

                    transactions.push({
                        date: date,
                        description: description,
                        amount: amount,
                        category: null,
                        id: `${date}-${description}-${amount}-${i}`
                    });
                }

                return transactions;
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());

                return result;
            }

            findColumnIndex(header, possibleNames) {
                if (typeof possibleNames === 'string') {
                    return header.findIndex(h => h.toLowerCase().trim() === possibleNames.toLowerCase());
                }

                for (const name of possibleNames) {
                    const idx = header.findIndex(h => h.toLowerCase().trim() === name.toLowerCase());
                    if (idx !== -1) return idx;
                }
                return -1;
            }

            parseDate(dateStr, format) {
                if (!dateStr) return null;

                dateStr = dateStr.replace(/"/g, '').trim();

                // Try various formats
                const formats = [
                    /^(\d{1,2})\/(\d{1,2})\/(\d{4})$/,  // MM/DD/YYYY
                    /^(\d{4})-(\d{2})-(\d{2})$/,        // YYYY-MM-DD
                    /^(\d{1,2})-(\d{1,2})-(\d{4})$/,    // MM-DD-YYYY
                ];

                for (const regex of formats) {
                    const match = dateStr.match(regex);
                    if (match) {
                        if (regex === formats[1]) {
                            // YYYY-MM-DD
                            return `${match[1]}-${match[2]}-${match[3]}`;
                        } else {
                            // MM/DD/YYYY or MM-DD-YYYY
                            const month = match[1].padStart(2, '0');
                            const day = match[2].padStart(2, '0');
                            const year = match[3];
                            return `${year}-${month}-${day}`;
                        }
                    }
                }

                // Fallback: try native Date parsing
                const date = new Date(dateStr);
                if (!isNaN(date.getTime())) {
                    return date.toISOString().split('T')[0];
                }

                return null;
            }

            categorizeTransaction(transaction) {
                const desc = transaction.description.toLowerCase();
                const amount = transaction.amount;

                // Check income first (positive amounts or income patterns)
                if (amount > 0) {
                    for (const pattern of this.categoryPatterns['income']) {
                        if (pattern.test(desc)) {
                            return 'income';
                        }
                    }
                    // If positive but no income pattern, might still be income or refund
                    return 'income';
                }

                // Check expense categories
                for (const [category, patterns] of Object.entries(this.categoryPatterns)) {
                    if (category === 'income') continue;

                    for (const pattern of patterns) {
                        if (pattern.test(desc)) {
                            return category;
                        }
                    }
                }

                return 'uncategorized';
            }

            updateDisplay() {
                this.updateStats();
                this.updateSummaryCards();
                this.updateComparisonChart();
                this.renderTransactions();
            }

            updateStats() {
                const dates = this.transactions.map(t => new Date(t.date)).filter(d => !isNaN(d));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));

                document.getElementById('dateRange').textContent =
                    `Showing transactions from ${minDate.toLocaleDateString()} to ${maxDate.toLocaleDateString()}`;

                const totalIncome = this.transactions
                    .filter(t => t.amount > 0)
                    .reduce((sum, t) => sum + t.amount, 0);

                const totalSpending = this.transactions
                    .filter(t => t.amount < 0)
                    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

                const net = totalIncome - totalSpending;

                document.getElementById('totalTransactions').textContent = this.transactions.length;
                document.getElementById('totalIncome').textContent = this.formatCurrency(totalIncome);
                document.getElementById('totalSpending').textContent = this.formatCurrency(totalSpending);

                const netElement = document.getElementById('netAmount');
                netElement.textContent = this.formatCurrency(net);
                netElement.classList.remove('income', 'expense');
                netElement.classList.add(net >= 0 ? 'income' : 'expense');
            }

            updateSummaryCards() {
                const categories = this.calculateCategoryTotals();
                const totalSpending = Object.entries(categories)
                    .filter(([cat]) => cat !== 'income')
                    .reduce((sum, [, data]) => sum + data.total, 0);

                // Calculate months in data
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const cardsContainer = document.getElementById('summaryCards');
                cardsContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free Spending', targetKey: 'guiltFree' },
                    { key: 'uncategorized', name: 'Uncategorized', targetKey: null }
                ];

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0, count: 0 };
                    const monthlyAvg = data.total / months;
                    const percentage = totalSpending > 0 ? (data.total / totalSpending * 100) : 0;

                    let targetPct = cat.targetKey ? this.targets[cat.targetKey] : 0;
                    let targetAmount = this.targets.income * (targetPct / 100);
                    let diff = monthlyAvg - targetAmount;
                    let diffClass = 'neutral';
                    let diffText = '-';

                    if (cat.targetKey) {
                        if (cat.key === 'short-term' || cat.key === 'long-term') {
                            // For savings, under target is bad
                            diffClass = diff >= 0 ? 'under' : 'over';
                            diffText = diff >= 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        } else {
                            // For spending, over target is bad
                            diffClass = diff <= 0 ? 'under' : 'over';
                            diffText = diff > 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        }
                    }

                    const card = document.createElement('div');
                    card.className = `summary-card ${cat.key}`;
                    card.innerHTML = `
                        <div class="card-header">
                            <span class="card-title">${cat.name}</span>
                            <span class="card-percentage">${percentage.toFixed(1)}%</span>
                        </div>
                        <div class="card-amount">${this.formatCurrency(monthlyAvg)}/mo</div>
                        ${cat.targetKey ? `
                            <div class="card-comparison">
                                <span class="comparison-target">Target: ${this.formatCurrency(targetAmount)}/mo</span>
                                <span class="comparison-diff ${diffClass}">${diffText}</span>
                            </div>
                        ` : `
                            <div class="card-comparison">
                                <span class="comparison-target">${data.count} transactions</span>
                            </div>
                        `}
                    `;
                    cardsContainer.appendChild(card);
                });
            }

            updateComparisonChart() {
                const categories = this.calculateCategoryTotals();

                // Calculate months
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const monthlyIncome = this.targets.income;
                const maxValue = monthlyIncome;

                const chartContainer = document.getElementById('comparisonChart');
                chartContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free', targetKey: 'guiltFree' }
                ];

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0 };
                    const monthlyActual = data.total / months;
                    const targetPct = this.targets[cat.targetKey];
                    const targetAmount = monthlyIncome * (targetPct / 100);

                    const targetWidth = Math.min(100, (targetAmount / maxValue) * 100);
                    const actualWidth = Math.min(100, (monthlyActual / maxValue) * 100);

                    const row = document.createElement('div');
                    row.className = 'comparison-row';
                    row.innerHTML = `
                        <div class="comparison-label">${cat.name}</div>
                        <div class="comparison-bar-container">
                            <div class="comparison-bar target" style="width: ${targetWidth}%"></div>
                            <div class="comparison-bar actual ${cat.key}" style="width: ${actualWidth}%"></div>
                        </div>
                        <div class="comparison-value">
                            <div style="font-size: 0.8em; color: #999;">Target: ${targetPct}%</div>
                            <div>Actual: ${(monthlyActual / monthlyIncome * 100).toFixed(1)}%</div>
                        </div>
                    `;
                    chartContainer.appendChild(row);
                });

                // Add legend
                const legend = document.createElement('div');
                legend.style.cssText = 'display: flex; gap: 20px; justify-content: center; margin-top: 20px; font-size: 0.9em;';
                legend.innerHTML = `
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #e0e0e0; border-radius: 2px; margin-right: 5px;"></span> Target</div>
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #667eea; border-radius: 2px; margin-right: 5px;"></span> Actual</div>
                `;
                chartContainer.appendChild(legend);
            }

            calculateCategoryTotals() {
                const totals = {};

                this.transactions.forEach(t => {
                    const cat = t.category || 'uncategorized';
                    if (!totals[cat]) {
                        totals[cat] = { total: 0, count: 0 };
                    }
                    totals[cat].total += Math.abs(t.amount);
                    totals[cat].count++;
                });

                return totals;
            }

            renderTransactions() {
                const categoryFilter = document.getElementById('categoryFilter').value;
                const sortOrder = document.getElementById('sortOrder').value;

                let filtered = [...this.transactions];

                // Apply category filter
                if (categoryFilter !== 'all') {
                    filtered = filtered.filter(t => t.category === categoryFilter);
                }

                // Apply sort
                switch (sortOrder) {
                    case 'date-desc':
                        filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
                        break;
                    case 'date-asc':
                        filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
                        break;
                    case 'amount-desc':
                        filtered.sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));
                        break;
                    case 'amount-asc':
                        filtered.sort((a, b) => Math.abs(a.amount) - Math.abs(b.amount));
                        break;
                }

                const tbody = document.getElementById('transactionsBody');
                tbody.innerHTML = '';

                filtered.forEach(t => {
                    const row = document.createElement('tr');
                    const isExpense = t.amount < 0;

                    row.innerHTML = `
                        <td>${new Date(t.date).toLocaleDateString()}</td>
                        <td>${this.escapeHtml(t.description)}</td>
                        <td class="amount-cell ${isExpense ? 'expense' : 'income'}">
                            ${isExpense ? '-' : '+'}${this.formatCurrency(Math.abs(t.amount))}
                        </td>
                        <td>
                            <select class="category-select" data-id="${t.id}" onchange="analyzer.updateCategory(this)">
                                <option value="fixed-costs" ${t.category === 'fixed-costs' ? 'selected' : ''}>Fixed Costs</option>
                                <option value="short-term" ${t.category === 'short-term' ? 'selected' : ''}>Short-Term Savings</option>
                                <option value="long-term" ${t.category === 'long-term' ? 'selected' : ''}>Long-Term Savings</option>
                                <option value="guilt-free" ${t.category === 'guilt-free' ? 'selected' : ''}>Guilt-Free</option>
                                <option value="income" ${t.category === 'income' ? 'selected' : ''}>Income</option>
                                <option value="uncategorized" ${t.category === 'uncategorized' ? 'selected' : ''}>Uncategorized</option>
                            </select>
                        </td>
                    `;
                    tbody.appendChild(row);
                });
            }

            updateCategory(select) {
                const id = select.dataset.id;
                const newCategory = select.value;

                const transaction = this.transactions.find(t => t.id === id);
                if (transaction) {
                    transaction.category = newCategory;

                    // Save the rule for this merchant
                    this.saveRule(transaction.description, newCategory);

                    // Update display
                    this.updateStats();
                    this.updateSummaryCards();
                    this.updateComparisonChart();
                }
            }

            saveRule(description, category) {
                // Extract merchant name (first few words, cleaned up)
                const merchantPattern = description
                    .replace(/[0-9#*]+/g, '')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .split(' ')
                    .slice(0, 3)
                    .join(' ')
                    .toLowerCase();

                if (merchantPattern.length < 3) return;

                // Save to localStorage
                const rules = JSON.parse(localStorage.getItem('transactionRules') || '{}');
                rules[merchantPattern] = category;
                localStorage.setItem('transactionRules', JSON.stringify(rules));
            }

            loadSavedRules() {
                const rules = JSON.parse(localStorage.getItem('transactionRules') || '{}');

                // Add saved rules to category patterns
                for (const [pattern, category] of Object.entries(rules)) {
                    if (this.categoryPatterns[category]) {
                        const regex = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                        this.categoryPatterns[category].unshift(regex);
                    }
                }
            }

            saveRules() {
                const rules = JSON.parse(localStorage.getItem('transactionRules') || '{}');
                const blob = new Blob([JSON.stringify(rules, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'transaction-rules.json';
                a.click();
                URL.revokeObjectURL(url);
            }

            exportSummary() {
                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                let summary = `Transaction Analysis Summary\n`;
                summary += `============================\n\n`;
                summary += `Date Range: ${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}\n`;
                summary += `Total Transactions: ${this.transactions.length}\n\n`;

                summary += `Monthly Spending by Category:\n`;
                summary += `-----------------------------\n`;

                const categoryNames = {
                    'fixed-costs': 'Fixed Costs',
                    'short-term': 'Short-Term Savings',
                    'long-term': 'Long-Term Savings',
                    'guilt-free': 'Guilt-Free Spending',
                    'income': 'Income',
                    'uncategorized': 'Uncategorized'
                };

                for (const [key, name] of Object.entries(categoryNames)) {
                    const data = categories[key] || { total: 0, count: 0 };
                    const monthly = data.total / months;
                    summary += `${name}: ${this.formatCurrency(monthly)}/month (${data.count} transactions)\n`;
                }

                const blob = new Blob([summary], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'spending-summary.txt';
                a.click();
                URL.revokeObjectURL(url);
            }

            formatCurrency(value) {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(value);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // AI Categorization Methods
            toggleApiKeyVisibility() {
                const input = document.getElementById('apiKey');
                const btn = event.target;
                if (input.type === 'password') {
                    input.type = 'text';
                    btn.textContent = 'Hide';
                } else {
                    input.type = 'password';
                    btn.textContent = 'Show';
                }
            }

            async aiCategorize() {
                const apiKey = document.getElementById('apiKey').value.trim();
                if (!apiKey) {
                    this.showAiStatus('Please enter your Claude API key', 'error');
                    return;
                }

                const uncategorized = this.transactions.filter(t => t.category === 'uncategorized');
                if (uncategorized.length === 0) {
                    this.showAiStatus('No uncategorized transactions to process!', 'success');
                    return;
                }

                this.showAiStatus(`Processing ${uncategorized.length} uncategorized transactions...`, 'processing');
                document.getElementById('aiCategorizeBtn').disabled = true;

                try {
                    // Process in batches of 50
                    const batchSize = 50;
                    for (let i = 0; i < uncategorized.length; i += batchSize) {
                        const batch = uncategorized.slice(i, i + batchSize);
                        this.showAiStatus(`Processing transactions ${i + 1}-${Math.min(i + batchSize, uncategorized.length)} of ${uncategorized.length}...`, 'processing');

                        const categorizations = await this.callClaudeAPI(apiKey, batch);

                        // Apply categorizations
                        categorizations.forEach(result => {
                            const transaction = this.transactions.find(t => t.id === result.id);
                            if (transaction && result.category) {
                                transaction.category = result.category;
                                // Save the learned rule
                                this.saveRule(transaction.description, result.category);
                            }
                        });
                    }

                    this.updateDisplay();
                    this.showAiStatus(`Successfully categorized ${uncategorized.length} transactions!`, 'success');
                } catch (error) {
                    console.error('AI categorization error:', error);
                    this.showAiStatus(`Error: ${error.message}`, 'error');
                } finally {
                    document.getElementById('aiCategorizeBtn').disabled = false;
                }
            }

            async callClaudeAPI(apiKey, transactions) {
                const transactionList = transactions.map(t => ({
                    id: t.id,
                    description: t.description,
                    amount: t.amount
                }));

                const prompt = `You are a financial transaction categorizer. Categorize each transaction into exactly one of these categories:

- fixed-costs: Essential expenses (rent, mortgage, utilities, insurance, groceries, gas, pharmacy, childcare, minimum debt payments)
- short-term: Transfers to savings accounts, emergency fund deposits
- long-term: Retirement contributions (401k, IRA), investment transfers, brokerage deposits
- guilt-free: Discretionary spending (restaurants, entertainment, shopping, subscriptions, travel, hobbies)
- income: Salary, refunds, reimbursements, interest earned

Here are the transactions to categorize (negative amounts are expenses, positive are income):

${JSON.stringify(transactionList, null, 2)}

Respond with ONLY a JSON array in this exact format, no other text:
[{"id": "transaction-id-here", "category": "category-name-here"}, ...]`;

                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-3-haiku-20240307',
                        max_tokens: 4096,
                        messages: [{
                            role: 'user',
                            content: prompt
                        }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `API request failed: ${response.status}`);
                }

                const data = await response.json();
                const content = data.content[0].text;

                // Parse the JSON response
                try {
                    // Extract JSON from response (in case there's extra text)
                    const jsonMatch = content.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[0]);
                    }
                    throw new Error('No valid JSON array found in response');
                } catch (parseError) {
                    console.error('Failed to parse AI response:', content);
                    throw new Error('Failed to parse AI response');
                }
            }

            showAiStatus(message, type) {
                const status = document.getElementById('aiStatus');
                status.textContent = message;
                status.className = `ai-status show ${type}`;
            }
        }

        // Initialize
        let analyzer;
        document.addEventListener('DOMContentLoaded', () => {
            analyzer = new TransactionAnalyzer();

            // Enable AI button when API key is entered
            document.getElementById('apiKey').addEventListener('input', (e) => {
                document.getElementById('aiCategorizeBtn').disabled = !e.target.value.trim();
            });

            // Load saved API key from localStorage
            const savedKey = localStorage.getItem('claudeApiKey');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
                document.getElementById('aiCategorizeBtn').disabled = false;
            }

            // Save API key when changed
            document.getElementById('apiKey').addEventListener('change', (e) => {
                if (e.target.value.trim()) {
                    localStorage.setItem('claudeApiKey', e.target.value.trim());
                }
            });
        });
    </script>
</body>
</html>
