<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Transaction Analyzer - See Your Spending Reality</title>
    <script src="shared.js?v=20251229"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f5f7fa;
            border-radius: 8px;
        }

        .section h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        .section h3 {
            margin-bottom: 10px;
            color: #555;
            font-size: 1.1em;
        }

        /* Upload Section */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .upload-area:hover {
            background: #f0f4ff;
            border-color: #5568d3;
        }

        .upload-area.dragover {
            background: #e8edff;
            border-color: #4455c7;
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 5px;
        }

        .upload-hint {
            font-size: 0.9em;
            color: #999;
        }

        /* Bank Format Selection */
        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .format-option {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s;
        }

        .format-option:hover {
            border-color: #667eea;
        }

        .format-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Targets Section */
        .targets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .target-input {
            display: flex;
            flex-direction: column;
        }

        .target-input label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .target-input input {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
        }

        .target-input input:focus {
            outline: none;
            border-color: #667eea;
        }

        .target-input select {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .target-input select:focus {
            outline: none;
            border-color: #667eea;
        }

        .target-input select:hover {
            border-color: #bbb;
        }

        /* Results Section */
        .results-hidden {
            display: none;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid;
        }

        .summary-card.fixed-costs { border-left-color: #ef4444; }
        .summary-card.short-term { border-left-color: #f59e0b; }
        .summary-card.long-term { border-left-color: #10b981; }
        .summary-card.guilt-free { border-left-color: #8b5cf6; }
        .summary-card.uncategorized { border-left-color: #6b7280; }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .card-percentage {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .card-amount {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .card-comparison {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .comparison-target {
            color: #666;
        }

        .comparison-diff {
            font-weight: 600;
        }

        .comparison-diff.over { color: #ef4444; }
        .comparison-diff.under { color: #10b981; }
        .comparison-diff.neutral { color: #6b7280; }

        /* Progress Bar */
        .progress-container {
            margin-top: 10px;
        }

        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .progress-target {
            position: absolute;
            top: -4px;
            width: 2px;
            height: 16px;
            background: #333;
        }

        /* Transactions Table */
        .transactions-container {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .transactions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
        }

        .transactions-table {
            width: 100%;
            border-collapse: collapse;
        }

        .transactions-table th,
        .transactions-table td {
            padding: 12px 20px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transactions-table tr:hover {
            background: #f9fafb;
        }

        .amount-cell {
            font-weight: 600;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .amount-cell.expense { color: #ef4444; }
        .amount-cell.income { color: #10b981; }

        .category-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .category-badge.fixed-costs { background: #fee2e2; color: #dc2626; }
        .category-badge.short-term { background: #fef3c7; color: #d97706; }
        .category-badge.long-term { background: #d1fae5; color: #059669; }
        .category-badge.guilt-free { background: #ede9fe; color: #7c3aed; }
        .category-badge.uncategorized { background: #f3f4f6; color: #6b7280; }
        .category-badge.income { background: #dbeafe; color: #2563eb; }

        .category-select {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* Comparison Chart */
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .chart-title {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 20px;
            text-align: center;
        }

        .comparison-bars {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .comparison-row {
            display: grid;
            grid-template-columns: 150px 1fr 80px;
            gap: 15px;
            align-items: center;
        }

        .comparison-label {
            font-weight: 500;
            text-align: right;
        }

        .comparison-bar-container {
            position: relative;
            height: 30px;
        }

        .comparison-bar {
            position: absolute;
            height: 12px;
            border-radius: 6px;
            transition: width 0.5s;
        }

        .comparison-bar.target {
            top: 0;
            background: #e0e0e0;
        }

        .comparison-bar.actual {
            top: 16px;
        }

        .comparison-bar.actual.fixed-costs { background: #ef4444; }
        .comparison-bar.actual.short-term { background: #f59e0b; }
        .comparison-bar.actual.long-term { background: #10b981; }
        .comparison-bar.actual.guilt-free { background: #8b5cf6; }

        .comparison-value {
            font-weight: 600;
            font-size: 0.9em;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover {
            background: #f0f4ff;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        /* Footer */
        footer {
            background: #f5f5f5;
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Navigation Tabs */
        .nav-tabs {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            background: transparent;
            gap: 8px;
            padding: 0 20px;
        }

        .nav-tab {
            flex: 1;
            padding: 14px 16px;
            text-align: center;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
            font-size: 0.95em;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            background: transparent;
        }

        .nav-tab:hover {
            color: rgba(255, 255, 255, 0.95);
        }

        .nav-tab.active {
            color: white;
            border-bottom-color: white;
            font-weight: 600;
        }

        /* Accessibility: Skip link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #667eea;
            color: white;
            padding: 8px 16px;
            z-index: 100;
            text-decoration: none;
            font-weight: 600;
            border-radius: 0 0 4px 0;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Info Box */
        .info-box {
            background: #dbeafe;
            border: 1px solid #93c5fd;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #1e40af;
            font-size: 0.95em;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        /* API Key Section */
        .api-key-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .api-key-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            font-family: monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .ai-status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            display: none;
        }

        .ai-status.show {
            display: block;
        }

        .ai-status.processing {
            background: #dbeafe;
            color: #1e40af;
        }

        .ai-status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .ai-status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .provider-select {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            min-width: 180px;
        }

        .provider-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .api-help {
            margin-top: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .api-help a {
            color: #667eea;
            text-decoration: none;
        }

        .api-help a:hover {
            text-decoration: underline;
        }

        .cors-notice {
            background: #fef3c7;
            border: 1px solid #fcd34d;
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 15px;
            color: #92400e;
            font-size: 0.9em;
        }

        /* Upload Guidance */
        .upload-guidance {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .guidance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .guidance-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .guidance-item.essential {
            border-left: 3px solid #10b981;
        }

        .guidance-item.recommended {
            border-left: 3px solid #f59e0b;
        }

        .guidance-icon {
            font-size: 1.2em;
        }

        .guidance-item div {
            display: flex;
            flex-direction: column;
        }

        .guidance-item strong {
            font-size: 0.95em;
            color: #333;
        }

        .guidance-item span:not(.guidance-icon) {
            font-size: 0.85em;
            color: #666;
        }

        .guidance-tip {
            margin-top: 15px;
            font-size: 0.9em;
            color: #0369a1;
            font-style: italic;
        }

        /* Bulk Categorization */
        .bulk-group {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .bulk-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            cursor: pointer;
            background: #f9fafb;
            transition: background 0.2s;
            gap: 10px;
        }

        .bulk-group-header:hover {
            background: #f3f4f6;
        }

        .bulk-group-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            flex: 1;
        }

        .bulk-group-name {
            font-weight: 600;
            color: #333;
            word-break: break-word;
        }

        .bulk-group-count {
            font-size: 0.85em;
            color: #666;
        }

        .bulk-group-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .bulk-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.1s;
            font-weight: 500;
        }

        .bulk-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        .bulk-btn:active {
            transform: scale(0.98);
        }

        .bulk-btn.fixed-costs { background: #fee2e2; color: #dc2626; }
        .bulk-btn.short-term { background: #fef3c7; color: #d97706; }
        .bulk-btn.long-term { background: #d1fae5; color: #059669; }
        .bulk-btn.guilt-free { background: #ede9fe; color: #7c3aed; }
        .bulk-btn.income { background: #dbeafe; color: #2563eb; }

        .bulk-group-details {
            display: none;
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            background: white;
            max-height: 200px;
            overflow-y: auto;
        }

        .bulk-group.expanded .bulk-group-details {
            display: block;
        }

        .bulk-transaction {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
            font-size: 0.9em;
            gap: 10px;
        }

        .bulk-transaction:last-child {
            border-bottom: none;
        }

        .bulk-transaction span:first-child {
            flex: 1;
            min-width: 0;
            word-break: break-word;
        }

        /* Upload Success State */
        .upload-area.success {
            border-color: #10b981;
            background: #d1fae5;
        }

        .upload-success-info {
            margin-top: 15px;
            padding: 12px 15px;
            background: #d1fae5;
            border: 1px solid #6ee7b7;
            border-radius: 6px;
            color: #065f46;
            font-size: 0.95em;
        }

        .upload-success-info strong {
            display: block;
            margin-bottom: 5px;
        }

        /* Mobile Transaction Cards */
        .transaction-cards {
            display: none;
        }

        .transaction-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .transaction-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .transaction-card-desc {
            font-weight: 500;
            color: #333;
            word-break: break-word;
            flex: 1;
        }

        .transaction-card-amount {
            font-weight: 700;
            font-family: 'SF Mono', Monaco, monospace;
            white-space: nowrap;
        }

        .transaction-card-amount.expense { color: #ef4444; }
        .transaction-card-amount.income { color: #10b981; }

        .transaction-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .transaction-card-date {
            font-size: 0.85em;
            color: #666;
        }

        .transaction-card-category {
            flex: 1;
        }

        .transaction-card-category select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #f9fafb;
            font-size: 0.9em;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .nav-tabs {
                padding: 0 10px;
                gap: 4px;
            }

            .nav-tab {
                padding: 12px 8px;
                font-size: 0.85em;
            }

            header {
                padding: 20px;
            }

            header h1 {
                font-size: 1.5em;
            }

            header p {
                font-size: 0.95em;
            }

            .content {
                padding: 15px;
            }

            .section {
                padding: 15px;
                margin-bottom: 20px;
            }

            .comparison-row {
                grid-template-columns: 1fr;
                gap: 5px;
            }

            .comparison-label {
                text-align: left;
            }

            /* Hide table, show cards on mobile */
            .table-scroll {
                display: none;
            }

            .transaction-cards {
                display: block;
                max-height: 600px;
                overflow-y: auto;
            }

            .transactions-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .filter-controls {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .filter-select {
                flex: 1;
                min-width: 120px;
            }

            /* Bulk categorization mobile */
            .bulk-group-header {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .bulk-group-actions {
                justify-content: flex-start;
            }

            .bulk-btn {
                padding: 10px 14px;
                font-size: 0.9em;
            }

            /* Upload area mobile */
            .upload-area {
                padding: 30px 20px;
            }

            .upload-icon {
                font-size: 36px;
            }

            /* Targets grid mobile */
            .targets-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .target-input:first-child {
                grid-column: 1 / -1;
            }

            /* Format grid mobile */
            .format-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            /* Summary cards mobile */
            .summary-cards {
                grid-template-columns: 1fr;
            }

            /* Stats row mobile */
            .stats-row {
                grid-template-columns: repeat(2, 1fr);
            }

            /* API section mobile */
            .api-key-wrapper {
                flex-direction: column;
            }

            .provider-select,
            .api-key-input {
                width: 100%;
            }

            /* Action buttons mobile */
            .action-buttons {
                flex-direction: column;
            }

            .action-buttons .btn {
                width: 100%;
                text-align: center;
            }

            /* Guidance grid mobile */
            .guidance-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .targets-grid {
                grid-template-columns: 1fr;
            }

            .stats-row {
                grid-template-columns: 1fr;
            }

            .bulk-group-actions {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .bulk-btn {
                text-align: center;
            }
        }

        /* Scrollable table container */
        .table-scroll {
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }

        /* Date range display */
        .date-range {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }

        /* Stats row */
        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: #333;
        }

        .stat-value.expense { color: #ef4444; }
        .stat-value.income { color: #10b981; }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <nav class="nav-tabs" role="navigation" aria-label="Main navigation">
        <a href="income-allocation.html" class="nav-tab">Budget Planner</a>
        <a href="transaction-analyzer.html" class="nav-tab active" aria-current="page">Spending Tracker</a>
        <a href="index.html" class="nav-tab">Retirement Forecast</a>
    </nav>

    <div class="container" role="document">
        <header role="banner">
            <h1>Spending Tracker</h1>
            <p>Upload your bank transactions to see your actual spending vs. your goals</p>
        </header>

        <main id="main-content" class="content" role="main">
            <!-- Step 1: Set Targets -->
            <div class="section">
                <h2>Step 1: Set Your Target Allocations</h2>
                <p style="color: #666; margin-bottom: 15px;">Enter your monthly take-home pay and how you want to divide it. <a href="income-allocation.html" style="color: #667eea;">Need help deciding? Use the Budget Planner first.</a></p>

                <div class="targets-grid">
                    <div class="target-input">
                        <label for="monthlyIncome">Monthly Income</label>
                        <input type="text" id="monthlyIncome" value="$5,000.00" inputmode="decimal" autocomplete="transaction-amount">
                    </div>
                    <div class="target-input">
                        <label for="targetFixed">Bills & Essentials %</label>
                        <input type="number" id="targetFixed" value="50" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetShortTerm">Savings Goals %</label>
                        <input type="number" id="targetShortTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetLongTerm">Retirement %</label>
                        <input type="number" id="targetLongTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetGuiltFree">Fun Money %</label>
                        <input type="number" id="targetGuiltFree" value="10" min="0" max="100">
                    </div>
                </div>
            </div>

            <!-- Step 2: Upload -->
            <div class="section">
                <h2>Step 2: Upload Your Transactions</h2>

                <div class="upload-guidance">
                    <strong>For an accurate spending picture, upload transactions from:</strong>
                    <div class="guidance-grid">
                        <div class="guidance-item essential">
                            <span class="guidance-icon">&#9989;</span>
                            <div>
                                <strong>Primary Checking Account</strong>
                                <span>Where bills & transfers come from</span>
                            </div>
                        </div>
                        <div class="guidance-item essential">
                            <span class="guidance-icon">&#9989;</span>
                            <div>
                                <strong>Credit Cards</strong>
                                <span>Daily spending & subscriptions</span>
                            </div>
                        </div>
                        <div class="guidance-item recommended">
                            <span class="guidance-icon">&#128161;</span>
                            <div>
                                <strong>Savings Accounts</strong>
                                <span>To track savings transfers</span>
                            </div>
                        </div>
                        <div class="guidance-item recommended">
                            <span class="guidance-icon">&#128161;</span>
                            <div>
                                <strong>Investment Accounts</strong>
                                <span>401k/IRA contributions</span>
                            </div>
                        </div>
                    </div>
                    <p class="guidance-tip">Tip: Export 3-6 months of data for the most accurate monthly averages</p>

                    <div style="background: #fff4e6; border: 1px solid #ffb020; border-radius: 6px; padding: 15px; margin-top: 15px;">
                        <strong style="color: #b45309; display: block; margin-bottom: 8px;">&#128200; How to Export Multiple Statements:</strong>
                        <ul style="color: #92400e; font-size: 0.9em; margin: 0; padding-left: 20px; line-height: 1.6;">
                            <li><strong>Chase:</strong> Log in → Activity → Select account → Download → Choose date range → CSV format</li>
                            <li><strong>Bank of America:</strong> Accounts → Select account → Export Transactions → CSV</li>
                            <li><strong>Wells Fargo:</strong> Accounts → Select account → Download Transactions → CSV</li>
                            <li><strong>Citi:</strong> Account Activity → Download → CSV</li>
                            <li><strong>American Express:</strong> Account → Statements & Activity → Download → CSV</li>
                            <li><strong>Capital One:</strong> Transactions → Download → CSV</li>
                        </ul>
                        <p style="margin: 10px 0 5px 0; color: #b45309; font-size: 0.9em;"><strong>&#10004; Multiple File Upload:</strong> You can select and upload multiple CSV files at once (Ctrl/Cmd+Click to select multiple files)</p>
                        <p style="margin: 5px 0 0 0; color: #b45309; font-size: 0.85em; font-style: italic;">&#9888; Automatic Deduplication: Inter-account transfers (like credit card payments from checking) are automatically detected and excluded from income/spending totals to prevent double-counting.</p>
                    </div>
                </div>

                <div class="upload-area" id="uploadArea">
                    <input type="file" id="fileInput" accept=".csv" multiple>
                    <div class="upload-icon">&#128196;</div>
                    <div class="upload-text">Drop CSV files here or click to upload</div>
                    <div class="upload-hint">You can upload multiple files from different accounts</div>
                </div>
            </div>

            <!-- AI Categorization (Optional) -->
            <div class="section" id="aiSection">
                <h2>AI-Powered Categorization (Optional)</h2>
                <p style="color: #666; margin-bottom: 15px;">Select your AI provider and enter your API key to automatically categorize transactions. Your key is stored locally in your browser.</p>

                <div class="api-key-wrapper">
                    <select id="aiProvider" class="provider-select">
                        <option value="gemini">Google Gemini</option>
                        <option value="openai">OpenAI (GPT-4o-mini)</option>
                        <option value="anthropic">Anthropic Claude</option>
                    </select>
                    <input type="password" id="apiKey" placeholder="Enter API key..." class="api-key-input">
                    <button class="btn btn-secondary" onclick="analyzer.toggleApiKeyVisibility()">Show</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" id="aiCategorizeBtn" onclick="analyzer.aiCategorize()" disabled>AI Categorize Uncategorized</button>
                </div>
                <div id="aiStatus" class="ai-status"></div>
                <div class="api-help">
                    <strong>Get a free API key:</strong>
                    <a href="https://aistudio.google.com/apikey" target="_blank">Google Gemini (free tier)</a> |
                    <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI</a> |
                    <a href="https://console.anthropic.com/" target="_blank">Anthropic</a>
                </div>
            </div>

            <!-- Results Section (hidden until data uploaded) -->
            <div id="resultsSection" class="results-hidden">
                <!-- Date Range and Stats -->
                <div class="section">
                    <h2>Analysis Summary</h2>
                    <div class="date-range" id="dateRange"></div>
                    <div class="stats-row">
                        <div class="stat-box">
                            <div class="stat-label">Total Transactions</div>
                            <div class="stat-value" id="totalTransactions">0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Income</div>
                            <div class="stat-value income" id="totalIncome">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Spending</div>
                            <div class="stat-value expense" id="totalSpending">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Net</div>
                            <div class="stat-value" id="netAmount">$0</div>
                        </div>
                    </div>
                </div>

                <!-- Comparison Chart -->
                <div class="section">
                    <h2>Goal vs Reality</h2>
                    <div class="chart-container">
                        <div class="chart-title">Target Allocation vs Actual Spending (Monthly Average)</div>
                        <div class="comparison-bars" id="comparisonChart"></div>
                    </div>
                </div>

                <!-- Category Cards -->
                <div class="summary-cards" id="summaryCards"></div>

                <!-- Bulk Categorization -->
                <div class="section" id="bulkCategorizeSection" style="display: none;">
                    <h2>Quick Categorize</h2>
                    <p style="color: #666; margin-bottom: 15px;">Group similar transactions and categorize them all at once. Click a group to expand and categorize.</p>
                    <div id="bulkGroups"></div>
                </div>

                <!-- Transactions Table -->
                <div class="section">
                    <h2>Transaction Details</h2>
                    <div class="transactions-container">
                        <div class="transactions-header">
                            <span class="transactions-title">All Transactions</span>
                            <div class="filter-controls">
                                <select class="filter-select" id="categoryFilter">
                                    <option value="all">All Categories</option>
                                    <option value="fixed-costs">Fixed Costs</option>
                                    <option value="short-term">Short-Term Savings</option>
                                    <option value="long-term">Long-Term Savings</option>
                                    <option value="guilt-free">Guilt-Free Spending</option>
                                    <option value="income">Income</option>
                                    <option value="uncategorized">Uncategorized</option>
                                    <option value="transfers">Transfers (Excluded)</option>
                                </select>
                                <select class="filter-select" id="sortOrder">
                                    <option value="date-desc">Date (Newest)</option>
                                    <option value="date-asc">Date (Oldest)</option>
                                    <option value="amount-desc">Amount (High to Low)</option>
                                    <option value="amount-asc">Amount (Low to High)</option>
                                </select>
                            </div>
                        </div>
                        <!-- Desktop Table View -->
                        <div class="table-scroll">
                            <table class="transactions-table">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Description</th>
                                        <th>Amount</th>
                                        <th>Category</th>
                                    </tr>
                                </thead>
                                <tbody id="transactionsBody"></tbody>
                            </table>
                        </div>
                        <!-- Mobile Card View -->
                        <div class="transaction-cards" id="transactionCards"></div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="action-buttons">
                    <button class="btn btn-secondary" onclick="analyzer.exportSummary()">Export Summary</button>
                    <button class="btn btn-primary" onclick="analyzer.saveRules()">Save Categorization Rules</button>
                    <a href="income-allocation.html" class="btn btn-success">Adjust Your Allocation Plan</a>
                </div>
            </div>
        </main>

        <footer role="contentinfo">
            <a href="income-allocation.html">Budget Planner</a> |
            <a href="index.html">Retirement Forecast</a>
        </footer>
    </div>

    <script>
        class TransactionAnalyzer {
            constructor() {
                this.transactions = [];
                this.selectedFormat = 'generic';
                this.targets = {
                    income: 5000,
                    fixedCosts: 50,
                    shortTerm: 20,
                    longTerm: 20,
                    guiltFree: 10
                };

                // Category patterns for auto-categorization
                this.categoryPatterns = {
                    'fixed-costs': [
                        // Housing
                        /rent|mortgage|hoa|property.*tax|home.*insurance|landlord|apartment|lease/i,
                        // Utilities
                        /electric|gas.*company|water.*bill|sewage|trash|waste|pge|con.*ed|duke.*energy|xcel|national.*grid|dominion/i,
                        /comcast|xfinity|spectrum|at&t|verizon|t-mobile|sprint|cricket|internet|cable|fiber|broadband/i,
                        // Phone
                        /phone.*bill|wireless|cell.*phone|mobile.*plan/i,
                        // Insurance
                        /geico|allstate|state.*farm|progressive|liberty.*mutual|insurance|health.*plan|aetna|cigna|united.*health|blue.*cross|anthem|kaiser/i,
                        // Car
                        /car.*payment|auto.*loan|toyota.*financial|honda.*financial|ford.*credit|gm.*financial|bmw.*financial|mercedes.*financial/i,
                        // Debt payments
                        /student.*loan|nelnet|navient|fedloan|sofi|earnest|loan.*payment|great.*lakes|mohela/i,
                        /credit.*card.*payment|minimum.*payment|debt.*payment/i,
                        // Groceries (essential)
                        /grocery|safeway|kroger|publix|trader.*joe|whole.*foods|aldi|costco|walmart|target|wegmans|heb|albertsons|giant|stop.*shop|food.*lion|winco|sprouts|meijer|food.*city/i,
                        // Healthcare essentials
                        /pharmacy|cvs|walgreens|rite.*aid|prescription|doctor|medical|copay|hospital|clinic|urgent.*care|lab|quest.*diagnostics|labcorp/i,
                        // Childcare
                        /daycare|childcare|preschool|tuition|school|kindercare|bright.*horizons/i,
                        // Transportation essentials
                        /gas.*station|shell|chevron|exxon|mobil|bp|arco|speedway|wawa|parking|toll|ez.*pass|sunpass|fastrak/i,
                        /uber(?!.*eats)|lyft|transit|metro|subway.*fare|bus.*pass|caltrain|bart|mta|wmata/i,
                        // Bank fees (unfortunately essential)
                        /bank.*fee|monthly.*fee|service.*charge|overdraft/i
                    ],
                    'short-term': [
                        // Savings transfers
                        /transfer.*to.*savings|savings.*deposit|marcus|ally.*savings|hysa/i,
                        /emergency.*fund|vacation.*fund|sinking.*fund/i
                    ],
                    'long-term': [
                        // Retirement & Investments
                        /401k|403b|ira|roth|vanguard|fidelity|schwab|etrade|robinhood|wealthfront|betterment/i,
                        /investment|brokerage|stock.*purchase|dividend/i
                    ],
                    'guilt-free': [
                        // Dining & Drinks
                        /restaurant|cafe|coffee|starbucks|dunkin|mcdonald|burger|pizza|chipotle|taco.*bell|wendy|chick-fil-a|panera|subway|panda.*express/i,
                        /doordash|uber.*eats|grubhub|postmates|instacart|seamless|caviar|gopuff/i,
                        /bar|brewery|pub|tavern|wine|liquor|total.*wine|bevmo/i,
                        // Entertainment & Streaming
                        /netflix|hulu|disney|hbo|max|amazon.*prime|spotify|apple.*music|youtube.*premium|paramount|peacock|crunchyroll|funimation/i,
                        /movie|cinema|amc|regal|concert|ticket|eventbrite|stubhub|ticketmaster|livenation|fandango/i,
                        /gaming|playstation|xbox|nintendo|steam|twitch|epic.*games|riot|blizzard/i,
                        // Apple (subscriptions, App Store, iTunes)
                        /apple\.com|apple\.com\/bill|itunes|app.*store|icloud/i,
                        // Google (Play Store, YouTube, etc)
                        /google.*play|google.*storage|google.*one|youtube/i,
                        // Other Tech Subscriptions
                        /microsoft|office.*365|adobe|creative.*cloud|dropbox|evernote|notion|slack|zoom|canva/i,
                        // Shopping
                        /amazon(?!.*prime.*member)|ebay|etsy|target(?!.*grocery)|walmart(?!.*grocery)|best.*buy|home.*depot|lowes|ikea|wayfair|overstock/i,
                        /nordstrom|macy|kohls|tj.*maxx|marshalls|ross|old.*navy|gap|h&m|zara|uniqlo|shein|asos|fashion.*nova/i,
                        /sephora|ulta|beauty|salon|spa|haircut|barber|nail|massage/i,
                        // Hobbies & Fitness
                        /gym|fitness|peloton|planet.*fitness|orange.*theory|crossfit|yoga|equinox|lifetime/i,
                        /golf|ski|sports|hobby|craft|book|audible|kindle|barnes.*noble/i,
                        // Subscriptions & Memberships
                        /subscription|membership|patreon|substack|medium|onlyfans|twitch.*sub/i,
                        /amazon.*prime.*member|costco.*member|sam.*club.*member/i,
                        // Travel & Leisure
                        /hotel|airbnb|vrbo|airline|flight|united|delta|american.*air|southwest|jetblue|spirit|frontier|expedia|booking|kayak|hotels\.com|tripadvisor/i,
                        // Food delivery & meal kits
                        /hellofresh|blue.*apron|factor|freshly|daily.*harvest/i,
                        // Dating & Social
                        /tinder|bumble|hinge|match\.com|dating/i,
                        // Pet
                        /petco|petsmart|chewy|pet.*supplies/i
                    ],
                    'income': [
                        /payroll|direct.*deposit|salary|wage|employer|paycheck/i,
                        /irs|tax.*refund|refund/i,
                        /dividend|interest.*payment|interest.*earned/i,
                        /venmo.*from|zelle.*from|paypal.*from|cash.*app.*from/i,
                        /reimbursement|expense.*reimburse/i
                    ]
                };

                // Bank format configurations
                this.bankFormats = {
                    'chase': {
                        dateCol: 'Transaction Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        negativeIsExpense: true
                    },
                    'bofa': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        negativeIsExpense: true
                    },
                    'wells': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        negativeIsExpense: true
                    },
                    'citi': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Debit',
                        creditCol: 'Credit',
                        dateFormat: 'MM/DD/YYYY',
                        separateDebitCredit: true
                    },
                    'amex': {
                        dateCol: 'Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        positiveIsExpense: true
                    },
                    'capital-one': {
                        dateCol: 'Transaction Date',
                        descCol: 'Description',
                        amountCol: 'Debit',
                        creditCol: 'Credit',
                        dateFormat: 'YYYY-MM-DD',
                        separateDebitCredit: true
                    },
                    'discover': {
                        dateCol: 'Trans. Date',
                        descCol: 'Description',
                        amountCol: 'Amount',
                        dateFormat: 'MM/DD/YYYY',
                        positiveIsExpense: true
                    },
                    'generic': {
                        dateCol: ['Date', 'Transaction Date', 'Trans Date', 'Posted Date'],
                        descCol: ['Description', 'Memo', 'Name', 'Merchant'],
                        amountCol: ['Amount', 'Transaction Amount', 'Debit', 'Credit'],
                        dateFormat: 'auto',
                        autoDetect: true
                    }
                };

                // Load saved rules from localStorage
                this.loadSavedRules();
                this.init();
            }

            init() {
                // File upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });
                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                // Target inputs - monthlyIncome with currency formatting
                const incomeInput = document.getElementById('monthlyIncome');
                incomeInput.addEventListener('input', (e) => {
                    this.targets.income = this.parseCurrencyValue(e.target.value);
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                incomeInput.addEventListener('focus', (e) => {
                    const value = this.parseCurrencyValue(e.target.value);
                    e.target.value = value > 0 ? value.toFixed(2) : '';
                });
                incomeInput.addEventListener('blur', (e) => {
                    const value = this.parseCurrencyValue(e.target.value);
                    e.target.value = this.formatCurrencyInput(value);
                });
                document.getElementById('targetFixed').addEventListener('input', (e) => {
                    this.targets.fixedCosts = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetShortTerm').addEventListener('input', (e) => {
                    this.targets.shortTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetLongTerm').addEventListener('input', (e) => {
                    this.targets.longTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetGuiltFree').addEventListener('input', (e) => {
                    this.targets.guiltFree = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });

                // Filters
                document.getElementById('categoryFilter').addEventListener('change', () => this.renderTransactions());
                document.getElementById('sortOrder').addEventListener('change', () => this.renderTransactions());
            }

            handleFiles(files) {
                const fileNames = Array.from(files).map(f => f.name);
                const promises = Array.from(files).map(file => this.parseCSV(file));

                Promise.all(promises).then(results => {
                    this.transactions = results.flat();
                    this.transactions.sort((a, b) => new Date(b.date) - new Date(a.date));

                    // Deduplicate inter-account transfers
                    this.deduplicateTransfers();

                    // Auto-categorize
                    this.transactions.forEach(t => {
                        if (!t.category) {
                            t.category = this.categorizeTransaction(t);
                        }
                    });

                    this.updateDisplay();
                    document.getElementById('resultsSection').classList.remove('results-hidden');

                    // Show upload success feedback
                    this.showUploadSuccess(fileNames, this.transactions.length);

                    // Save spending data for Retirement Forecast page
                    this.saveSpendingDataForRetirement();
                }).catch(error => {
                    console.error('Error parsing files:', error);
                    alert('Error parsing CSV file. Please check the format and try again.');
                });
            }

            showUploadSuccess(fileNames, transactionCount) {
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.classList.add('success');

                // Remove existing success info if any
                const existingInfo = document.querySelector('.upload-success-info');
                if (existingInfo) existingInfo.remove();

                // Create success message
                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                const successInfo = document.createElement('div');
                successInfo.className = 'upload-success-info';
                let message = `<strong>Successfully loaded ${transactionCount} transactions!</strong>`;
                if (transferCount > 0) {
                    message += `<span style="color: #10b981; font-size: 0.9em; margin-top: 5px; display: block;">&#10004; ${transferCount} inter-account transfers detected and excluded from totals</span>`;
                }
                message += `<span style="margin-top: 5px; display: block;">Files: ${fileNames.map(n => this.escapeHtml(n)).join(', ')}</span>`;
                successInfo.innerHTML = message;
                uploadArea.parentNode.insertBefore(successInfo, uploadArea.nextSibling);

                // Update upload area text
                uploadArea.querySelector('.upload-text').textContent = 'Drop more CSV files to add transactions';
            }

            saveSpendingDataForRetirement() {
                // Calculate monthly averages for Retirement Forecast
                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const monthlySpending = (categories['fixed-costs']?.total || 0) / months +
                                        (categories['guilt-free']?.total || 0) / months;
                const monthlyLongTermSavings = (categories['long-term']?.total || 0) / months;

                // Save for Retirement Forecast
                StorageUtils.set('spendingTrackerData', {
                    monthlySpending: Math.round(monthlySpending),
                    monthlyRetirementSavings: Math.round(monthlyLongTermSavings),
                    lastUpdated: new Date().toISOString()
                });
            }

            parseCSV(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result;
                            const transactions = this.parseCSVText(text);
                            resolve(transactions);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            parseCSVText(text) {
                const lines = text.trim().split('\n');
                if (lines.length < 2) return [];

                // Parse header
                const header = this.parseCSVLine(lines[0]);
                const format = this.bankFormats[this.selectedFormat];

                // Find column indices
                let dateIdx, descIdx, amountIdx, creditIdx;

                if (format.autoDetect) {
                    // Auto-detect columns for generic format
                    dateIdx = this.findColumnIndex(header, format.dateCol);
                    descIdx = this.findColumnIndex(header, format.descCol);
                    amountIdx = this.findColumnIndex(header, format.amountCol);
                } else {
                    dateIdx = header.findIndex(h => h.toLowerCase().trim() === format.dateCol.toLowerCase());
                    descIdx = header.findIndex(h => h.toLowerCase().trim() === format.descCol.toLowerCase());
                    amountIdx = header.findIndex(h => h.toLowerCase().trim() === format.amountCol.toLowerCase());

                    if (format.separateDebitCredit) {
                        creditIdx = header.findIndex(h => h.toLowerCase().trim() === format.creditCol.toLowerCase());
                    }
                }

                // Parse transactions
                const transactions = [];
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = this.parseCSVLine(line);
                    if (values.length < Math.max(dateIdx, descIdx, amountIdx) + 1) continue;

                    const dateStr = values[dateIdx];
                    const description = values[descIdx];
                    let amount;

                    if (format.separateDebitCredit) {
                        const debit = parseFloat(values[amountIdx]?.replace(/[,$]/g, '')) || 0;
                        const credit = parseFloat(values[creditIdx]?.replace(/[,$]/g, '')) || 0;
                        amount = credit - debit;
                    } else {
                        amount = parseFloat(values[amountIdx]?.replace(/[,$]/g, '')) || 0;

                        if (format.positiveIsExpense) {
                            amount = -amount;
                        }
                    }

                    const date = this.parseDate(dateStr, format.dateFormat);
                    if (!date || isNaN(amount)) continue;

                    transactions.push({
                        date: date,
                        description: description,
                        amount: amount,
                        category: null,
                        id: `${date}-${description}-${amount}-${i}`
                    });
                }

                return transactions;
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());

                return result;
            }

            findColumnIndex(header, possibleNames) {
                if (typeof possibleNames === 'string') {
                    return header.findIndex(h => h.toLowerCase().trim() === possibleNames.toLowerCase());
                }

                for (const name of possibleNames) {
                    const idx = header.findIndex(h => h.toLowerCase().trim() === name.toLowerCase());
                    if (idx !== -1) return idx;
                }
                return -1;
            }

            parseDate(dateStr, format) {
                return DateUtils.parseDate(dateStr);
            }

            categorizeTransaction(transaction) {
                const desc = transaction.description.toLowerCase();
                const amount = transaction.amount;

                // Check income first (positive amounts or income patterns)
                if (amount > 0) {
                    for (const pattern of this.categoryPatterns['income']) {
                        if (pattern.test(desc)) {
                            return 'income';
                        }
                    }
                    // If positive but no income pattern, might still be income or refund
                    return 'income';
                }

                // Check expense categories
                for (const [category, patterns] of Object.entries(this.categoryPatterns)) {
                    if (category === 'income') continue;

                    for (const pattern of patterns) {
                        if (pattern.test(desc)) {
                            return category;
                        }
                    }
                }

                return 'uncategorized';
            }

            deduplicateTransfers() {
                // Mark inter-account transfers as duplicates
                // A transfer is detected when:
                // 1. Two transactions have similar amounts (one positive, one negative)
                // 2. Dates are within 5 days of each other
                // 3. Amounts match within $0.50 tolerance

                const DAYS_TOLERANCE = 5;
                const AMOUNT_TOLERANCE = 0.50;

                // Reset all isTransfer flags
                this.transactions.forEach(t => t.isTransfer = false);

                for (let i = 0; i < this.transactions.length; i++) {
                    const t1 = this.transactions[i];
                    if (t1.isTransfer) continue; // Already marked as transfer

                    for (let j = i + 1; j < this.transactions.length; j++) {
                        const t2 = this.transactions[j];
                        if (t2.isTransfer) continue; // Already marked as transfer

                        // Check if amounts are opposite (one positive, one negative) and similar magnitude
                        const amountMatch = Math.abs(Math.abs(t1.amount) - Math.abs(t2.amount)) <= AMOUNT_TOLERANCE;
                        const oppositeSign = (t1.amount > 0) !== (t2.amount > 0);

                        if (!amountMatch || !oppositeSign) continue;

                        // Check date proximity
                        const date1 = new Date(t1.date);
                        const date2 = new Date(t2.date);
                        const daysDiff = Math.abs((date1 - date2) / (1000 * 60 * 60 * 24));

                        if (daysDiff > DAYS_TOLERANCE) continue;

                        // Check if descriptions suggest a transfer
                        const desc1 = t1.description.toLowerCase();
                        const desc2 = t2.description.toLowerCase();

                        // Common transfer keywords
                        const transferKeywords = [
                            'transfer', 'payment', 'autopay', 'online payment',
                            'debit card purchase', 'credit card payment', 'electronic payment',
                            'ach', 'zelle', 'venmo', 'paypal', 'check'
                        ];

                        const hasTransferKeyword = transferKeywords.some(kw =>
                            desc1.includes(kw) || desc2.includes(kw)
                        );

                        // If all conditions match, or if transfer keywords are present, mark both as transfers
                        if (amountMatch && oppositeSign && daysDiff <= DAYS_TOLERANCE) {
                            // Higher confidence match - mark as transfers
                            if (hasTransferKeyword || daysDiff <= 2) {
                                t1.isTransfer = true;
                                t2.isTransfer = true;
                                t1.transferMatch = t2.id;
                                t2.transferMatch = t1.id;
                                break; // Move to next transaction
                            }
                        }
                    }
                }

                // Log deduplication results
                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                if (transferCount > 0) {
                    console.log(`Detected and marked ${transferCount} inter-account transfer transactions`);
                }
            }

            updateDisplay() {
                this.updateStats();
                this.updateSummaryCards();
                this.updateComparisonChart();
                this.updateBulkCategorization();
                this.renderTransactions();
            }

            updateBulkCategorization() {
                const uncategorized = this.transactions.filter(t => t.category === 'uncategorized' && !t.isTransfer);
                const section = document.getElementById('bulkCategorizeSection');
                const container = document.getElementById('bulkGroups');

                if (uncategorized.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';

                // Group by similar description (first 20 chars, normalized)
                const groups = {};
                uncategorized.forEach(t => {
                    const key = t.description
                        .replace(/[0-9#*]+/g, '')
                        .replace(/\s+/g, ' ')
                        .trim()
                        .substring(0, 25)
                        .toLowerCase();

                    if (!groups[key]) {
                        groups[key] = {
                            name: t.description.substring(0, 30),
                            transactions: []
                        };
                    }
                    groups[key].transactions.push(t);
                });

                // Sort by count (most frequent first) and take top 20
                const sortedGroups = Object.values(groups)
                    .sort((a, b) => b.transactions.length - a.transactions.length)
                    .slice(0, 20);

                container.innerHTML = '';

                sortedGroups.forEach((group, idx) => {
                    const total = group.transactions.reduce((sum, t) => sum + Math.abs(t.amount), 0);
                    const groupEl = document.createElement('div');
                    groupEl.className = 'bulk-group';
                    groupEl.innerHTML = `
                        <div class="bulk-group-header" onclick="analyzer.toggleBulkGroup(${idx})">
                            <div class="bulk-group-info">
                                <span class="bulk-group-name">${this.escapeHtml(group.name)}${group.name.length >= 30 ? '...' : ''}</span>
                                <span class="bulk-group-count">${group.transactions.length} transactions • ${this.formatCurrency(total)} total</span>
                            </div>
                            <div class="bulk-group-actions">
                                <button class="bulk-btn fixed-costs" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'fixed-costs')">Fixed</button>
                                <button class="bulk-btn guilt-free" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'guilt-free')">Guilt-Free</button>
                                <button class="bulk-btn long-term" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'long-term')">Long-Term</button>
                                <button class="bulk-btn short-term" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'short-term')">Short-Term</button>
                                <button class="bulk-btn income" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'income')">Income</button>
                            </div>
                        </div>
                        <div class="bulk-group-details">
                            ${group.transactions.slice(0, 10).map(t => `
                                <div class="bulk-transaction">
                                    <span>${new Date(t.date).toLocaleDateString()} - ${this.escapeHtml(t.description.substring(0, 40))}</span>
                                    <span style="color: ${t.amount < 0 ? '#ef4444' : '#10b981'}">${this.formatCurrency(Math.abs(t.amount))}</span>
                                </div>
                            `).join('')}
                            ${group.transactions.length > 10 ? `<div style="color: #666; font-size: 0.85em; padding-top: 8px;">...and ${group.transactions.length - 10} more</div>` : ''}
                        </div>
                    `;
                    groupEl.dataset.groupIndex = idx;
                    container.appendChild(groupEl);
                });

                // Store groups for later reference
                this.bulkGroups = sortedGroups;
            }

            toggleBulkGroup(idx) {
                const groups = document.querySelectorAll('.bulk-group');
                groups.forEach((g, i) => {
                    if (i === idx) {
                        g.classList.toggle('expanded');
                    }
                });
            }

            bulkCategorize(groupIdx, category) {
                if (!this.bulkGroups || !this.bulkGroups[groupIdx]) return;

                const group = this.bulkGroups[groupIdx];
                group.transactions.forEach(t => {
                    const transaction = this.transactions.find(tr => tr.id === t.id);
                    if (transaction) {
                        transaction.category = category;
                        this.saveRule(transaction.description, category);
                    }
                });

                this.updateDisplay();
            }

            updateStats() {
                const dates = this.transactions.map(t => new Date(t.date)).filter(d => !isNaN(d));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));

                document.getElementById('dateRange').textContent =
                    `Showing transactions from ${minDate.toLocaleDateString()} to ${maxDate.toLocaleDateString()}`;

                // Exclude inter-account transfers from income/spending calculations
                const nonTransferTransactions = this.transactions.filter(t => !t.isTransfer);

                const totalIncome = nonTransferTransactions
                    .filter(t => t.amount > 0)
                    .reduce((sum, t) => sum + t.amount, 0);

                const totalSpending = nonTransferTransactions
                    .filter(t => t.amount < 0)
                    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

                const net = totalIncome - totalSpending;

                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                const displayCount = nonTransferTransactions.length;

                document.getElementById('totalTransactions').textContent =
                    transferCount > 0 ? `${displayCount} (${transferCount} transfers excluded)` : displayCount;
                document.getElementById('totalIncome').textContent = this.formatCurrency(totalIncome);
                document.getElementById('totalSpending').textContent = this.formatCurrency(totalSpending);

                const netElement = document.getElementById('netAmount');
                netElement.textContent = this.formatCurrency(net);
                netElement.classList.remove('income', 'expense');
                netElement.classList.add(net >= 0 ? 'income' : 'expense');
            }

            updateSummaryCards() {
                const categories = this.calculateCategoryTotals();
                const totalSpending = Object.entries(categories)
                    .filter(([cat]) => cat !== 'income')
                    .reduce((sum, [, data]) => sum + data.total, 0);

                // Calculate months in data
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const cardsContainer = document.getElementById('summaryCards');
                cardsContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free Spending', targetKey: 'guiltFree' },
                    { key: 'uncategorized', name: 'Uncategorized', targetKey: null }
                ];

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0, count: 0 };
                    const monthlyAvg = data.total / months;
                    const percentage = totalSpending > 0 ? (data.total / totalSpending * 100) : 0;

                    let targetPct = cat.targetKey ? this.targets[cat.targetKey] : 0;
                    let targetAmount = this.targets.income * (targetPct / 100);
                    let diff = monthlyAvg - targetAmount;
                    let diffClass = 'neutral';
                    let diffText = '-';

                    if (cat.targetKey) {
                        if (cat.key === 'short-term' || cat.key === 'long-term') {
                            // For savings, under target is bad
                            diffClass = diff >= 0 ? 'under' : 'over';
                            diffText = diff >= 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        } else {
                            // For spending, over target is bad
                            diffClass = diff <= 0 ? 'under' : 'over';
                            diffText = diff > 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        }
                    }

                    const card = document.createElement('div');
                    card.className = `summary-card ${cat.key}`;
                    card.innerHTML = `
                        <div class="card-header">
                            <span class="card-title">${cat.name}</span>
                            <span class="card-percentage">${percentage.toFixed(1)}%</span>
                        </div>
                        <div class="card-amount">${this.formatCurrency(monthlyAvg)}/mo</div>
                        ${cat.targetKey ? `
                            <div class="card-comparison">
                                <span class="comparison-target">Target: ${this.formatCurrency(targetAmount)}/mo</span>
                                <span class="comparison-diff ${diffClass}">${diffText}</span>
                            </div>
                        ` : `
                            <div class="card-comparison">
                                <span class="comparison-target">${data.count} transactions</span>
                            </div>
                        `}
                    `;
                    cardsContainer.appendChild(card);
                });
            }

            updateComparisonChart() {
                const categories = this.calculateCategoryTotals();

                // Calculate months
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const monthlyIncome = this.targets.income;
                const maxValue = monthlyIncome;

                const chartContainer = document.getElementById('comparisonChart');
                chartContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free', targetKey: 'guiltFree' }
                ];

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0 };
                    const monthlyActual = data.total / months;
                    const targetPct = this.targets[cat.targetKey];
                    const targetAmount = monthlyIncome * (targetPct / 100);

                    const targetWidth = Math.min(100, (targetAmount / maxValue) * 100);
                    const actualWidth = Math.min(100, (monthlyActual / maxValue) * 100);

                    const row = document.createElement('div');
                    row.className = 'comparison-row';
                    row.innerHTML = `
                        <div class="comparison-label">${cat.name}</div>
                        <div class="comparison-bar-container">
                            <div class="comparison-bar target" style="width: ${targetWidth}%"></div>
                            <div class="comparison-bar actual ${cat.key}" style="width: ${actualWidth}%"></div>
                        </div>
                        <div class="comparison-value">
                            <div style="font-size: 0.8em; color: #999;">Target: ${targetPct}%</div>
                            <div>Actual: ${(monthlyActual / monthlyIncome * 100).toFixed(1)}%</div>
                        </div>
                    `;
                    chartContainer.appendChild(row);
                });

                // Add legend
                const legend = document.createElement('div');
                legend.style.cssText = 'display: flex; gap: 20px; justify-content: center; margin-top: 20px; font-size: 0.9em;';
                legend.innerHTML = `
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #e0e0e0; border-radius: 2px; margin-right: 5px;"></span> Target</div>
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #667eea; border-radius: 2px; margin-right: 5px;"></span> Actual</div>
                `;
                chartContainer.appendChild(legend);
            }

            calculateCategoryTotals() {
                const totals = {};

                // Exclude inter-account transfers from category totals
                this.transactions
                    .filter(t => !t.isTransfer)
                    .forEach(t => {
                        const cat = t.category || 'uncategorized';
                        if (!totals[cat]) {
                            totals[cat] = { total: 0, count: 0 };
                        }
                        totals[cat].total += Math.abs(t.amount);
                        totals[cat].count++;
                    });

                return totals;
            }

            renderTransactions() {
                const categoryFilter = document.getElementById('categoryFilter').value;
                const sortOrder = document.getElementById('sortOrder').value;

                let filtered = [...this.transactions];

                // Apply category filter
                if (categoryFilter === 'transfers') {
                    filtered = filtered.filter(t => t.isTransfer);
                } else if (categoryFilter !== 'all') {
                    filtered = filtered.filter(t => t.category === categoryFilter && !t.isTransfer);
                } else {
                    // For 'all', exclude transfers by default unless specifically viewing them
                    filtered = filtered.filter(t => !t.isTransfer);
                }

                // Apply sort
                switch (sortOrder) {
                    case 'date-desc':
                        filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
                        break;
                    case 'date-asc':
                        filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
                        break;
                    case 'amount-desc':
                        filtered.sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));
                        break;
                    case 'amount-asc':
                        filtered.sort((a, b) => Math.abs(a.amount) - Math.abs(b.amount));
                        break;
                }

                // Render desktop table
                const tbody = document.getElementById('transactionsBody');
                tbody.innerHTML = '';

                // Render mobile cards
                const cardsContainer = document.getElementById('transactionCards');
                cardsContainer.innerHTML = '';

                filtered.forEach(t => {
                    const isExpense = t.amount < 0;
                    const transferBadge = t.isTransfer ? '<span style="background: #6b7280; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; margin-left: 8px;">TRANSFER</span>' : '';
                    const categoryOptions = `
                        <option value="fixed-costs" ${t.category === 'fixed-costs' ? 'selected' : ''}>Fixed Costs</option>
                        <option value="short-term" ${t.category === 'short-term' ? 'selected' : ''}>Short-Term Savings</option>
                        <option value="long-term" ${t.category === 'long-term' ? 'selected' : ''}>Long-Term Savings</option>
                        <option value="guilt-free" ${t.category === 'guilt-free' ? 'selected' : ''}>Guilt-Free</option>
                        <option value="income" ${t.category === 'income' ? 'selected' : ''}>Income</option>
                        <option value="uncategorized" ${t.category === 'uncategorized' ? 'selected' : ''}>Uncategorized</option>
                    `;

                    // Desktop table row
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${new Date(t.date).toLocaleDateString()}</td>
                        <td>${this.escapeHtml(t.description)}${transferBadge}</td>
                        <td class="amount-cell ${isExpense ? 'expense' : 'income'}">
                            ${isExpense ? '-' : '+'}${this.formatCurrency(Math.abs(t.amount))}
                        </td>
                        <td>
                            ${t.isTransfer ? '<span style="color: #6b7280; font-style: italic;">Inter-account transfer</span>' : `
                            <select class="category-select" data-id="${t.id}" onchange="analyzer.updateCategory(this)">
                                ${categoryOptions}
                            </select>
                            `}
                        </td>
                    `;
                    tbody.appendChild(row);

                    // Mobile card
                    const card = document.createElement('div');
                    card.className = 'transaction-card';
                    card.innerHTML = `
                        <div class="transaction-card-header">
                            <span class="transaction-card-desc">${this.escapeHtml(t.description)}${transferBadge}</span>
                            <span class="transaction-card-amount ${isExpense ? 'expense' : 'income'}">
                                ${isExpense ? '-' : '+'}${this.formatCurrency(Math.abs(t.amount))}
                            </span>
                        </div>
                        <div class="transaction-card-footer">
                            <span class="transaction-card-date">${new Date(t.date).toLocaleDateString()}</span>
                            <div class="transaction-card-category">
                                ${t.isTransfer ? '<span style="color: #6b7280; font-style: italic;">Inter-account transfer</span>' : `
                                <select data-id="${t.id}" onchange="analyzer.updateCategory(this)">
                                    ${categoryOptions}
                                </select>
                                `}
                            </div>
                        </div>
                    `;
                    cardsContainer.appendChild(card);
                });
            }

            updateCategory(select) {
                const id = select.dataset.id;
                const newCategory = select.value;

                const transaction = this.transactions.find(t => t.id === id);
                if (transaction) {
                    transaction.category = newCategory;

                    // Save the rule for this merchant
                    this.saveRule(transaction.description, newCategory);

                    // Update display
                    this.updateStats();
                    this.updateSummaryCards();
                    this.updateComparisonChart();
                }
            }

            saveRule(description, category) {
                // Extract merchant name (first few words, cleaned up)
                const merchantPattern = description
                    .replace(/[0-9#*]+/g, '')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .split(' ')
                    .slice(0, 3)
                    .join(' ')
                    .toLowerCase();

                if (merchantPattern.length < 3) return;

                // Save to localStorage
                const rules = StorageUtils.get('transactionRules', {});
                rules[merchantPattern] = category;
                StorageUtils.set('transactionRules', rules);
            }

            loadSavedRules() {
                const rules = StorageUtils.get('transactionRules', {});

                // Add saved rules to category patterns
                for (const [pattern, category] of Object.entries(rules)) {
                    if (this.categoryPatterns[category]) {
                        const regex = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                        this.categoryPatterns[category].unshift(regex);
                    }
                }
            }

            saveRules() {
                const rules = StorageUtils.get('transactionRules', {});
                DOMUtils.downloadFile(JSON.stringify(rules, null, 2), 'transaction-rules.json', 'application/json');
            }

            exportSummary() {
                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                let summary = `Transaction Analysis Summary\n`;
                summary += `============================\n\n`;
                summary += `Date Range: ${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}\n`;
                summary += `Total Transactions: ${this.transactions.length}\n\n`;

                summary += `Monthly Spending by Category:\n`;
                summary += `-----------------------------\n`;

                const categoryNames = {
                    'fixed-costs': 'Fixed Costs',
                    'short-term': 'Short-Term Savings',
                    'long-term': 'Long-Term Savings',
                    'guilt-free': 'Guilt-Free Spending',
                    'income': 'Income',
                    'uncategorized': 'Uncategorized'
                };

                for (const [key, name] of Object.entries(categoryNames)) {
                    const data = categories[key] || { total: 0, count: 0 };
                    const monthly = data.total / months;
                    summary += `${name}: ${this.formatCurrency(monthly)}/month (${data.count} transactions)\n`;
                }

                DOMUtils.downloadFile(summary, 'spending-summary.txt');
            }

            formatCurrency(value) {
                return FinanceUtils.formatCurrency(value);
            }

            parseCurrencyValue(value) {
                // Remove all non-numeric characters except decimal point
                const cleaned = String(value).replace(/[^0-9.]/g, '');
                return parseFloat(cleaned) || 0;
            }

            formatCurrencyInput(value) {
                // Format as currency with commas and 2 decimal places
                return '$' + value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            }

            escapeHtml(text) {
                return DOMUtils.escapeHtml(text);
            }

            // AI Categorization Methods
            toggleApiKeyVisibility() {
                const input = document.getElementById('apiKey');
                const btn = event.target;
                if (input.type === 'password') {
                    input.type = 'text';
                    btn.textContent = 'Hide';
                } else {
                    input.type = 'password';
                    btn.textContent = 'Show';
                }
            }

            getCategorizationPrompt(transactionList) {
                return `You are a financial transaction categorizer. Categorize each transaction into exactly one of these categories:

- fixed-costs: Essential expenses (rent, mortgage, utilities, insurance, groceries, gas, pharmacy, childcare, minimum debt payments)
- short-term: Transfers to savings accounts, emergency fund deposits
- long-term: Retirement contributions (401k, IRA), investment transfers, brokerage deposits
- guilt-free: Discretionary spending (restaurants, entertainment, shopping, subscriptions, travel, hobbies)
- income: Salary, refunds, reimbursements, interest earned

Here are the transactions to categorize (negative amounts are expenses, positive are income):

${JSON.stringify(transactionList, null, 2)}

Respond with ONLY a JSON array in this exact format, no other text:
[{"id": "transaction-id-here", "category": "category-name-here"}, ...]`;
            }

            async aiCategorize() {
                const apiKey = document.getElementById('apiKey').value.trim();
                const provider = document.getElementById('aiProvider').value;

                if (!apiKey) {
                    this.showAiStatus('Please enter your API key', 'error');
                    return;
                }

                const uncategorized = this.transactions.filter(t => t.category === 'uncategorized');
                if (uncategorized.length === 0) {
                    this.showAiStatus('No uncategorized transactions to process!', 'success');
                    return;
                }

                this.showAiStatus(`Processing ${uncategorized.length} transactions with ${provider}...`, 'processing');
                document.getElementById('aiCategorizeBtn').disabled = true;

                let successCount = 0;
                let errorCount = 0;
                let lastError = '';

                try {
                    // Process in larger batches for speed (modern models handle 40+ easily)
                    const batchSize = 40;
                    const failedTransactions = [];

                    for (let i = 0; i < uncategorized.length; i += batchSize) {
                        const batch = uncategorized.slice(i, i + batchSize);
                        const batchEnd = Math.min(i + batchSize, uncategorized.length);
                        this.showAiStatus(`Processing ${i + 1}-${batchEnd} of ${uncategorized.length}...`, 'processing');

                        try {
                            const categorizations = await this.callAI(provider, apiKey, batch);

                            // Apply categorizations
                            categorizations.forEach(result => {
                                const transaction = this.transactions.find(t => t.id === result.id);
                                if (transaction && result.category && this.isValidCategory(result.category)) {
                                    transaction.category = result.category;
                                    this.saveRule(transaction.description, result.category);
                                    successCount++;
                                }
                            });

                            this.updateDisplay();
                        } catch (batchError) {
                            lastError = batchError.message;
                            console.error(`Batch error:`, batchError);
                            failedTransactions.push(...batch);
                        }

                        // Brief delay between batches to avoid rate limits
                        if (i + batchSize < uncategorized.length) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }

                    // One retry pass for any failures (smaller batches)
                    if (failedTransactions.length > 0 && failedTransactions.length < uncategorized.length) {
                        this.showAiStatus(`Retrying ${failedTransactions.length} failed transactions...`, 'processing');
                        await new Promise(resolve => setTimeout(resolve, 1000));

                        try {
                            const categorizations = await this.callAI(provider, apiKey, failedTransactions);
                            categorizations.forEach(result => {
                                const transaction = this.transactions.find(t => t.id === result.id);
                                if (transaction && result.category && this.isValidCategory(result.category)) {
                                    transaction.category = result.category;
                                    this.saveRule(transaction.description, result.category);
                                    successCount++;
                                }
                            });
                            this.updateDisplay();
                        } catch (retryError) {
                            errorCount = failedTransactions.length;
                            lastError = retryError.message;
                        }
                    } else if (failedTransactions.length === uncategorized.length) {
                        errorCount = failedTransactions.length;
                    }

                    if (successCount > 0) {
                        const remaining = this.transactions.filter(t => t.category === 'uncategorized').length;
                        if (remaining > 0) {
                            this.showAiStatus(`Categorized ${successCount}. ${remaining} still uncategorized - click again to retry. Last error: ${lastError}`, 'success');
                        } else {
                            this.showAiStatus(`Successfully categorized all ${successCount} transactions!`, 'success');
                        }
                    } else {
                        this.showAiStatus(`Failed: ${lastError}`, 'error');
                    }
                } catch (error) {
                    console.error('AI categorization error:', error);
                    if (successCount > 0) {
                        this.showAiStatus(`Partially completed: ${successCount} categorized. Error: ${error.message}`, 'error');
                    } else {
                        this.showAiStatus(`Error: ${error.message}`, 'error');
                    }
                } finally {
                    document.getElementById('aiCategorizeBtn').disabled = false;
                }
            }

            isValidCategory(category) {
                const validCategories = ['fixed-costs', 'short-term', 'long-term', 'guilt-free', 'income'];
                return validCategories.includes(category);
            }

            async callAI(provider, apiKey, transactions) {
                const transactionList = transactions.map(t => ({
                    id: t.id,
                    description: t.description,
                    amount: t.amount
                }));

                const prompt = this.getCategorizationPrompt(transactionList);

                switch (provider) {
                    case 'openai':
                        return await this.callOpenAI(apiKey, prompt);
                    case 'gemini':
                        return await this.callGemini(apiKey, prompt);
                    case 'anthropic':
                        return await this.callAnthropic(apiKey, prompt);
                    default:
                        throw new Error('Unknown AI provider');
                }
            }

            async callOpenAI(apiKey, prompt) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [{ role: 'user', content: prompt }],
                            max_tokens: 4096,
                            temperature: 0
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.choices[0].message.content;
                    return this.parseAIResponse(content);
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        throw new Error('OpenAI blocked by browser (CORS). Try Google Gemini instead.');
                    }
                    throw error;
                }
            }

            async callGemini(apiKey, prompt) {
                // Try models from newest to oldest - cache working model for speed
                const models = [
                    'gemini-2.5-flash',      // Stable 2.5 (fast)
                    'gemini-2.5-pro',        // Stable 2.5 (powerful)
                    'gemini-2.0-flash',      // Fallback
                    'gemini-1.5-flash',      // Legacy fallback
                ];

                // Use cached model if we found one that works
                const cachedModel = this.workingGeminiModel;
                const modelsToTry = cachedModel ? [cachedModel, ...models.filter(m => m !== cachedModel)] : models;

                let lastError = null;

                for (const model of modelsToTry) {
                    try {
                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0,
                                    maxOutputTokens: 8192
                                }
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            const errorMsg = errorData.error?.message || `Gemini API error: ${response.status}`;

                            // If model not found, try next model
                            if (errorMsg.includes('not found') || errorMsg.includes('not supported')) {
                                console.log(`Model ${model} not available, trying next...`);
                                lastError = new Error(errorMsg);
                                continue;
                            }

                            if (response.status === 400 && errorMsg.includes('API key')) {
                                throw new Error('Invalid Gemini API key. Get one at aistudio.google.com/apikey');
                            }
                            throw new Error(errorMsg);
                        }

                        const data = await response.json();
                        if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]?.text) {
                            console.log(`Model ${model} returned unexpected format, trying next...`);
                            lastError = new Error('Unexpected response format from Gemini');
                            continue;
                        }

                        // Cache the working model for future calls
                        this.workingGeminiModel = model;
                        console.log(`Successfully used Gemini model: ${model}`);
                        const content = data.candidates[0].content.parts[0].text;
                        return this.parseAIResponse(content);
                    } catch (error) {
                        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                            throw new Error('Network error connecting to Gemini. Check your internet connection.');
                        }
                        // If it's an API key error, don't try other models
                        if (error.message.includes('API key')) {
                            throw error;
                        }
                        lastError = error;
                        console.log(`Model ${model} failed: ${error.message}`);
                    }
                }

                // All models failed
                throw lastError || new Error('All Gemini models failed. Try a different provider.');
            }

            async callAnthropic(apiKey, prompt) {
                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-haiku-20240307',
                            max_tokens: 4096,
                            messages: [{ role: 'user', content: prompt }]
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `Anthropic API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.content[0].text;
                    return this.parseAIResponse(content);
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        throw new Error('Anthropic blocked by browser (CORS). Try Google Gemini instead.');
                    }
                    throw error;
                }
            }

            parseAIResponse(content) {
                try {
                    // Extract JSON from response (in case there's extra text)
                    const jsonMatch = content.match(/\[[\s\S]*?\]/);
                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[0]);
                    }
                    throw new Error('No valid JSON array found in response');
                } catch (parseError) {
                    console.error('Failed to parse AI response:', content);
                    throw new Error('Failed to parse AI response');
                }
            }

            showAiStatus(message, type) {
                const status = document.getElementById('aiStatus');
                status.textContent = message;
                status.className = `ai-status show ${type}`;
            }
        }

        // Initialize
        let analyzer;
        DOMUtils.ready(() => {
            analyzer = new TransactionAnalyzer();

            // Load data from Budget Planner if available
            const budgetData = StorageUtils.get('budgetPlannerData');
            if (budgetData) {
                // Update income field
                const incomeInput = document.getElementById('monthlyIncome');
                if (budgetData.monthlyIncome) {
                    incomeInput.value = analyzer.formatCurrencyInput(budgetData.monthlyIncome);
                    analyzer.targets.income = budgetData.monthlyIncome;
                }
                // Update allocation percentages
                if (budgetData.fixedCosts !== undefined) {
                    document.getElementById('targetFixed').value = budgetData.fixedCosts;
                    analyzer.targets.fixedCosts = budgetData.fixedCosts;
                }
                if (budgetData.shortTerm !== undefined) {
                    document.getElementById('targetShortTerm').value = budgetData.shortTerm;
                    analyzer.targets.shortTerm = budgetData.shortTerm;
                }
                if (budgetData.longTerm !== undefined) {
                    document.getElementById('targetLongTerm').value = budgetData.longTerm;
                    analyzer.targets.longTerm = budgetData.longTerm;
                }
                if (budgetData.guiltFree !== undefined) {
                    document.getElementById('targetGuiltFree').value = budgetData.guiltFree;
                    analyzer.targets.guiltFree = budgetData.guiltFree;
                }
            }

            const apiKeyInput = document.getElementById('apiKey');
            const providerSelect = document.getElementById('aiProvider');
            const aiCategorizeBtn = document.getElementById('aiCategorizeBtn');

            // Enable AI button when API key is entered
            apiKeyInput.addEventListener('input', (e) => {
                aiCategorizeBtn.disabled = !e.target.value.trim();
            });

            // Load saved provider and API key from localStorage
            const savedProvider = StorageUtils.get('aiProvider', 'gemini');
            providerSelect.value = savedProvider;

            const savedKey = StorageUtils.get(`apiKey_${savedProvider}`);
            if (savedKey) {
                apiKeyInput.value = savedKey;
                aiCategorizeBtn.disabled = false;
            }

            // Update placeholder and load key when provider changes
            providerSelect.addEventListener('change', (e) => {
                const provider = e.target.value;
                StorageUtils.set('aiProvider', provider);

                // Update placeholder
                const placeholders = {
                    'openai': 'sk-...',
                    'gemini': 'AIza...',
                    'anthropic': 'sk-ant-api...'
                };
                apiKeyInput.placeholder = placeholders[provider] || 'Enter API key...';

                // Load saved key for this provider
                const savedProviderKey = StorageUtils.get(`apiKey_${provider}`);
                apiKeyInput.value = savedProviderKey || '';
                aiCategorizeBtn.disabled = !savedProviderKey;
            });

            // Trigger initial placeholder update
            providerSelect.dispatchEvent(new Event('change'));

            // Save API key when changed (per provider)
            apiKeyInput.addEventListener('change', (e) => {
                if (e.target.value.trim()) {
                    const provider = providerSelect.value;
                    StorageUtils.set(`apiKey_${provider}`, e.target.value.trim());
                }
            });

            // Load saved transactions if available
            const savedTransactions = StorageUtils.get('transactionData', []);
            if (savedTransactions.length > 0) {
                analyzer.transactions = savedTransactions;
                analyzer.analyze();
            }

            // Initialize session toolbar
            SessionManager.initToolbar(
                // Get current page data for export
                () => {
                    // Save current transactions to localStorage
                    if (analyzer.transactions.length > 0) {
                        StorageUtils.set('transactionData', analyzer.transactions);
                    }

                    return {
                        transactions: analyzer.transactions,
                        bankFormat: analyzer.selectedFormat,
                        targets: analyzer.targets
                    };
                },
                // Handle import
                (result) => {
                    // Check if we have transaction data in the imported session
                    const session = StorageUtils.get('transactionData', []);
                    if (session.length > 0) {
                        analyzer.transactions = session;
                        analyzer.analyze();
                        SessionManager.showToast('Transactions restored!', 'success');
                    } else {
                        window.location.reload();
                    }
                }
            );
        });
    </script>
</body>
</html>
