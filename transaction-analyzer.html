<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Transaction Analyzer - See Your Spending Reality</title>
    <script src="shared.js?v=20251229"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f5f7fa;
            border-radius: 8px;
        }

        .section h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        .section h3 {
            margin-bottom: 10px;
            color: #555;
            font-size: 1.1em;
        }

        /* Upload Section */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .upload-area:hover {
            background: #f0f4ff;
            border-color: #5568d3;
        }

        .upload-area.dragover {
            background: #e8edff;
            border-color: #4455c7;
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 5px;
        }

        .upload-hint {
            font-size: 0.9em;
            color: #999;
        }

        /* Bank Format Selection */
        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .format-option {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s;
        }

        .format-option:hover {
            border-color: #667eea;
        }

        .format-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Targets Section */
        .targets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .target-input {
            display: flex;
            flex-direction: column;
        }

        .target-input label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .target-input input {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
        }

        .target-input input:focus {
            outline: none;
            border-color: #667eea;
        }

        .target-input select {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .target-input select:focus {
            outline: none;
            border-color: #667eea;
        }

        .target-input select:hover {
            border-color: #bbb;
        }

        /* Results Section */
        .results-hidden {
            display: none;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid;
        }

        .summary-card.fixed-costs { border-left-color: #ef4444; }
        .summary-card.short-term { border-left-color: #f59e0b; }
        .summary-card.long-term { border-left-color: #10b981; }
        .summary-card.guilt-free { border-left-color: #8b5cf6; }
        .summary-card.uncategorized { border-left-color: #6b7280; }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .card-percentage {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .card-amount {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .card-comparison {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .comparison-target {
            color: #666;
        }

        .comparison-diff {
            font-weight: 600;
        }

        .comparison-diff.over { color: #ef4444; }
        .comparison-diff.under { color: #10b981; }
        .comparison-diff.neutral { color: #6b7280; }

        /* Progress Bar */
        .progress-container {
            margin-top: 10px;
        }

        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .progress-target {
            position: absolute;
            top: -4px;
            width: 2px;
            height: 16px;
            background: #333;
        }

        /* Transactions Table */
        .transactions-container {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .transactions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
        }

        .transactions-table {
            width: 100%;
            border-collapse: collapse;
        }

        .transactions-table th,
        .transactions-table td {
            padding: 12px 20px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transactions-table tr:hover {
            background: #f9fafb;
        }

        .amount-cell {
            font-weight: 600;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .amount-cell.expense { color: #ef4444; }
        .amount-cell.income { color: #10b981; }

        .category-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .category-badge.fixed-costs { background: #fee2e2; color: #dc2626; }
        .category-badge.short-term { background: #fef3c7; color: #d97706; }
        .category-badge.long-term { background: #d1fae5; color: #059669; }
        .category-badge.guilt-free { background: #ede9fe; color: #7c3aed; }
        .category-badge.uncategorized { background: #f3f4f6; color: #6b7280; }
        .category-badge.income { background: #dbeafe; color: #2563eb; }

        .category-select {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* Comparison Chart */
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .chart-title {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 20px;
            text-align: center;
        }

        .comparison-bars {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .comparison-row {
            display: grid;
            grid-template-columns: 150px 1fr 80px;
            gap: 15px;
            align-items: center;
        }

        .comparison-label {
            font-weight: 500;
            text-align: right;
        }

        .comparison-bar-container {
            position: relative;
            height: 30px;
        }

        .comparison-bar {
            position: absolute;
            height: 12px;
            border-radius: 6px;
            transition: width 0.5s;
        }

        .comparison-bar.target {
            top: 0;
            background: #e0e0e0;
        }

        .comparison-bar.actual {
            top: 16px;
        }

        .comparison-bar.actual.fixed-costs { background: #ef4444; }
        .comparison-bar.actual.short-term { background: #f59e0b; }
        .comparison-bar.actual.long-term { background: #10b981; }
        .comparison-bar.actual.guilt-free { background: #8b5cf6; }

        .comparison-value {
            font-weight: 600;
            font-size: 0.9em;
        }

        /* Income Comparison Header */
        .income-comparison-header {
            margin-bottom: 24px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .income-comparison {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            font-size: 0.95em;
        }

        .income-label {
            color: #64748b;
        }

        .income-value {
            font-weight: 600;
            color: #1e293b;
        }

        .income-separator {
            color: #cbd5e1;
            margin: 0 4px;
        }

        .income-diff {
            font-weight: 600;
            font-size: 0.9em;
            padding: 2px 8px;
            border-radius: 4px;
        }

        .income-diff.positive {
            color: #059669;
            background: #d1fae5;
        }

        .income-diff.negative {
            color: #dc2626;
            background: #fee2e2;
        }

        .income-note {
            text-align: center;
            font-size: 0.85em;
            color: #64748b;
            margin-top: 8px;
        }

        /* Savings Rate */
        .savings-rate-row {
            margin-top: 24px;
            padding: 16px;
            background: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 100%);
            border-radius: 8px;
            border: 1px solid #bbf7d0;
        }

        .savings-rate {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            font-size: 1.1em;
        }

        .savings-label {
            color: #166534;
            font-weight: 500;
        }

        .savings-value {
            font-weight: 700;
            font-size: 1.2em;
        }

        .savings-value.positive {
            color: #059669;
        }

        .savings-value.negative {
            color: #dc2626;
        }

        .savings-target {
            color: #64748b;
            font-size: 0.9em;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 32px;
            flex-wrap: wrap;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 28px;
            border-radius: 8px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            text-decoration: none;
            min-width: 160px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            background: #5568d3;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: white;
            color: #475569;
            border: 1px solid #e2e8f0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .btn-secondary:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
            color: #334155;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        /* Footer */
        footer {
            background: #f5f5f5;
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .workflow-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 20px 0;
            margin-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .workflow-nav a {
            text-decoration: none;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .workflow-nav .nav-arrow {
            background: #667eea;
            color: white;
        }

        .workflow-nav .nav-arrow:hover {
            background: #5568d3;
            text-decoration: none;
        }

        .workflow-nav .home-link {
            color: #667eea;
            font-size: 0.95em;
        }

        .workflow-nav .home-link:hover {
            background: #f0f4ff;
            text-decoration: none;
        }

        .version-text {
            margin-top: 16px;
            font-size: 0.75em;
            color: #9ca3af;
        }

        /* Navigation Tabs */
        .nav-tabs {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            background: transparent;
            gap: 8px;
            padding: 0 20px;
        }

        .nav-tab {
            flex: 1;
            padding: 14px 16px;
            text-align: center;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
            font-size: 0.95em;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            background: transparent;
        }

        .nav-tab:hover {
            color: rgba(255, 255, 255, 0.95);
        }

        .nav-tab.active {
            color: white;
            border-bottom-color: white;
            font-weight: 600;
        }

        /* Accessibility: Skip link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #667eea;
            color: white;
            padding: 8px 16px;
            z-index: 100;
            text-decoration: none;
            font-weight: 600;
            border-radius: 0 0 4px 0;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Info Box */
        .info-box {
            background: #dbeafe;
            border: 1px solid #93c5fd;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #1e40af;
            font-size: 0.95em;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        /* API Key Section */
        .api-key-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .api-key-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            font-family: monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .ai-status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            display: none;
        }

        .ai-status.show {
            display: block;
        }

        .ai-status.processing {
            background: #dbeafe;
            color: #1e40af;
        }

        .ai-status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .ai-status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .provider-select {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            min-width: 180px;
        }

        .provider-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .api-help {
            margin-top: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .api-help a {
            color: #667eea;
            text-decoration: none;
        }

        .api-help a:hover {
            text-decoration: underline;
        }

        .cors-notice {
            background: #fef3c7;
            border: 1px solid #fcd34d;
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 15px;
            color: #92400e;
            font-size: 0.9em;
        }

        /* Upload Guidance */
        .upload-guidance {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .guidance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .guidance-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .guidance-item.essential {
            border-left: 3px solid #10b981;
        }

        .guidance-item.recommended {
            border-left: 3px solid #f59e0b;
        }

        .guidance-icon {
            font-size: 1.2em;
        }

        .guidance-item div {
            display: flex;
            flex-direction: column;
        }

        .guidance-item strong {
            font-size: 0.95em;
            color: #333;
        }

        .guidance-item span:not(.guidance-icon) {
            font-size: 0.85em;
            color: #666;
        }

        .guidance-tip {
            margin-top: 15px;
            font-size: 0.9em;
            color: #0369a1;
            font-style: italic;
        }

        /* Bulk Categorization */
        .bulk-group {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .bulk-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            cursor: pointer;
            background: #f9fafb;
            transition: background 0.2s;
            gap: 10px;
        }

        .bulk-group-header:hover {
            background: #f3f4f6;
        }

        .bulk-group-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            flex: 1;
        }

        .bulk-group-name {
            font-weight: 600;
            color: #333;
            word-break: break-word;
        }

        .bulk-group-count {
            font-size: 0.85em;
            color: #666;
        }

        .bulk-group-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .bulk-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.1s;
            font-weight: 500;
        }

        .bulk-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        .bulk-btn:active {
            transform: scale(0.98);
        }

        .bulk-btn.fixed-costs { background: #fee2e2; color: #dc2626; }
        .bulk-btn.short-term { background: #fef3c7; color: #d97706; }
        .bulk-btn.long-term { background: #d1fae5; color: #059669; }
        .bulk-btn.guilt-free { background: #ede9fe; color: #7c3aed; }
        .bulk-btn.income { background: #dbeafe; color: #2563eb; }

        .bulk-group-details {
            display: none;
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            background: white;
            max-height: 200px;
            overflow-y: auto;
        }

        .bulk-group.expanded .bulk-group-details {
            display: block;
        }

        .bulk-transaction {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
            font-size: 0.9em;
            gap: 10px;
        }

        .bulk-transaction:last-child {
            border-bottom: none;
        }

        .bulk-transaction span:first-child {
            flex: 1;
            min-width: 0;
            word-break: break-word;
        }

        /* Upload Success State */
        .upload-area.success {
            border-color: #10b981;
            background: #d1fae5;
        }

        .upload-success-info {
            margin-top: 15px;
            padding: 12px 15px;
            background: #d1fae5;
            border: 1px solid #6ee7b7;
            border-radius: 6px;
            color: #065f46;
            font-size: 0.95em;
        }

        .upload-success-info strong {
            display: block;
            margin-bottom: 5px;
        }

        /* Mobile Transaction Cards */
        .transaction-cards {
            display: none;
        }

        .transaction-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .transaction-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .transaction-card-desc {
            font-weight: 500;
            color: #333;
            word-break: break-word;
            flex: 1;
        }

        .transaction-card-amount {
            font-weight: 700;
            font-family: 'SF Mono', Monaco, monospace;
            white-space: nowrap;
        }

        .transaction-card-amount.expense { color: #ef4444; }
        .transaction-card-amount.income { color: #10b981; }

        .transaction-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .transaction-card-date {
            font-size: 0.85em;
            color: #666;
        }

        .transaction-card-category {
            flex: 1;
        }

        .transaction-card-category select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #f9fafb;
            font-size: 0.9em;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .nav-tabs {
                padding: 0 10px;
                gap: 4px;
            }

            .nav-tab {
                padding: 12px 8px;
                font-size: 0.85em;
            }

            header {
                padding: 20px;
            }

            header h1 {
                font-size: 1.5em;
            }

            header p {
                font-size: 0.95em;
            }

            .content {
                padding: 15px;
            }

            .section {
                padding: 15px;
                margin-bottom: 20px;
            }

            .comparison-row {
                grid-template-columns: 1fr;
                gap: 5px;
            }

            .comparison-label {
                text-align: left;
            }

            /* Hide table, show cards on mobile */
            .table-scroll {
                display: none;
            }

            .transaction-cards {
                display: block;
                max-height: 600px;
                overflow-y: auto;
            }

            .transactions-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .filter-controls {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .filter-select {
                flex: 1;
                min-width: 120px;
            }

            /* Bulk categorization mobile */
            .bulk-group-header {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .bulk-group-actions {
                justify-content: flex-start;
            }

            .bulk-btn {
                padding: 10px 14px;
                font-size: 0.9em;
            }

            /* Upload area mobile */
            .upload-area {
                padding: 30px 20px;
            }

            .upload-icon {
                font-size: 36px;
            }

            /* Targets grid mobile */
            .targets-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .target-input:first-child {
                grid-column: 1 / -1;
            }

            /* Format grid mobile */
            .format-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            /* Summary cards mobile */
            .summary-cards {
                grid-template-columns: 1fr;
            }

            /* Stats row mobile */
            .stats-row {
                grid-template-columns: repeat(2, 1fr);
            }

            /* API section mobile */
            .api-key-wrapper {
                flex-direction: column;
            }

            .provider-select,
            .api-key-input {
                width: 100%;
            }

            /* Action buttons mobile */
            .action-buttons {
                flex-direction: column;
                gap: 10px;
            }

            .action-buttons .btn {
                width: 100%;
                min-width: unset;
            }

            /* Income comparison mobile */
            .income-comparison {
                flex-direction: column;
                gap: 4px;
            }

            .income-separator {
                display: none;
            }

            .savings-rate {
                flex-wrap: wrap;
            }

            /* Guidance grid mobile */
            .guidance-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .targets-grid {
                grid-template-columns: 1fr;
            }

            .stats-row {
                grid-template-columns: 1fr;
            }

            .bulk-group-actions {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .bulk-btn {
                text-align: center;
            }
        }

        /* Scrollable table container */
        .table-scroll {
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }

        /* Date range display */
        .date-range {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }

        /* Stats row */
        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: #333;
        }

        .stat-value.expense { color: #ef4444; }
        .stat-value.income { color: #10b981; }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <nav class="nav-tabs" role="navigation" aria-label="Main navigation">
        <a href="income-allocation.html" class="nav-tab">Budget Planner</a>
        <a href="transaction-analyzer.html" class="nav-tab active" aria-current="page">Spending Tracker</a>
        <a href="retirement-simulator.html" class="nav-tab">Retirement Forecast</a>
    </nav>

    <div class="container" role="document">
        <header role="banner">
            <h1><a href="index.html" style="color: inherit; text-decoration: none;">Spending Tracker</a></h1>
            <p>Upload your bank transactions to see your actual spending vs. your goals</p>
        </header>

        <main id="main-content" class="content" role="main">
            <!-- Step 1: Set Targets -->
            <div class="section">
                <h2>Step 1: Set Your Target Allocations</h2>
                <p style="color: #666; margin-bottom: 15px;">Enter your monthly take-home pay and how you want to divide it. <a href="income-allocation.html" style="color: #667eea;">Need help deciding? Use the Budget Planner first.</a></p>

                <div class="targets-grid">
                    <div class="target-input">
                        <label for="monthlyIncome">Monthly Income</label>
                        <input type="text" id="monthlyIncome" value="$5,000.00" inputmode="decimal" autocomplete="transaction-amount">
                    </div>
                    <div class="target-input">
                        <label for="targetFixed">Bills & Essentials %</label>
                        <input type="number" id="targetFixed" value="50" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetShortTerm">Savings Goals %</label>
                        <input type="number" id="targetShortTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetLongTerm">Retirement %</label>
                        <input type="number" id="targetLongTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetGuiltFree">Fun Money %</label>
                        <input type="number" id="targetGuiltFree" value="10" min="0" max="100">
                    </div>
                </div>
            </div>

            <!-- Step 2: Upload -->
            <div class="section">
                <h2>Step 2: Upload Your Transactions</h2>

                <div class="upload-guidance">
                    <strong>For an accurate spending picture, upload transactions from:</strong>
                    <div class="guidance-grid">
                        <div class="guidance-item essential">
                            <span class="guidance-icon">&#9989;</span>
                            <div>
                                <strong>Primary Checking Account</strong>
                                <span>Where bills & transfers come from</span>
                            </div>
                        </div>
                        <div class="guidance-item essential">
                            <span class="guidance-icon">&#9989;</span>
                            <div>
                                <strong>Credit Cards</strong>
                                <span>Daily spending & subscriptions</span>
                            </div>
                        </div>
                        <div class="guidance-item recommended">
                            <span class="guidance-icon">&#128161;</span>
                            <div>
                                <strong>Savings Accounts</strong>
                                <span>To track savings transfers</span>
                            </div>
                        </div>
                        <div class="guidance-item recommended">
                            <span class="guidance-icon">&#128161;</span>
                            <div>
                                <strong>Investment Accounts</strong>
                                <span>401k/IRA contributions</span>
                            </div>
                        </div>
                    </div>
                    <p class="guidance-tip">Tip: Export 3-6 months of data for the most accurate monthly averages</p>

                    <div style="background: #fff4e6; border: 1px solid #ffb020; border-radius: 6px; padding: 15px; margin-top: 15px;">
                        <strong style="color: #b45309; display: block; margin-bottom: 8px;">&#128200; How to Export Multiple Statements:</strong>
                        <ul style="color: #92400e; font-size: 0.9em; margin: 0; padding-left: 20px; line-height: 1.6;">
                            <li><strong>Chase:</strong> Log in ‚Üí Activity ‚Üí Select account ‚Üí Download ‚Üí Choose date range ‚Üí CSV format</li>
                            <li><strong>Bank of America:</strong> Accounts ‚Üí Select account ‚Üí Export Transactions ‚Üí CSV</li>
                            <li><strong>Wells Fargo:</strong> Accounts ‚Üí Select account ‚Üí Download Transactions ‚Üí CSV</li>
                            <li><strong>Citi:</strong> Account Activity ‚Üí Download ‚Üí CSV</li>
                            <li><strong>American Express:</strong> Account ‚Üí Statements & Activity ‚Üí Download ‚Üí CSV</li>
                            <li><strong>Capital One:</strong> Transactions ‚Üí Download ‚Üí CSV</li>
                        </ul>
                        <p style="margin: 10px 0 5px 0; color: #b45309; font-size: 0.9em;"><strong>&#10004; Multiple File Upload:</strong> You can select and upload multiple CSV files at once (Ctrl/Cmd+Click to select multiple files)</p>
                        <p style="margin: 5px 0 0 0; color: #b45309; font-size: 0.85em; font-style: italic;">&#9888; Automatic Deduplication: Inter-account transfers (like credit card payments from checking) are automatically detected and excluded from income/spending totals to prevent double-counting.</p>
                    </div>
                </div>

                <div class="upload-area" id="uploadArea">
                    <input type="file" id="fileInput" accept=".csv" multiple>
                    <div class="upload-icon">&#128196;</div>
                    <div class="upload-text">Drop CSV files here or click to upload</div>
                    <div class="upload-hint">You can upload multiple files from different accounts</div>
                </div>
            </div>

            <!-- AI Categorization (Optional) -->
            <div class="section" id="aiSection">
                <h2>AI Categorization (Optional)</h2>
                <p style="color: #666; margin-bottom: 15px;">Use your own API key to auto-categorize transactions.</p>

                <details style="margin-bottom: 15px; font-size: 0.85em; color: #64748b;">
                    <summary style="cursor: pointer;">Data sent to AI provider</summary>
                    <p style="margin: 8px 0 0 0;">Date, description, and amount for each uncategorized transaction. Sent directly to the provider you select. API key stored in browser localStorage.</p>
                </details>

                <div class="api-key-wrapper">
                    <select id="aiProvider" class="provider-select">
                        <option value="gemini">Google Gemini</option>
                        <option value="openai">OpenAI (GPT-4o-mini)</option>
                        <option value="anthropic">Anthropic Claude</option>
                    </select>
                    <input type="password" id="apiKey" placeholder="Enter API key..." class="api-key-input">
                    <button class="btn btn-secondary" onclick="analyzer.toggleApiKeyVisibility()">Show</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" id="aiCategorizeBtn" onclick="analyzer.aiCategorize()" disabled>Categorize Remaining Transactions with AI</button>
                </div>
                <div id="aiStatus" class="ai-status"></div>
                <div class="api-help">
                    <strong>Get a free API key:</strong>
                    <a href="https://aistudio.google.com/apikey" target="_blank">Google Gemini (free tier)</a> |
                    <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI</a> |
                    <a href="https://console.anthropic.com/" target="_blank">Anthropic</a>
                </div>
            </div>

            <!-- Results Section (hidden until data uploaded) -->
            <div id="resultsSection" class="results-hidden">
                <!-- Date Range and Stats -->
                <div class="section">
                    <h2>Analysis Summary</h2>
                    <div class="date-range" id="dateRange"></div>
                    <div class="stats-row">
                        <div class="stat-box">
                            <div class="stat-label">Total Transactions</div>
                            <div class="stat-value" id="totalTransactions">0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Income</div>
                            <div class="stat-value income" id="totalIncome">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Outflow</div>
                            <div class="stat-value expense" id="totalSpending">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Net</div>
                            <div class="stat-value" id="netAmount">$0</div>
                        </div>
                    </div>
                </div>

                <!-- Comparison Chart -->
                <div class="section">
                    <h2>Goal vs Reality</h2>
                    <div class="chart-container">
                        <div class="chart-title">Target Allocation vs Actual Spending (Monthly Average)</div>
                        <div class="comparison-bars" id="comparisonChart"></div>
                    </div>
                </div>

                <!-- Category Cards -->
                <div class="summary-cards" id="summaryCards"></div>

                <!-- Excluded Transfers Section -->
                <div class="section" id="transfersSection" style="display: none;">
                    <button type="button" id="toggleTransfers" style="width: 100%; background: #f9fafb; border: 1px solid #e5e7eb; padding: 12px 20px; font-size: 1em; font-weight: 600; color: #6b7280; cursor: pointer; display: flex; align-items: center; justify-content: space-between; border-radius: 6px; transition: background 0.2s;">
                        <span><span style="margin-right: 8px;">&#8644;</span> Transfers Detected &amp; Excluded (<span id="transferCount">0</span>)</span>
                        <span class="arrow" style="transition: transform 0.3s;">&#9660;</span>
                    </button>
                    <div id="transfersPanel" style="display: none; margin-top: 10px;">
                        <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">These transactions were detected as inter-account transfers (matching amounts on same day) and excluded from income/spending totals to prevent double-counting.</p>
                        <div style="overflow-x: auto;">
                            <table class="transactions-table" style="font-size: 0.9em;">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Description</th>
                                        <th>Amount</th>
                                        <th>Matched With</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody id="transfersTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Bulk Categorization -->
                <div class="section" id="bulkCategorizeSection" style="display: none;">
                    <h2>Quick Categorize</h2>
                    <p style="color: #666; margin-bottom: 15px;">Group similar transactions and categorize them all at once. Click a group to expand and categorize.</p>
                    <div id="bulkGroups"></div>
                    <div id="zeroTotalGroups" style="margin-top: 20px;"></div>
                </div>

                <!-- Transactions Table -->
                <div class="section">
                    <h2>Transaction Details</h2>
                    <div class="transactions-container">
                        <div class="transactions-header">
                            <span class="transactions-title">All Transactions</span>
                            <div class="filter-controls">
                                <select class="filter-select" id="categoryFilter">
                                    <option value="all">All Categories</option>
                                    <option value="fixed-costs">Fixed Costs</option>
                                    <option value="short-term">Short-Term Savings</option>
                                    <option value="long-term">Long-Term Savings</option>
                                    <option value="guilt-free">Guilt-Free Spending</option>
                                    <option value="income">Income</option>
                                    <option value="uncategorized">Uncategorized</option>
                                    <option value="transfers">Transfers (Excluded)</option>
                                </select>
                                <select class="filter-select" id="sortOrder">
                                    <option value="date-desc">Date (Newest)</option>
                                    <option value="date-asc">Date (Oldest)</option>
                                    <option value="amount-desc">Amount (High to Low)</option>
                                    <option value="amount-asc">Amount (Low to High)</option>
                                </select>
                            </div>
                        </div>
                        <!-- Desktop Table View -->
                        <div class="table-scroll">
                            <table class="transactions-table">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Description</th>
                                        <th>Amount</th>
                                        <th>Category</th>
                                    </tr>
                                </thead>
                                <tbody id="transactionsBody"></tbody>
                            </table>
                        </div>
                        <!-- Mobile Card View -->
                        <div class="transaction-cards" id="transactionCards"></div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="action-buttons">
                    <button class="btn btn-secondary" onclick="analyzer.exportSummary()">Export Summary</button>
                    <button class="btn btn-primary" onclick="analyzer.updateBudgetPlan()">Update Budget Plan</button>
                </div>
            </div>
        </main>

        <footer role="contentinfo">
            <nav class="workflow-nav" aria-label="Workflow navigation">
                <a href="income-allocation.html" class="nav-arrow">‚Üê Back to Budget Planner</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="retirement-simulator.html" class="nav-arrow">Continue to Retirement Simulator ‚Üí</a>
            </nav>
            <p class="version-text">v2025.12.29</p>
        </footer>
    </div>

    <script>
        class TransactionAnalyzer {
            constructor() {
                this.transactions = [];
                this.lastBulkAction = null; // For undo functionality
                this.targets = {
                    income: 5000,
                    fixedCosts: 50,
                    shortTerm: 20,
                    longTerm: 20,
                    guiltFree: 10
                };

                // Category patterns for auto-categorization
                this.categoryPatterns = {
                    'fixed-costs': [
                        // Housing
                        /rent|mortgage|hoa|property.*tax|home.*insurance|landlord|apartment|lease/i,
                        // Utilities
                        /electric|gas.*company|water.*bill|sewage|trash|waste|pge|con.*ed|duke.*energy|xcel|national.*grid|dominion/i,
                        /comcast|xfinity|spectrum|at&t|verizon|t-mobile|sprint|cricket|internet|cable|fiber|broadband/i,
                        // Phone
                        /phone.*bill|wireless|cell.*phone|mobile.*plan/i,
                        // Insurance
                        /geico|allstate|state.*farm|progressive|liberty.*mutual|insurance|health.*plan|aetna|cigna|united.*health|blue.*cross|anthem|kaiser/i,
                        // Car
                        /car.*payment|auto.*loan|toyota.*financial|honda.*financial|ford.*credit|gm.*financial|bmw.*financial|mercedes.*financial/i,
                        // Debt payments
                        /student.*loan|nelnet|navient|fedloan|sofi|earnest|loan.*payment|great.*lakes|mohela/i,
                        /credit.*card.*payment|minimum.*payment|debt.*payment/i,
                        // Groceries (essential)
                        /grocery|safeway|kroger|publix|trader.*joe|whole.*foods|aldi|costco|walmart|target|wegmans|heb|albertsons|giant|stop.*shop|food.*lion|winco|sprouts|meijer|food.*city/i,
                        // Healthcare essentials
                        /pharmacy|cvs|walgreens|rite.*aid|prescription|doctor|medical|copay|hospital|clinic|urgent.*care|lab|quest.*diagnostics|labcorp/i,
                        // Childcare
                        /daycare|childcare|preschool|tuition|school|kindercare|bright.*horizons/i,
                        // Transportation essentials
                        /gas.*station|shell|chevron|exxon|mobil|bp|arco|speedway|wawa|parking|toll|ez.*pass|sunpass|fastrak/i,
                        /uber(?!.*eats)|lyft|transit|metro|subway.*fare|bus.*pass|caltrain|bart|mta|wmata/i,
                        // Bank fees (unfortunately essential)
                        /bank.*fee|monthly.*fee|service.*charge|overdraft/i
                    ],
                    'short-term': [
                        // Savings transfers
                        /transfer.*to.*savings|savings.*deposit|marcus|ally.*savings|hysa/i,
                        /emergency.*fund|vacation.*fund|sinking.*fund/i
                    ],
                    'long-term': [
                        // Retirement & Investments
                        /401k|403b|ira|roth|vanguard|fidelity|schwab|etrade|robinhood|wealthfront|betterment/i,
                        /investment|brokerage|stock.*purchase|dividend/i
                    ],
                    'guilt-free': [
                        // Dining & Drinks
                        /restaurant|cafe|coffee|starbucks|dunkin|mcdonald|burger|pizza|chipotle|taco.*bell|wendy|chick-fil-a|panera|subway|panda.*express/i,
                        /doordash|uber.*eats|grubhub|postmates|instacart|seamless|caviar|gopuff/i,
                        /bar|brewery|pub|tavern|wine|liquor|total.*wine|bevmo/i,
                        // Entertainment & Streaming
                        /netflix|hulu|disney|hbo|max|amazon.*prime|spotify|apple.*music|youtube.*premium|paramount|peacock|crunchyroll|funimation/i,
                        /movie|cinema|amc|regal|concert|ticket|eventbrite|stubhub|ticketmaster|livenation|fandango/i,
                        /gaming|playstation|xbox|nintendo|steam|twitch|epic.*games|riot|blizzard/i,
                        // Apple (subscriptions, App Store, iTunes)
                        /apple\.com|apple\.com\/bill|itunes|app.*store|icloud/i,
                        // Google (Play Store, YouTube, etc)
                        /google.*play|google.*storage|google.*one|youtube/i,
                        // Other Tech Subscriptions
                        /microsoft|office.*365|adobe|creative.*cloud|dropbox|evernote|notion|slack|zoom|canva/i,
                        // Shopping
                        /amazon(?!.*prime.*member)|ebay|etsy|target(?!.*grocery)|walmart(?!.*grocery)|best.*buy|home.*depot|lowes|ikea|wayfair|overstock/i,
                        /nordstrom|macy|kohls|tj.*maxx|marshalls|ross|old.*navy|gap|h&m|zara|uniqlo|shein|asos|fashion.*nova/i,
                        /sephora|ulta|beauty|salon|spa|haircut|barber|nail|massage/i,
                        // Hobbies & Fitness
                        /gym|fitness|peloton|planet.*fitness|orange.*theory|crossfit|yoga|equinox|lifetime/i,
                        /golf|ski|sports|hobby|craft|book|audible|kindle|barnes.*noble/i,
                        // Subscriptions & Memberships
                        /subscription|membership|patreon|substack|medium|onlyfans|twitch.*sub/i,
                        /amazon.*prime.*member|costco.*member|sam.*club.*member/i,
                        // Travel & Leisure
                        /hotel|airbnb|vrbo|airline|flight|united|delta|american.*air|southwest|jetblue|spirit|frontier|expedia|booking|kayak|hotels\.com|tripadvisor/i,
                        // Food delivery & meal kits
                        /hellofresh|blue.*apron|factor|freshly|daily.*harvest/i,
                        // Dating & Social
                        /tinder|bumble|hinge|match\.com|dating/i,
                        // Pet
                        /petco|petsmart|chewy|pet.*supplies/i
                    ],
                    'income': [
                        /payroll|direct.*deposit|salary|wage|employer|paycheck/i,
                        /irs|tax.*refund|refund/i,
                        /dividend|interest.*payment|interest.*earned/i,
                        /venmo.*from|zelle.*from|paypal.*from|cash.*app.*from/i,
                        /reimbursement|expense.*reimburse/i
                    ]
                };

                // Column detection configuration (auto-detects common bank formats)
                this.columnConfig = {
                    dateCol: [
                        'Date', 'Transaction Date', 'Trans Date', 'Trans. Date',
                        'Posted Date', 'Posting Date', 'Post Date', 'Settlement Date',
                        'Trade Date', 'Value Date', 'Effective Date', 'Process Date',
                        'Txn Date', 'Transaction_Date', 'TransactionDate', 'BookingDate',
                        'Booking Date', 'Entry Date', 'Cleared Date'
                    ],
                    descCol: [
                        'Description', 'Memo', 'Name', 'Merchant', 'Payee',
                        'Transaction Description', 'Trans Description', 'Details',
                        'Original Description', 'Narrative', 'Particulars', 'Reference',
                        'Transaction', 'Trans', 'Merchant Name', 'Vendor', 'Payee Name',
                        'Transaction Details', 'Payment Details', 'Remarks'
                    ],
                    amountCol: [
                        'Amount', 'Transaction Amount', 'Value', 'Sum', 'Total',
                        'Net Amount', 'Payment Amount', 'Trans Amount', 'Amt'
                    ],
                    debitCol: [
                        'Debit', 'Debit Amount', 'Debits', 'Withdrawal', 'Withdrawals',
                        'Money Out', 'Spent', 'Charge', 'Charges', 'Debit Amt', 'Expense', 'Outflow'
                    ],
                    creditCol: [
                        'Credit', 'Credit Amount', 'Credits', 'Deposit', 'Deposits',
                        'Money In', 'Received', 'Payment Received', 'Refund', 'Credit Amt', 'Inflow'
                    ],
                    // Transaction type column that indicates debit/credit (e.g., Capital One 360)
                    typeCol: [
                        'Transaction Type', 'Trans Type', 'Type', 'Tran Type'
                    ]
                };

                // Load saved rules from localStorage
                this.loadSavedRules();
                this.init();
            }

            init() {
                // File upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });
                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                // Target inputs - monthlyIncome with currency formatting
                const incomeInput = document.getElementById('monthlyIncome');
                incomeInput.addEventListener('input', (e) => {
                    this.targets.income = this.parseCurrencyValue(e.target.value);
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                incomeInput.addEventListener('focus', (e) => {
                    const value = this.parseCurrencyValue(e.target.value);
                    e.target.value = value > 0 ? value.toFixed(2) : '';
                });
                incomeInput.addEventListener('blur', (e) => {
                    const value = this.parseCurrencyValue(e.target.value);
                    e.target.value = this.formatCurrencyInput(value);
                });
                document.getElementById('targetFixed').addEventListener('input', (e) => {
                    this.targets.fixedCosts = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetShortTerm').addEventListener('input', (e) => {
                    this.targets.shortTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetLongTerm').addEventListener('input', (e) => {
                    this.targets.longTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetGuiltFree').addEventListener('input', (e) => {
                    this.targets.guiltFree = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });

                // Filters - reset pagination when filter changes
                document.getElementById('categoryFilter').addEventListener('change', () => {
                    this.currentMobilePage = 1;
                    this.renderTransactions();
                });
                document.getElementById('sortOrder').addEventListener('change', () => {
                    this.currentMobilePage = 1;
                    this.renderTransactions();
                });
            }

            handleFiles(files) {
                // Early return if no files provided
                if (!files || files.length === 0) {
                    return;
                }

                // File size limits
                const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB hard limit
                const WARN_FILE_SIZE = 5 * 1024 * 1024; // 5MB warning threshold

                for (const file of files) {
                    if (file.size > MAX_FILE_SIZE) {
                        this.showError(`File "${file.name}" is too large (${(file.size / 1024 / 1024).toFixed(1)}MB).\n\nMaximum file size is 10MB. Please split large files into smaller chunks.`);
                        return;
                    }
                    if (file.size > WARN_FILE_SIZE) {
                        console.warn(`Large file detected: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB). Processing may be slow.`);
                    }
                }

                const promises = Array.from(files).map(file => this.parseCSV(file));

                Promise.all(promises).then(results => {
                    // Separate successful and failed file results
                    const successful = results.filter(r => !r.error && r.transactions.length > 0);
                    const failed = results.filter(r => r.error);
                    const empty = results.filter(r => !r.error && r.transactions.length === 0);

                    // Collect all transactions from successful files
                    this.transactions = successful.flatMap(r => r.transactions);
                    this.transactions.sort((a, b) => new Date(b.date) - new Date(a.date));

                    // Deduplicate inter-account transfers
                    this.deduplicateTransfers();

                    // Auto-categorize
                    this.transactions.forEach(t => {
                        if (!t.category) {
                            t.category = this.categorizeTransaction(t);
                        }
                    });

                    // Show results if we have any transactions
                    if (this.transactions.length > 0) {
                        this.updateDisplay();
                        document.getElementById('resultsSection').classList.remove('results-hidden');

                        // Save transactions to localStorage for session persistence
                        StorageUtils.set('transactionData', this.transactions);

                        // Save spending data for Retirement Forecast page
                        this.saveSpendingDataForRetirement();
                    }

                    // Show upload summary with per-file results
                    this.showUploadSummary(successful, failed, empty);
                });
            }

            showUploadSummary(successful, failed, empty) {
                const uploadArea = document.getElementById('uploadArea');

                // Remove existing success info if any
                const existingInfo = document.querySelector('.upload-success-info');
                if (existingInfo) existingInfo.remove();

                // If all files failed, show error
                if (successful.length === 0 && failed.length > 0) {
                    uploadArea.classList.remove('success');
                    const errorMessages = failed.map(f => `${this.escapeHtml(f.fileName)}: ${this.escapeHtml(f.error)}`).join('\n\n');
                    this.showError(`Failed to parse CSV file(s):\n\n${errorMessages}`);
                    return;
                }

                // Show success state
                uploadArea.classList.add('success');

                const totalTransactions = successful.reduce((sum, r) => sum + r.transactions.length, 0);
                const totalWarnings = successful.reduce((sum, r) => sum + r.warnings.length, 0);
                const transferCount = this.transactions.filter(t => t.isTransfer).length;

                const successInfo = document.createElement('div');
                successInfo.className = 'upload-success-info';

                let html = `<strong>Successfully loaded ${totalTransactions.toLocaleString()} transactions!</strong>`;

                // Per-file breakdown if multiple files
                if (successful.length > 1 || failed.length > 0) {
                    html += `<div style="margin-top: 10px; font-size: 0.9em;">`;
                    for (const result of successful) {
                        const detectionMethod = result.columnMapping?.detectedBy === 'ai' ? ' (AI-detected)' : '';
                        const warningBadge = result.warnings.length > 0
                            ? `<span style="color: #f59e0b;"> ‚ö† ${result.warnings.length} skipped</span>`
                            : '';
                        html += `<div style="color: #10b981;">‚úì ${this.escapeHtml(result.fileName)}: ${result.transactions.length} transactions${detectionMethod}${warningBadge}</div>`;
                    }
                    for (const result of failed) {
                        html += `<div style="color: #ef4444;">‚úó ${this.escapeHtml(result.fileName)}: ${this.escapeHtml(result.error)}</div>`;
                    }
                    html += `</div>`;
                }

                if (transferCount > 0) {
                    html += `<span style="color: #10b981; font-size: 0.9em; margin-top: 5px; display: block;">&#10004; ${transferCount} inter-account transfers detected and excluded from totals</span>`;
                }

                if (totalWarnings > 0) {
                    html += `<span style="color: #f59e0b; font-size: 0.9em; margin-top: 5px; display: block;">‚ö† ${totalWarnings} rows skipped (invalid dates or amounts)</span>`;
                }

                html += `<div style="background: #f0f9ff; border-left: 3px solid #3b82f6; padding: 10px; margin-top: 10px; font-size: 0.9em;">
                    <strong style="color: #1e40af;">Smart Categorization:</strong>
                    <span style="color: #475569;">Your transactions are first automatically categorized using pattern matching. Use AI categorization below for any remaining uncategorized transactions.</span>
                </div>`;

                successInfo.innerHTML = html;
                uploadArea.parentNode.insertBefore(successInfo, uploadArea.nextSibling);

                // Update upload area text to indicate more files can be added
                const uploadText = uploadArea.querySelector('.upload-text');
                if (uploadText) {
                    uploadText.textContent = 'Drop more CSV files to add transactions';
                }
            }

            showError(errorMessage) {
                // Remove any existing error messages
                const existingError = document.querySelector('.upload-error-info');
                if (existingError) existingError.remove();

                // Create error message element
                const errorDiv = document.createElement('div');
                errorDiv.className = 'upload-error-info';
                errorDiv.style.cssText = `
                    background: #fef2f2;
                    border: 2px solid #ef4444;
                    border-radius: 8px;
                    padding: 20px;
                    margin: 20px auto;
                    max-width: 800px;
                    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
                `;

                // Format the error message (escape HTML first, then preserve newlines and structure)
                const formattedMessage = this.escapeHtml(errorMessage)
                    .replace(/\n\n/g, '<br><br>')
                    .replace(/\n‚Ä¢/g, '<br>‚Ä¢');

                errorDiv.innerHTML = `
                    <div style="display: flex; align-items: start; gap: 15px;">
                        <div style="font-size: 2em; color: #ef4444;">‚ö†Ô∏è</div>
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 10px 0; color: #991b1b; font-size: 1.2em;">CSV Upload Error</h3>
                            <div style="color: #7f1d1d; white-space: pre-wrap; font-family: inherit; line-height: 1.6;">${formattedMessage}</div>
                            <button onclick="this.parentElement.parentElement.parentElement.remove()"
                                    style="margin-top: 15px; padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                Dismiss
                            </button>
                        </div>
                    </div>
                `;

                // Insert after upload area
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.parentNode.insertBefore(errorDiv, uploadArea.nextSibling);

                // Scroll to error message
                errorDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            saveSpendingDataForRetirement() {
                // Calculate monthly averages for Retirement Forecast
                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date)).filter(d => !isNaN(d));

                // Default to 1 month if no valid dates
                let months = 1;
                if (dates.length > 0) {
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));
                }

                const monthlySpending = (categories['fixed-costs']?.total || 0) / months +
                                        (categories['guilt-free']?.total || 0) / months;
                const monthlyLongTermSavings = (categories['long-term']?.total || 0) / months;

                // Save for Retirement Forecast
                StorageUtils.set('spendingTrackerData', {
                    monthlySpending: Math.round(monthlySpending),
                    monthlyRetirementSavings: Math.round(monthlyLongTermSavings),
                    lastUpdated: new Date().toISOString()
                });
            }

            parseCSV(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const text = this.preprocessText(e.target.result);
                            const result = await this.parseCSVText(text, file.name);
                            resolve(result);
                        } catch (error) {
                            // Return error info instead of rejecting, for graceful multi-file handling
                            resolve({
                                transactions: [],
                                fileName: file.name,
                                error: error.message,
                                warnings: []
                            });
                        }
                    };
                    reader.onerror = () => resolve({
                        transactions: [],
                        fileName: file.name,
                        error: 'Failed to read file',
                        warnings: []
                    });
                    reader.readAsText(file);
                });
            }

            // Preprocess CSV text: remove BOM, normalize line endings
            preprocessText(text) {
                // Remove UTF-8 BOM if present
                if (text.charCodeAt(0) === 0xFEFF) {
                    text = text.slice(1);
                }
                // Normalize line endings (Windows \r\n, old Mac \r, Unix \n)
                text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                return text.trim();
            }

            async parseCSVText(text, fileName = 'unknown') {
                const lines = text.split('\n');
                const warnings = [];

                if (lines.length < 2) {
                    throw new Error('CSV file is empty or has no data rows.');
                }

                // Parse header
                const header = this.parseCSVLine(lines[0]);

                // Get sample rows for format detection
                const sampleRows = [];
                for (let i = 1; i < Math.min(lines.length, 6); i++) {
                    const line = lines[i].trim();
                    if (line) sampleRows.push(this.parseCSVLine(line));
                }

                // Detect column mapping
                let columnMapping = this.detectColumns(header, sampleRows);

                // If detection failed and AI is available, try AI-assisted detection
                if (!columnMapping.success && this.hasAIConfigured()) {
                    try {
                        columnMapping = await this.detectColumnsWithAI(header, sampleRows, fileName);
                    } catch (e) {
                        console.warn('AI column detection failed:', e);
                    }
                }

                // If still no success, throw with helpful error
                if (!columnMapping.success) {
                    const foundColumns = header.map(h => `"${h}"`).join(', ');
                    throw new Error(
                        `Could not detect columns in "${fileName}".\n\n` +
                        `Found columns: ${foundColumns}\n\n` +
                        `Expected: Date, Description, and either Amount or Debit/Credit columns.`
                    );
                }

                // Detect date format from sample data
                const dateFormat = this.detectDateFormat(sampleRows, columnMapping.dateIdx);

                // Parse transactions
                const transactions = [];
                const { dateIdx, descIdx, amountIdx, debitIdx, creditIdx, typeIdx, mode } = columnMapping;
                const requiredIdx = Math.max(dateIdx, descIdx, amountIdx ?? -1, debitIdx ?? -1, creditIdx ?? -1, typeIdx ?? -1);

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = this.parseCSVLine(line);

                    // Skip rows that don't have enough columns
                    if (values.length <= requiredIdx) {
                        warnings.push({ row: i + 1, issue: 'insufficient_columns' });
                        continue;
                    }

                    const dateStr = values[dateIdx]?.trim();
                    const description = values[descIdx]?.trim();

                    // Parse amount based on mode
                    let amount;
                    if (mode === 'debit_credit') {
                        // Separate Debit/Credit columns (e.g., Capital One credit card)
                        const credit = this.parseAmount(values[creditIdx]) || 0;
                        const debit = this.parseAmount(values[debitIdx]) || 0;
                        amount = credit - debit;
                    } else if (mode === 'amount_with_type') {
                        // Amount + Type column (e.g., Capital One 360)
                        // Amount is always positive, Type indicates direction
                        amount = this.parseAmount(values[amountIdx]);
                        const transType = values[typeIdx]?.trim().toLowerCase() || '';
                        // If type indicates debit/withdrawal/expense, negate the amount
                        // Use word boundaries to avoid matching "in" inside words like "PARTNERFI"
                        if (/\b(debit|withdrawal|expense|payment|out)\b/i.test(transType)) {
                            amount = -Math.abs(amount);
                        } else if (/\b(credit|deposit|income|in)\b/i.test(transType)) {
                            amount = Math.abs(amount);
                        }
                    } else {
                        // Single signed amount column (e.g., Chase)
                        amount = this.parseAmount(values[amountIdx]);
                    }

                    const date = this.parseDateWithFormat(dateStr, dateFormat);

                    if (!date) {
                        warnings.push({ row: i + 1, issue: 'invalid_date', value: dateStr });
                        continue;
                    }
                    if (isNaN(amount) || amount === 0) {
                        // Skip zero-amount transactions (often headers or summary rows)
                        if (amount === 0 && !/balance|total|summary/i.test(description || '')) {
                            warnings.push({ row: i + 1, issue: 'zero_amount' });
                        }
                        continue;
                    }

                    transactions.push({
                        date: date,
                        description: description || '',
                        amount: amount,
                        category: null,
                        id: `${fileName}-${date}-${description}-${amount}-${i}`,
                        sourceFile: fileName
                    });
                }

                // If no transactions were parsed, throw a helpful error
                if (transactions.length === 0) {
                    const issues = [];
                    const dateErrors = warnings.filter(w => w.issue === 'invalid_date').length;
                    const amountErrors = warnings.filter(w => w.issue === 'zero_amount').length;
                    if (dateErrors > 0) issues.push(`${dateErrors} rows with unrecognized dates`);
                    if (amountErrors > 0) issues.push(`${amountErrors} rows with zero/invalid amounts`);

                    // Debug info to help diagnose parsing issues
                    const rawAmountIdx = this.findColumnIndex(header, this.columnConfig.amountCol);
                    const debugInfo = [
                        `Detected columns: date=${dateIdx}, desc=${descIdx}, amount=${amountIdx} (raw=${rawAmountIdx}), type=${typeIdx ?? 'none'}`,
                        `Mode: ${mode}`,
                        `Header (${header.length} cols): [${header.map((h, i) => `${i}:"${h}"`).join(', ')}]`,
                        sampleRows.length > 0 ? `Sample row[0]: [${sampleRows[0].map((v, i) => `${i}:"${v}"`).join(', ')}]` : 'No sample rows',
                        sampleRows.length > 0 && amountIdx !== null ? `Sample amount (col ${amountIdx}): "${sampleRows[0][amountIdx]}" ‚Üí parsed: ${this.parseAmount(sampleRows[0][amountIdx])}` : 'No amount column'
                    ];

                    throw new Error(
                        `No valid transactions found in "${fileName}".\n\n` +
                        (issues.length > 0 ? `Issues: ${issues.join(', ')}\n\n` : '') +
                        `Debug info:\n${debugInfo.join('\n')}\n\n` +
                        'Check that date and amount formats are standard.'
                    );
                }

                return {
                    transactions,
                    fileName,
                    warnings,
                    columnMapping,
                    error: null
                };
            }

            // Detect columns with expanded logic for Debit/Credit
            detectColumns(header, sampleRows) {
                const dateIdx = this.findColumnIndex(header, this.columnConfig.dateCol);
                const descIdx = this.findColumnIndex(header, this.columnConfig.descCol);
                let amountIdx = this.findColumnIndex(header, this.columnConfig.amountCol);
                const debitIdx = this.findColumnIndex(header, this.columnConfig.debitCol);
                const creditIdx = this.findColumnIndex(header, this.columnConfig.creditCol);
                const typeIdx = this.findColumnIndex(header, this.columnConfig.typeCol);

                // Check if we have the required columns
                const hasDate = dateIdx !== -1;
                const hasDesc = descIdx !== -1;
                let hasAmount = amountIdx !== -1;
                const hasDebitCredit = debitIdx !== -1 && creditIdx !== -1;
                const hasTypeColumn = typeIdx !== -1;

                // If we matched Amount to a Debit or Credit column, clear it and use split mode
                if (hasAmount && (amountIdx === debitIdx || amountIdx === creditIdx)) {
                    amountIdx = -1;
                    hasAmount = false;
                }

                // Check if amounts are already signed (have negatives) by looking at sample data
                // Also check for Unicode minus signs: ‚àí (U+2212), ‚Äì (en dash), ‚Äî (em dash)
                let amountsAreSigned = false;
                if (hasAmount && sampleRows.length > 0) {
                    for (const row of sampleRows) {
                        const amtStr = row[amountIdx];
                        if (amtStr && /^[\s]*[-\u2212\u2013\u2014]/.test(amtStr)) {
                            amountsAreSigned = true;
                            break;
                        }
                    }
                }

                // Determine the mode
                let mode = 'unknown';
                if (hasDebitCredit) {
                    mode = 'debit_credit';      // e.g., Capital One credit card: separate columns
                } else if (hasAmount && hasTypeColumn && !amountsAreSigned) {
                    mode = 'amount_with_type';  // e.g., Capital One 360: unsigned amount + type column
                } else if (hasAmount) {
                    mode = 'single_amount';     // e.g., Chase: signed amount column
                }

                const success = hasDate && hasDesc && (hasAmount || hasDebitCredit);

                return {
                    success,
                    dateIdx,
                    descIdx,
                    amountIdx: hasAmount ? amountIdx : null,
                    debitIdx: hasDebitCredit ? debitIdx : null,
                    creditIdx: hasDebitCredit ? creditIdx : null,
                    typeIdx: (hasTypeColumn && mode === 'amount_with_type') ? typeIdx : null,
                    mode,
                    detectedBy: 'auto'
                };
            }

            // Parse amount with support for various formats
            parseAmount(value) {
                if (value === null || value === undefined || value === '') return 0;

                let str = String(value).trim();

                // Normalize Unicode minus signs to ASCII hyphen-minus
                // Common Unicode minus characters: ‚àí (U+2212), ‚Äì (en dash U+2013), ‚Äî (em dash U+2014)
                str = str.replace(/[\u2212\u2013\u2014]/g, '-');

                // Handle parentheses notation for negatives: (100.00) -> -100.00
                const isParenthesesNegative = /^\([\d,.\s]+\)$/.test(str);
                if (isParenthesesNegative) {
                    str = '-' + str.replace(/[()]/g, '');
                }

                // Handle trailing minus: 100.00- -> -100.00
                if (/^[\d,.\s]+-$/.test(str)) {
                    str = '-' + str.slice(0, -1);
                }

                // Handle CR/DR suffixes: 100.00 CR -> 100.00, 100.00 DR -> -100.00
                if (/\s*CR\s*$/i.test(str)) {
                    str = str.replace(/\s*CR\s*$/i, '');
                } else if (/\s*DR\s*$/i.test(str)) {
                    str = '-' + str.replace(/\s*DR\s*$/i, '');
                }

                // Remove currency symbols and thousand separators
                str = str.replace(/[$¬£‚Ç¨¬•‚Çπ,\s]/g, '');

                // Handle European decimal format (1.234,56 -> 1234.56)
                // If there's a comma after a period, it's European format
                if (/\d+\.\d{3},\d{2}$/.test(str)) {
                    str = str.replace(/\./g, '').replace(',', '.');
                }

                return parseFloat(str) || 0;
            }

            // Detect date format from sample data
            detectDateFormat(sampleRows, dateIdx) {
                if (!sampleRows.length || dateIdx === -1) return null;

                const dateStrings = sampleRows
                    .map(row => row[dateIdx])
                    .filter(Boolean)
                    .slice(0, 10);

                // Check for named months (unambiguous)
                for (const dateStr of dateStrings) {
                    if (/[a-zA-Z]{3,}/.test(dateStr)) {
                        return 'named_month';
                    }
                }

                // Check for ISO format YYYY-MM-DD
                for (const dateStr of dateStrings) {
                    if (/^\d{4}[-/]\d{1,2}[-/]\d{1,2}/.test(dateStr)) {
                        return 'YYYY-MM-DD';
                    }
                }

                // Analyze numeric dates to determine day vs month position
                let maxFirst = 0, maxSecond = 0;
                for (const dateStr of dateStrings) {
                    const match = dateStr.match(/^(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/);
                    if (match) {
                        maxFirst = Math.max(maxFirst, parseInt(match[1], 10));
                        maxSecond = Math.max(maxSecond, parseInt(match[2], 10));
                    }
                }

                // If first position > 12, it must be day (DD/MM/YYYY)
                if (maxFirst > 12) return 'DD/MM/YYYY';
                // If second position > 12, it must be day (MM/DD/YYYY)
                if (maxSecond > 12) return 'MM/DD/YYYY';

                // Ambiguous - default to US format
                return 'MM/DD/YYYY';
            }

            // Parse date with detected format
            parseDateWithFormat(dateStr, format) {
                if (!dateStr) return null;
                dateStr = dateStr.trim();

                // Try named month formats first
                if (format === 'named_month' || /[a-zA-Z]/.test(dateStr)) {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        return date.toISOString().split('T')[0];
                    }
                }

                // ISO format
                if (format === 'YYYY-MM-DD') {
                    const match = dateStr.match(/^(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})/);
                    if (match) {
                        const [_, year, month, day] = match;
                        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                    }
                }

                // DD/MM/YYYY format
                if (format === 'DD/MM/YYYY') {
                    const match = dateStr.match(/^(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/);
                    if (match) {
                        let [_, day, month, year] = match;
                        if (year.length === 2) year = (parseInt(year) > 50 ? '19' : '20') + year;
                        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                    }
                }

                // MM/DD/YYYY format (default)
                const match = dateStr.match(/^(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})/);
                if (match) {
                    let [_, month, day, year] = match;
                    if (year.length === 2) year = (parseInt(year) > 50 ? '19' : '20') + year;
                    return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                }

                // Fallback to DateUtils
                return DateUtils.parseDate(dateStr);
            }

            // Check if AI API is configured
            hasAIConfigured() {
                const geminiKey = document.getElementById('geminiApiKey')?.value;
                const openaiKey = document.getElementById('openaiApiKey')?.value;
                const anthropicKey = document.getElementById('anthropicApiKey')?.value;
                return !!(geminiKey || openaiKey || anthropicKey);
            }

            // AI-assisted column detection
            async detectColumnsWithAI(header, sampleRows, fileName) {
                const prompt = `Analyze this CSV file structure and identify the columns for a financial transaction import.

File: ${fileName}
Headers: ${JSON.stringify(header)}
Sample data rows:
${sampleRows.slice(0, 3).map((row, i) => `Row ${i + 1}: ${JSON.stringify(row)}`).join('\n')}

Identify which column index (0-based) contains:
1. Transaction date
2. Description/merchant/payee
3. Amount (single column), OR separate Debit and Credit columns

Return ONLY a JSON object (no markdown, no explanation):
{
  "dateIdx": <number>,
  "descIdx": <number>,
  "amountIdx": <number or null if using debit/credit>,
  "debitIdx": <number or null>,
  "creditIdx": <number or null>,
  "dateFormat": "<detected format like MM/DD/YYYY or YYYY-MM-DD>",
  "confidence": "<high|medium|low>"
}`;

                try {
                    const response = await this.callAIForColumnDetection(prompt);
                    const parsed = JSON.parse(response.replace(/```json\n?|\n?```/g, '').trim());

                    return {
                        success: parsed.dateIdx !== undefined && parsed.descIdx !== undefined &&
                                 (parsed.amountIdx !== null || (parsed.debitIdx !== null && parsed.creditIdx !== null)),
                        dateIdx: parsed.dateIdx,
                        descIdx: parsed.descIdx,
                        amountIdx: parsed.amountIdx,
                        debitIdx: parsed.debitIdx,
                        creditIdx: parsed.creditIdx,
                        mode: parsed.amountIdx !== null ? 'single_amount' : 'debit_credit',
                        detectedBy: 'ai',
                        confidence: parsed.confidence
                    };
                } catch (e) {
                    console.error('AI column detection error:', e);
                    throw e;
                }
            }

            // Call AI API for column detection (reuses existing API infrastructure)
            async callAIForColumnDetection(prompt) {
                const geminiKey = document.getElementById('geminiApiKey')?.value;
                const openaiKey = document.getElementById('openaiApiKey')?.value;
                const anthropicKey = document.getElementById('anthropicApiKey')?.value;

                if (geminiKey) {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${geminiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { temperature: 0.1, maxOutputTokens: 500 }
                        })
                    });
                    const data = await response.json();
                    return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                }

                if (openaiKey) {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openaiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [{ role: 'user', content: prompt }],
                            temperature: 0.1,
                            max_tokens: 500
                        })
                    });
                    const data = await response.json();
                    return data.choices?.[0]?.message?.content || '';
                }

                if (anthropicKey) {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': anthropicKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-5-haiku-latest',
                            max_tokens: 500,
                            messages: [{ role: 'user', content: prompt }]
                        })
                    });
                    const data = await response.json();
                    return data.content?.[0]?.text || '';
                }

                throw new Error('No AI API configured');
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        // Handle escaped quotes (RFC 4180: "" inside quoted field = literal ")
                        if (inQuotes && line[i + 1] === '"') {
                            current += '"';
                            i++; // Skip next quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());

                return result;
            }

            findColumnIndex(header, possibleNames) {
                // Normalize a string for flexible matching
                const normalize = (str) => {
                    return str
                        .toLowerCase()
                        .trim()
                        .replace(/[.\-_]/g, ' ')  // Replace punctuation with spaces
                        .replace(/\s+/g, ' ')      // Normalize multiple spaces to single space
                        .trim();
                };

                const namesToCheck = typeof possibleNames === 'string' ? [possibleNames] : possibleNames;

                // First pass: exact match (case-insensitive)
                for (const name of namesToCheck) {
                    const idx = header.findIndex(h => h.toLowerCase().trim() === name.toLowerCase());
                    if (idx !== -1) return idx;
                }

                // Second pass: normalized match (handles punctuation/spacing differences)
                for (const name of namesToCheck) {
                    const normalizedName = normalize(name);
                    const idx = header.findIndex(h => normalize(h) === normalizedName);
                    if (idx !== -1) return idx;
                }

                // Third pass: partial match (header contains the search term)
                // Only match if header is MORE specific than pattern (e.g., "Transaction Amount" matches "Amount")
                // Do NOT match if pattern is more specific (e.g., "Debit Amount" should NOT match plain "Amount" header)
                for (const name of namesToCheck) {
                    const normalizedName = normalize(name);
                    const idx = header.findIndex(h => {
                        const normalizedHeader = normalize(h);
                        // Only match if header contains the pattern name (header is more specific)
                        return normalizedHeader.includes(normalizedName);
                    });
                    if (idx !== -1) return idx;
                }

                return -1;
            }

            parseDate(dateStr) {
                return DateUtils.parseDate(dateStr);
            }

            categorizeTransaction(transaction) {
                const result = this.categorizeWithConfidence(transaction);
                return result.category;
            }

            // Categorize with confidence scoring and sanity checks
            categorizeWithConfidence(transaction) {
                const desc = transaction.description.toLowerCase();
                const amount = transaction.amount;
                const matches = [];

                // Collect ALL pattern matches across categories
                for (const [category, patterns] of Object.entries(this.categoryPatterns)) {
                    for (const pattern of patterns) {
                        if (pattern.test(desc)) {
                            matches.push({ category, pattern: pattern.toString() });
                        }
                    }
                }

                // No matches - return uncategorized
                if (matches.length === 0) {
                    // For positive amounts with no pattern match, still mark as income but low confidence
                    if (amount > 0) {
                        return { category: 'income', confidence: 'low', reason: 'positive-amount-no-pattern' };
                    }
                    return { category: 'uncategorized', confidence: 'none', reason: 'no-match' };
                }

                // Single match - straightforward
                if (matches.length === 1) {
                    const match = matches[0];
                    // Sanity check: income pattern but negative amount
                    if (match.category === 'income' && amount < 0) {
                        return { category: 'uncategorized', confidence: 'low', reason: 'income-pattern-negative-amount' };
                    }
                    // Sanity check: expense category but positive amount (refund?)
                    if (match.category !== 'income' && amount > 0) {
                        return { category: 'income', confidence: 'medium', reason: 'expense-pattern-positive-amount-likely-refund' };
                    }
                    return { category: match.category, confidence: 'high', reason: 'single-match' };
                }

                // Multiple matches - need to resolve conflict
                const categories = [...new Set(matches.map(m => m.category))];

                // If all matches point to same category, high confidence
                if (categories.length === 1) {
                    const category = categories[0];
                    // Apply same sanity checks
                    if (category === 'income' && amount < 0) {
                        return { category: 'uncategorized', confidence: 'low', reason: 'income-pattern-negative-amount' };
                    }
                    if (category !== 'income' && amount > 0) {
                        return { category: 'income', confidence: 'medium', reason: 'expense-pattern-positive-amount-likely-refund' };
                    }
                    return { category, confidence: 'high', reason: 'multiple-matches-same-category' };
                }

                // Conflicting categories - use amount as tiebreaker
                if (amount > 0 && categories.includes('income')) {
                    return { category: 'income', confidence: 'medium', reason: 'conflict-resolved-by-positive-amount' };
                }

                // For negative amounts, prefer expense categories in priority order
                const expensePriority = ['fixed-costs', 'guilt-free', 'long-term', 'short-term'];
                for (const cat of expensePriority) {
                    if (categories.includes(cat)) {
                        return { category: cat, confidence: 'low', reason: 'conflict-first-match-priority' };
                    }
                }

                return { category: matches[0].category, confidence: 'low', reason: 'conflict-fallback' };
            }

            deduplicateTransfers() {
                // Mark inter-account transfers as duplicates
                // A transfer is detected when:
                // 1. Two transactions have opposite amounts (one positive, one negative)
                // 2. Amounts match exactly or within small tolerance
                // 3. Dates are within a few days
                // 4. At least one description contains strong transfer indicators

                const DAYS_TOLERANCE = 3; // Reduced from 5 for fewer false positives
                const AMOUNT_TOLERANCE = 0.01; // Exact match for most transfers

                // Reset all isTransfer flags (but preserve manual overrides)
                this.transactions.forEach(t => {
                    if (!t.manuallyUnmarkedTransfer) {
                        t.isTransfer = false;
                    }
                });

                // Strong transfer indicators (require at least one)
                const strongTransferKeywords = [
                    'transfer to', 'transfer from', 'online transfer',
                    'credit card payment', 'payment to card', 'card payment',
                    'ach payment', 'electronic payment',
                    'payment thank you', 'autopay'
                ];

                // Account reference patterns (common in inter-account transfers)
                const accountPatterns = [
                    /\*{4}\d{4}/, // ****1234
                    /x{4}\d{4}/i, // xxxx1234
                    /ending in \d{4}/i,
                    /account.*\d{4}/i
                ];

                for (let i = 0; i < this.transactions.length; i++) {
                    const t1 = this.transactions[i];
                    if (t1.isTransfer || t1.manuallyUnmarkedTransfer) continue;

                    for (let j = i + 1; j < this.transactions.length; j++) {
                        const t2 = this.transactions[j];
                        if (t2.isTransfer || t2.manuallyUnmarkedTransfer) continue;

                        // Check if amounts are opposite and match
                        const amountMatch = Math.abs(Math.abs(t1.amount) - Math.abs(t2.amount)) <= AMOUNT_TOLERANCE;
                        const oppositeSign = (t1.amount > 0) !== (t2.amount > 0);

                        if (!amountMatch || !oppositeSign) continue;

                        // Check date proximity
                        const date1 = new Date(t1.date);
                        const date2 = new Date(t2.date);
                        const daysDiff = Math.abs((date1 - date2) / (1000 * 60 * 60 * 24));

                        if (daysDiff > DAYS_TOLERANCE) continue;

                        // Check for strong transfer indicators
                        const desc1 = t1.description.toLowerCase();
                        const desc2 = t2.description.toLowerCase();

                        const hasStrongKeyword = strongTransferKeywords.some(kw =>
                            desc1.includes(kw) || desc2.includes(kw)
                        );

                        const hasAccountRef = accountPatterns.some(pattern =>
                            pattern.test(t1.description) || pattern.test(t2.description)
                        );

                        // Require strong evidence: keyword OR (same day + account reference)
                        if (hasStrongKeyword || (daysDiff === 0 && hasAccountRef)) {
                            t1.isTransfer = true;
                            t2.isTransfer = true;
                            t1.transferMatch = t2.id;
                            t2.transferMatch = t1.id;
                            break;
                        }
                    }
                }

                // Log deduplication results
                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                if (transferCount > 0) {
                    console.log(`Detected and marked ${transferCount} inter-account transfer transactions`);
                }
            }

            updateDisplay() {
                this.updateStats();
                this.updateSummaryCards();
                this.updateComparisonChart();
                this.updateBulkCategorization();
                this.updateTransfersTable();
                this.renderTransactions();
            }

            updateTransfersTable() {
                const transfers = this.transactions.filter(t => t.isTransfer);
                const section = document.getElementById('transfersSection');
                const countEl = document.getElementById('transferCount');
                const tbody = document.getElementById('transfersTableBody');

                if (transfers.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';
                countEl.textContent = transfers.length;

                tbody.innerHTML = transfers.map(t => {
                    const matchedTx = t.transferMatch ? this.transactions.find(tx => tx.id === t.transferMatch) : null;
                    const matchDesc = matchedTx ? this.escapeHtml(matchedTx.description.substring(0, 30)) : 'No match found';
                    return `
                        <tr>
                            <td>${new Date(t.date).toLocaleDateString()}</td>
                            <td>${this.escapeHtml(t.description.substring(0, 40))}${t.description.length > 40 ? '...' : ''}</td>
                            <td class="amount-cell ${t.amount < 0 ? 'expense' : 'income'}">${this.formatCurrency(Math.abs(t.amount))}</td>
                            <td style="font-size: 0.85em; color: #666;">${matchDesc}</td>
                            <td>
                                <button onclick="analyzer.unmarkTransfer('${t.id}')"
                                    style="padding: 4px 10px; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 4px; cursor: pointer; font-size: 0.8em;"
                                    title="Include this in spending/income totals">
                                    Not a transfer
                                </button>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            updateBulkCategorization() {
                const uncategorized = this.transactions.filter(t => t.category === 'uncategorized' && !t.isTransfer);
                const section = document.getElementById('bulkCategorizeSection');
                const container = document.getElementById('bulkGroups');

                if (uncategorized.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';

                // Group by similar description (first 20 chars, normalized)
                const groups = {};
                uncategorized.forEach(t => {
                    const key = t.description
                        .replace(/[0-9#*]+/g, '')
                        .replace(/\s+/g, ' ')
                        .trim()
                        .substring(0, 25)
                        .toLowerCase();

                    if (!groups[key]) {
                        groups[key] = {
                            name: t.description.substring(0, 30),
                            transactions: []
                        };
                    }
                    groups[key].transactions.push(t);
                });

                // Calculate totals for each group and separate $0 groups
                const groupsWithTotals = Object.values(groups).map(group => ({
                    ...group,
                    total: group.transactions.reduce((sum, t) => sum + t.amount, 0)
                }));

                // Separate zero-total groups (refunded/net-zero transactions)
                const zeroGroups = groupsWithTotals.filter(g => Math.abs(g.total) < 0.01);
                const nonZeroGroups = groupsWithTotals.filter(g => Math.abs(g.total) >= 0.01);

                // Sort by count (most frequent first) and take top 20
                const sortedGroups = nonZeroGroups
                    .sort((a, b) => b.transactions.length - a.transactions.length)
                    .slice(0, 20);

                container.innerHTML = '';

                sortedGroups.forEach((group, idx) => {
                    const total = Math.abs(group.total);
                    const groupEl = document.createElement('div');
                    groupEl.className = 'bulk-group';
                    groupEl.innerHTML = `
                        <div class="bulk-group-header" onclick="analyzer.toggleBulkGroup(${idx})">
                            <div class="bulk-group-info">
                                <span class="bulk-group-name">${this.escapeHtml(group.name)}${group.name.length >= 30 ? '...' : ''}</span>
                                <span class="bulk-group-count">${group.transactions.length} transactions ‚Ä¢ ${this.formatCurrency(total)} total</span>
                            </div>
                            <div class="bulk-group-actions">
                                <button class="bulk-btn fixed-costs" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'fixed-costs')">Fixed</button>
                                <button class="bulk-btn guilt-free" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'guilt-free')">Guilt-Free</button>
                                <button class="bulk-btn long-term" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'long-term')">Long-Term</button>
                                <button class="bulk-btn short-term" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'short-term')">Short-Term</button>
                                <button class="bulk-btn income" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'income')">Income</button>
                            </div>
                        </div>
                        <div class="bulk-group-details">
                            ${group.transactions.slice(0, 10).map(t => `
                                <div class="bulk-transaction">
                                    <span>${new Date(t.date).toLocaleDateString()} - ${this.escapeHtml(t.description.substring(0, 40))}</span>
                                    <span style="color: ${t.amount < 0 ? '#ef4444' : '#10b981'}">${this.formatCurrency(Math.abs(t.amount))}</span>
                                </div>
                            `).join('')}
                            ${group.transactions.length > 10 ? `<div style="color: #666; font-size: 0.85em; padding-top: 8px;">...and ${group.transactions.length - 10} more</div>` : ''}
                        </div>
                    `;
                    groupEl.dataset.groupIndex = idx;
                    container.appendChild(groupEl);
                });

                // Store groups for later reference
                this.bulkGroups = sortedGroups;

                // Display zero-total groups separately
                const zeroContainer = document.getElementById('zeroTotalGroups');
                if (zeroGroups.length > 0) {
                    zeroContainer.innerHTML = `
                        <div style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px; padding: 15px; margin-top: 15px;">
                            <h3 style="color: #0369a1; margin: 0 0 10px 0; font-size: 1em;">Net-Zero Transactions (Not requiring categorization)</h3>
                            <p style="color: #0c4a6e; font-size: 0.9em; margin: 0 0 10px 0;">These transaction groups total $0 and don't impact your budget, so they don't need to be categorized (e.g., refunded purchases, reimbursed expenses).</p>
                            ${zeroGroups.map(group => `
                                <div style="background: white; border-radius: 4px; padding: 10px; margin-bottom: 8px;">
                                    <div style="font-weight: 500; color: #1e293b;">${this.escapeHtml(group.name)}${group.name.length >= 30 ? '...' : ''}</div>
                                    <div style="color: #64748b; font-size: 0.85em;">${group.transactions.length} transaction${group.transactions.length > 1 ? 's' : ''} ‚Ä¢ $0 net total</div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else {
                    zeroContainer.innerHTML = '';
                }
            }

            toggleBulkGroup(idx) {
                const groups = document.querySelectorAll('.bulk-group');
                groups.forEach((g, i) => {
                    if (i === idx) {
                        g.classList.toggle('expanded');
                    }
                });
            }

            bulkCategorize(groupIdx, category) {
                if (!this.bulkGroups || !this.bulkGroups[groupIdx]) return;

                const group = this.bulkGroups[groupIdx];

                // Save state for undo
                this.lastBulkAction = {
                    groupName: group.name,
                    transactionIds: group.transactions.map(t => t.id),
                    previousCategories: {}
                };

                group.transactions.forEach(t => {
                    const transaction = this.transactions.find(tr => tr.id === t.id);
                    if (transaction) {
                        // Store previous category for undo
                        this.lastBulkAction.previousCategories[t.id] = transaction.category;
                        transaction.category = category;
                        this.saveRule(transaction.description, category);
                    }
                });

                // Save to localStorage for session persistence
                StorageUtils.set('transactionData', this.transactions);

                this.updateDisplay();
                this.showUndoNotification(group.name, category, group.transactions.length);
            }

            showUndoNotification(groupName, category, count) {
                // Remove any existing undo notification
                const existing = document.querySelector('.undo-notification');
                if (existing) existing.remove();

                const notification = document.createElement('div');
                notification.className = 'undo-notification';
                notification.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #1e293b;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    z-index: 1000;
                    font-size: 0.95em;
                `;
                notification.innerHTML = `
                    <span>Categorized ${count} "${this.escapeHtml(groupName.substring(0, 20))}..." transactions as ${category}</span>
                    <button onclick="analyzer.undoLastBulkAction()" style="
                        background: #667eea;
                        color: white;
                        border: none;
                        padding: 6px 12px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: 600;
                    ">Undo</button>
                    <button onclick="this.parentElement.remove()" style="
                        background: transparent;
                        color: #94a3b8;
                        border: none;
                        padding: 4px;
                        cursor: pointer;
                        font-size: 1.2em;
                    ">√ó</button>
                `;
                document.body.appendChild(notification);

                // Auto-dismiss after 10 seconds
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 10000);
            }

            undoLastBulkAction() {
                if (!this.lastBulkAction) return;

                // Restore previous categories
                for (const [id, prevCategory] of Object.entries(this.lastBulkAction.previousCategories)) {
                    const transaction = this.transactions.find(t => t.id === id);
                    if (transaction) {
                        transaction.category = prevCategory;
                    }
                }

                // Save and update
                StorageUtils.set('transactionData', this.transactions);
                this.updateDisplay();

                // Remove notification
                const notification = document.querySelector('.undo-notification');
                if (notification) notification.remove();

                // Clear undo state
                this.lastBulkAction = null;
            }

            updateStats() {
                const dates = this.transactions.map(t => new Date(t.date)).filter(d => !isNaN(d));

                if (dates.length > 0) {
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    document.getElementById('dateRange').textContent =
                        `Showing transactions from ${minDate.toLocaleDateString()} to ${maxDate.toLocaleDateString()}`;
                } else {
                    document.getElementById('dateRange').textContent =
                        `Showing ${this.transactions.length} transactions`;
                }

                // Exclude inter-account transfers from income/spending calculations
                const nonTransferTransactions = this.transactions.filter(t => !t.isTransfer);

                const totalIncome = nonTransferTransactions
                    .filter(t => t.amount > 0)
                    .reduce((sum, t) => sum + t.amount, 0);

                const totalSpending = nonTransferTransactions
                    .filter(t => t.amount < 0)
                    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

                const net = totalIncome - totalSpending;

                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                const displayCount = nonTransferTransactions.length;

                const totalTransactionsEl = document.getElementById('totalTransactions');
                if (transferCount > 0) {
                    totalTransactionsEl.innerHTML = `${displayCount}<br><span style="font-size: 0.7em; color: #64748b; font-weight: normal;">(${transferCount} transfer${transferCount > 1 ? 's' : ''} excluded)</span>`;
                } else {
                    totalTransactionsEl.textContent = displayCount;
                }
                document.getElementById('totalIncome').textContent = this.formatCurrency(totalIncome);
                document.getElementById('totalSpending').textContent = this.formatCurrency(totalSpending);

                const netElement = document.getElementById('netAmount');
                netElement.textContent = this.formatCurrency(net);
                netElement.classList.remove('income', 'expense');
                netElement.classList.add(net >= 0 ? 'income' : 'expense');
            }

            updateSummaryCards() {
                const categories = this.calculateCategoryTotals();
                const totalSpending = Object.entries(categories)
                    .filter(([cat]) => cat !== 'income')
                    .reduce((sum, [, data]) => sum + data.total, 0);

                // Calculate months in data
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const cardsContainer = document.getElementById('summaryCards');
                cardsContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free Spending', targetKey: 'guiltFree' },
                    { key: 'uncategorized', name: 'Uncategorized', targetKey: null }
                ];

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0, count: 0 };
                    const monthlyAvg = data.total / months;
                    const percentage = totalSpending > 0 ? (data.total / totalSpending * 100) : 0;

                    let targetPct = cat.targetKey ? this.targets[cat.targetKey] : 0;
                    let targetAmount = this.targets.income * (targetPct / 100);
                    let diff = monthlyAvg - targetAmount;
                    let diffClass = 'neutral';
                    let diffText = '-';

                    if (cat.targetKey) {
                        if (cat.key === 'short-term' || cat.key === 'long-term') {
                            // For savings, under target is bad
                            diffClass = diff >= 0 ? 'under' : 'over';
                            diffText = diff >= 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        } else {
                            // For spending, over target is bad
                            diffClass = diff <= 0 ? 'under' : 'over';
                            diffText = diff > 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        }
                    }

                    const card = document.createElement('div');
                    card.className = `summary-card ${cat.key}`;
                    card.innerHTML = `
                        <div class="card-header">
                            <span class="card-title">${cat.name}</span>
                            <span class="card-percentage">${percentage.toFixed(1)}%</span>
                        </div>
                        <div class="card-amount">${this.formatCurrency(monthlyAvg)}/mo</div>
                        ${cat.targetKey ? `
                            <div class="card-comparison">
                                <span class="comparison-target">Target: ${this.formatCurrency(targetAmount)}/mo</span>
                                <span class="comparison-diff ${diffClass}">${diffText}</span>
                            </div>
                        ` : `
                            <div class="card-comparison">
                                <span class="comparison-target">${data.count} transactions</span>
                            </div>
                        `}
                    `;
                    cardsContainer.appendChild(card);
                });
            }

            updateComparisonChart() {
                const categories = this.calculateCategoryTotals();

                // Calculate months
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                // Calculate actual income from transactions
                const nonTransferTransactions = this.transactions.filter(t => !t.isTransfer);
                const totalActualIncome = nonTransferTransactions
                    .filter(t => t.amount > 0)
                    .reduce((sum, t) => sum + t.amount, 0);
                const monthlyActualIncome = totalActualIncome / months;

                // Calculate total spending
                const totalSpending = nonTransferTransactions
                    .filter(t => t.amount < 0)
                    .reduce((sum, t) => sum + Math.abs(t.amount), 0);
                const monthlySpending = totalSpending / months;

                const plannedIncome = this.targets.income;
                const maxValue = Math.max(plannedIncome, monthlyActualIncome);

                const chartContainer = document.getElementById('comparisonChart');
                chartContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free', targetKey: 'guiltFree' }
                ];

                // Add income comparison header
                const incomeHeader = document.createElement('div');
                incomeHeader.className = 'income-comparison-header';
                const incomeDiff = monthlyActualIncome - plannedIncome;
                const incomeDiffPct = plannedIncome > 0 ? ((incomeDiff / plannedIncome) * 100).toFixed(0) : 0;
                const incomeMatch = Math.abs(incomeDiff) < plannedIncome * 0.05; // Within 5%
                incomeHeader.innerHTML = `
                    <div class="income-comparison">
                        <span class="income-label">Planned Income:</span>
                        <span class="income-value">${this.formatCurrency(plannedIncome)}/mo</span>
                        <span class="income-separator">|</span>
                        <span class="income-label">Actual Income:</span>
                        <span class="income-value">${this.formatCurrency(monthlyActualIncome)}/mo</span>
                        ${!incomeMatch ? `<span class="income-diff ${incomeDiff > 0 ? 'positive' : 'negative'}">(${incomeDiff > 0 ? '+' : ''}${incomeDiffPct}%)</span>` : ''}
                    </div>
                    ${!incomeMatch ? `<div class="income-note">Actual percentages below use your actual income for accuracy.</div>` : ''}
                `;
                chartContainer.appendChild(incomeHeader);

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0 };
                    const monthlyActual = data.total / months;
                    const targetPct = this.targets[cat.targetKey];
                    const targetAmount = plannedIncome * (targetPct / 100);

                    // Use actual income for actual percentage calculation
                    const actualPct = monthlyActualIncome > 0 ? (monthlyActual / monthlyActualIncome * 100) : 0;

                    const targetWidth = Math.min(100, (targetAmount / maxValue) * 100);
                    const actualWidth = Math.min(100, (monthlyActual / maxValue) * 100);

                    const row = document.createElement('div');
                    row.className = 'comparison-row';
                    row.innerHTML = `
                        <div class="comparison-label">${cat.name}</div>
                        <div class="comparison-bar-container">
                            <div class="comparison-bar target" style="width: ${targetWidth}%"></div>
                            <div class="comparison-bar actual ${cat.key}" style="width: ${actualWidth}%"></div>
                        </div>
                        <div class="comparison-value">
                            <div style="font-size: 0.8em; color: #999;">Target: ${targetPct}%</div>
                            <div>Actual: ${actualPct.toFixed(1)}%</div>
                        </div>
                    `;
                    chartContainer.appendChild(row);
                });

                // Calculate and display savings rate (short-term + long-term savings)
                const shortTermSavings = (categories['short-term']?.total || 0) / months;
                const longTermSavings = (categories['long-term']?.total || 0) / months;
                const totalMonthlySavings = shortTermSavings + longTermSavings;
                const savingsRate = monthlyActualIncome > 0 ? (totalMonthlySavings / monthlyActualIncome * 100) : 0;
                const targetSavingsRate = this.targets.shortTerm + this.targets.longTerm;

                const savingsRow = document.createElement('div');
                savingsRow.className = 'savings-rate-row';
                savingsRow.innerHTML = `
                    <div class="savings-rate">
                        <span class="savings-label">Savings Rate:</span>
                        <span class="savings-value ${savingsRate >= targetSavingsRate ? 'positive' : 'negative'}">${savingsRate.toFixed(1)}%</span>
                        <span class="savings-target">(Target: ${targetSavingsRate}%)</span>
                    </div>
                `;
                chartContainer.appendChild(savingsRow);

                // Add legend
                const legend = document.createElement('div');
                legend.style.cssText = 'display: flex; gap: 20px; justify-content: center; margin-top: 20px; font-size: 0.9em;';
                legend.innerHTML = `
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #e0e0e0; border-radius: 2px; margin-right: 5px;"></span> Target</div>
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #667eea; border-radius: 2px; margin-right: 5px;"></span> Actual</div>
                `;
                chartContainer.appendChild(legend);
            }

            calculateCategoryTotals() {
                const totals = {};

                // Exclude inter-account transfers from category totals
                this.transactions
                    .filter(t => !t.isTransfer)
                    .forEach(t => {
                        const cat = t.category || 'uncategorized';
                        if (!totals[cat]) {
                            totals[cat] = { total: 0, count: 0 };
                        }
                        totals[cat].total += Math.abs(t.amount);
                        totals[cat].count++;
                    });

                return totals;
            }

            renderTransactions() {
                const categoryFilter = document.getElementById('categoryFilter').value;
                const sortOrder = document.getElementById('sortOrder').value;

                let filtered = [...this.transactions];

                // Apply category filter
                if (categoryFilter === 'transfers') {
                    filtered = filtered.filter(t => t.isTransfer);
                } else if (categoryFilter !== 'all') {
                    filtered = filtered.filter(t => t.category === categoryFilter && !t.isTransfer);
                } else {
                    // For 'all', exclude transfers by default unless specifically viewing them
                    filtered = filtered.filter(t => !t.isTransfer);
                }

                // Apply sort
                switch (sortOrder) {
                    case 'date-desc':
                        filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
                        break;
                    case 'date-asc':
                        filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
                        break;
                    case 'amount-desc':
                        filtered.sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));
                        break;
                    case 'amount-asc':
                        filtered.sort((a, b) => Math.abs(a.amount) - Math.abs(b.amount));
                        break;
                }

                // Render desktop table
                const tbody = document.getElementById('transactionsBody');
                tbody.innerHTML = '';

                // Render mobile cards with pagination
                const cardsContainer = document.getElementById('transactionCards');
                cardsContainer.innerHTML = '';

                // Mobile pagination settings
                const ITEMS_PER_PAGE = 20;
                this.currentMobilePage = this.currentMobilePage || 1;
                const totalPages = Math.ceil(filtered.length / ITEMS_PER_PAGE);
                const startIdx = (this.currentMobilePage - 1) * ITEMS_PER_PAGE;
                const endIdx = Math.min(startIdx + ITEMS_PER_PAGE, filtered.length);
                const paginatedMobile = filtered.slice(startIdx, endIdx);

                filtered.forEach((t, index) => {
                    const showOnMobile = index >= startIdx && index < endIdx;
                    const isExpense = t.amount < 0;
                    const transferBadge = t.isTransfer ? '<span style="background: #6b7280; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; margin-left: 8px;">TRANSFER</span>' : '';
                    const categoryOptions = `
                        <option value="fixed-costs" ${t.category === 'fixed-costs' ? 'selected' : ''}>Fixed Costs</option>
                        <option value="short-term" ${t.category === 'short-term' ? 'selected' : ''}>Short-Term Savings</option>
                        <option value="long-term" ${t.category === 'long-term' ? 'selected' : ''}>Long-Term Savings</option>
                        <option value="guilt-free" ${t.category === 'guilt-free' ? 'selected' : ''}>Guilt-Free</option>
                        <option value="income" ${t.category === 'income' ? 'selected' : ''}>Income</option>
                        <option value="uncategorized" ${t.category === 'uncategorized' ? 'selected' : ''}>Uncategorized</option>
                    `;

                    // Transfer override button
                    const transferOverride = t.isTransfer ? `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="color: #6b7280; font-style: italic;">Transfer</span>
                            <button onclick="analyzer.unmarkTransfer('${t.id}')"
                                style="background: #fef3c7; color: #92400e; border: 1px solid #fcd34d; border-radius: 4px; padding: 2px 8px; font-size: 0.8em; cursor: pointer;"
                                title="This was incorrectly detected as a transfer. Click to categorize it.">
                                Not a transfer
                            </button>
                        </div>` : '';

                    // Desktop table row
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${new Date(t.date).toLocaleDateString()}</td>
                        <td>${this.escapeHtml(t.description)}${transferBadge}</td>
                        <td class="amount-cell ${isExpense ? 'expense' : 'income'}">
                            ${isExpense ? '-' : '+'}${this.formatCurrency(Math.abs(t.amount))}
                        </td>
                        <td>
                            ${t.isTransfer ? transferOverride : `
                            <select class="category-select" data-id="${this.escapeHtml(t.id)}" onchange="analyzer.updateCategory(this)">
                                ${categoryOptions}
                            </select>
                            `}
                        </td>
                    `;
                    tbody.appendChild(row);

                    // Mobile card (only for current page)
                    if (showOnMobile) {
                        const card = document.createElement('div');
                        card.className = 'transaction-card';
                        card.innerHTML = `
                            <div class="transaction-card-header">
                                <span class="transaction-card-desc">${this.escapeHtml(t.description)}${transferBadge}</span>
                                <span class="transaction-card-amount ${isExpense ? 'expense' : 'income'}">
                                    ${isExpense ? '-' : '+'}${this.formatCurrency(Math.abs(t.amount))}
                                </span>
                            </div>
                            <div class="transaction-card-footer">
                                <span class="transaction-card-date">${new Date(t.date).toLocaleDateString()}</span>
                                <div class="transaction-card-category">
                                    ${t.isTransfer ? transferOverride : `
                                    <select data-id="${this.escapeHtml(t.id)}" onchange="analyzer.updateCategory(this)">
                                        ${categoryOptions}
                                    </select>
                                    `}
                                </div>
                            </div>
                        `;
                        cardsContainer.appendChild(card);
                    }
                });

                // Add mobile pagination controls
                if (filtered.length > ITEMS_PER_PAGE) {
                    const paginationDiv = document.createElement('div');
                    paginationDiv.className = 'mobile-pagination';
                    paginationDiv.style.cssText = `
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        gap: 10px;
                        padding: 15px;
                        margin-top: 10px;
                    `;
                    paginationDiv.innerHTML = `
                        <button onclick="analyzer.changeMobilePage(-1)" ${this.currentMobilePage <= 1 ? 'disabled' : ''}
                            style="padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: ${this.currentMobilePage <= 1 ? '#f5f5f5' : 'white'}; cursor: ${this.currentMobilePage <= 1 ? 'not-allowed' : 'pointer'};">
                            ‚Üê Prev
                        </button>
                        <span style="color: #666;">Page ${this.currentMobilePage} of ${totalPages}</span>
                        <button onclick="analyzer.changeMobilePage(1)" ${this.currentMobilePage >= totalPages ? 'disabled' : ''}
                            style="padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: ${this.currentMobilePage >= totalPages ? '#f5f5f5' : 'white'}; cursor: ${this.currentMobilePage >= totalPages ? 'not-allowed' : 'pointer'};">
                            Next ‚Üí
                        </button>
                    `;
                    cardsContainer.appendChild(paginationDiv);
                }
            }

            changeMobilePage(delta) {
                this.currentMobilePage = Math.max(1, this.currentMobilePage + delta);
                this.renderTransactions();
            }

            updateCategory(select) {
                const id = select.dataset.id;
                const newCategory = select.value;

                const transaction = this.transactions.find(t => t.id === id);
                if (transaction) {
                    transaction.category = newCategory;

                    // Save the rule for this merchant
                    this.saveRule(transaction.description, newCategory);

                    // Save to localStorage for session persistence
                    StorageUtils.set('transactionData', this.transactions);

                    // Update display
                    this.updateStats();
                    this.updateSummaryCards();
                    this.updateComparisonChart();
                }
            }

            unmarkTransfer(id) {
                const transaction = this.transactions.find(t => t.id === id);
                if (transaction) {
                    // Unmark this transaction and its matched pair
                    transaction.isTransfer = false;
                    transaction.manuallyUnmarkedTransfer = true; // Prevent re-detection
                    transaction.category = this.categorizeTransaction(transaction);

                    // Also unmark the matched transfer if it exists
                    if (transaction.transferMatch) {
                        const matchedTx = this.transactions.find(t => t.id === transaction.transferMatch);
                        if (matchedTx) {
                            matchedTx.isTransfer = false;
                            matchedTx.manuallyUnmarkedTransfer = true;
                            matchedTx.category = this.categorizeTransaction(matchedTx);
                            delete matchedTx.transferMatch;
                        }
                        delete transaction.transferMatch;
                    }

                    // Save and update display
                    StorageUtils.set('transactionData', this.transactions);
                    this.updateDisplay();
                }
            }

            saveRule(description, category) {
                // Extract merchant name (first few words, cleaned up)
                const merchantPattern = description
                    .replace(/[0-9#*]+/g, '')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .split(' ')
                    .slice(0, 3)
                    .join(' ')
                    .toLowerCase();

                if (merchantPattern.length < 3) return;

                // Save to localStorage
                const rules = StorageUtils.get('transactionRules', {});
                rules[merchantPattern] = category;
                StorageUtils.set('transactionRules', rules);
            }

            loadSavedRules() {
                const rules = StorageUtils.get('transactionRules', {});

                // Add saved rules to category patterns
                for (const [pattern, category] of Object.entries(rules)) {
                    if (this.categoryPatterns[category]) {
                        const regex = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                        this.categoryPatterns[category].unshift(regex);
                    }
                }
            }

            exportSummary() {
                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                let summary = `Transaction Analysis Summary\n`;
                summary += `============================\n\n`;
                summary += `Date Range: ${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}\n`;
                summary += `Total Transactions: ${this.transactions.length}\n\n`;

                summary += `Monthly Spending by Category:\n`;
                summary += `-----------------------------\n`;

                const categoryNames = {
                    'fixed-costs': 'Fixed Costs',
                    'short-term': 'Short-Term Savings',
                    'long-term': 'Long-Term Savings',
                    'guilt-free': 'Guilt-Free Spending',
                    'income': 'Income',
                    'uncategorized': 'Uncategorized'
                };

                for (const [key, name] of Object.entries(categoryNames)) {
                    const data = categories[key] || { total: 0, count: 0 };
                    const monthly = data.total / months;
                    summary += `${name}: ${this.formatCurrency(monthly)}/month (${data.count} transactions)\n`;
                }

                DOMUtils.downloadFile(summary, 'spending-summary.txt');
            }

            updateBudgetPlan() {
                if (this.transactions.length === 0) {
                    window.location.href = 'income-allocation.html';
                    return;
                }

                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                // Calculate actual monthly income from transactions
                const nonTransferTransactions = this.transactions.filter(t => !t.isTransfer);
                const totalActualIncome = nonTransferTransactions
                    .filter(t => t.amount > 0)
                    .reduce((sum, t) => sum + t.amount, 0);
                const monthlyActualIncome = totalActualIncome / months;

                // Calculate actual percentages based on actual income
                const fixedCosts = (categories['fixed-costs']?.total || 0) / months;
                const shortTerm = (categories['short-term']?.total || 0) / months;
                const longTerm = (categories['long-term']?.total || 0) / months;
                const guiltFree = (categories['guilt-free']?.total || 0) / months;

                const fixedPct = monthlyActualIncome > 0 ? (fixedCosts / monthlyActualIncome * 100) : 0;
                const shortPct = monthlyActualIncome > 0 ? (shortTerm / monthlyActualIncome * 100) : 0;
                const longPct = monthlyActualIncome > 0 ? (longTerm / monthlyActualIncome * 100) : 0;
                const guiltFreePct = monthlyActualIncome > 0 ? (guiltFree / monthlyActualIncome * 100) : 0;

                // Build URL with actual spending data
                const params = new URLSearchParams({
                    income: Math.round(monthlyActualIncome),
                    fixed: fixedPct.toFixed(1),
                    short: shortPct.toFixed(1),
                    long: longPct.toFixed(1),
                    guilt: guiltFreePct.toFixed(1),
                    source: 'spending-tracker'
                });

                window.location.href = `income-allocation.html?${params.toString()}`;
            }

            formatCurrency(value) {
                return FinanceUtils.formatCurrency(value);
            }

            parseCurrencyValue(value) {
                // Remove all non-numeric characters except decimal point
                const cleaned = String(value).replace(/[^0-9.]/g, '');
                return parseFloat(cleaned) || 0;
            }

            formatCurrencyInput(value) {
                // Format as currency with commas and 2 decimal places
                return '$' + value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            }

            escapeHtml(text) {
                return DOMUtils.escapeHtml(text);
            }

            // AI Categorization Methods
            toggleApiKeyVisibility() {
                const input = document.getElementById('apiKey');
                const btn = event.target;
                if (input.type === 'password') {
                    input.type = 'text';
                    btn.textContent = 'Hide';
                } else {
                    input.type = 'password';
                    btn.textContent = 'Show';
                }
            }

            getCategorizationPrompt(transactionList, includeVerification = false) {
                const verificationNote = includeVerification ?
                    `\nSome transactions have a "suggestedCategory" - verify if this is correct or provide a better category.\n` : '';

                return `You are a financial transaction categorizer. Categorize each transaction into exactly one of these categories:

- fixed-costs: Essential expenses (rent, mortgage, utilities, insurance, groceries, gas, pharmacy, childcare, minimum debt payments)
- short-term: Transfers to savings accounts, emergency fund deposits
- long-term: Retirement contributions (401k, IRA), investment transfers, brokerage deposits
- guilt-free: Discretionary spending (restaurants, entertainment, shopping, subscriptions, travel, hobbies)
- income: Salary, refunds, reimbursements, interest earned
${verificationNote}
Here are the transactions to categorize (negative amounts are expenses, positive are income):

${JSON.stringify(transactionList, null, 2)}

Respond with ONLY a JSON array in this exact format, no other text:
[{"id": "transaction-id-here", "category": "category-name-here"}, ...]`;
            }

            async aiCategorize() {
                const apiKey = document.getElementById('apiKey').value.trim();
                const provider = document.getElementById('aiProvider').value;

                if (!apiKey) {
                    this.showAiStatus('Please enter your API key', 'error');
                    return;
                }

                // Get uncategorized transactions
                const uncategorized = this.transactions.filter(t => t.category === 'uncategorized' && !t.isTransfer);

                // Also get low-confidence categorizations for AI verification
                const lowConfidence = this.transactions.filter(t => {
                    if (t.category === 'uncategorized' || t.isTransfer) return false;
                    const result = this.categorizeWithConfidence(t);
                    return result.confidence === 'low';
                });

                const totalToProcess = uncategorized.length + lowConfidence.length;

                if (totalToProcess === 0) {
                    this.showAiStatus('No transactions need AI categorization!', 'success');
                    return;
                }

                const statusParts = [];
                if (uncategorized.length > 0) statusParts.push(`${uncategorized.length} uncategorized`);
                if (lowConfidence.length > 0) statusParts.push(`${lowConfidence.length} to verify`);
                this.showAiStatus(`Processing ${statusParts.join(' + ')} transactions with AI (${provider})...`, 'processing');
                document.getElementById('aiCategorizeBtn').disabled = true;

                let successCount = 0;
                let verifiedCount = 0;
                let lastError = '';

                try {
                    // Group similar descriptions to reduce API calls
                    const { grouped, mapping } = this.groupSimilarTransactions([...uncategorized, ...lowConfidence]);
                    const uniqueDescriptions = Object.keys(grouped);

                    console.log(`Optimized: ${totalToProcess} transactions grouped into ${uniqueDescriptions.length} unique descriptions`);

                    // Process grouped transactions in batches
                    const batchSize = 40;
                    const failedGroups = [];

                    for (let i = 0; i < uniqueDescriptions.length; i += batchSize) {
                        const batchDescs = uniqueDescriptions.slice(i, i + batchSize);
                        const batchEnd = Math.min(i + batchSize, uniqueDescriptions.length);
                        this.showAiStatus(`Processing groups ${i + 1}-${batchEnd} of ${uniqueDescriptions.length} with AI...`, 'processing');

                        // Build batch with representative transactions
                        const batch = batchDescs.map(desc => {
                            const representative = grouped[desc][0];
                            const isVerification = lowConfidence.includes(representative);
                            return {
                                ...representative,
                                suggestedCategory: isVerification ? representative.category : undefined,
                                _groupKey: desc
                            };
                        });

                        try {
                            const hasVerification = batch.some(t => t.suggestedCategory);
                            const categorizations = await this.callAI(provider, apiKey, batch, hasVerification);

                            // Apply categorizations to all transactions in each group
                            categorizations.forEach(result => {
                                const groupKey = batch.find(t => t.id === result.id)?._groupKey;
                                if (!groupKey || !result.category || !this.isValidCategory(result.category)) return;

                                // Apply to all transactions with this description
                                grouped[groupKey].forEach(t => {
                                    const transaction = this.transactions.find(tx => tx.id === t.id);
                                    if (transaction) {
                                        const wasLowConfidence = lowConfidence.includes(t);
                                        const wasUncategorized = uncategorized.includes(t);
                                        transaction.category = result.category;
                                        if (wasUncategorized) successCount++;
                                        else if (wasLowConfidence) verifiedCount++;
                                    }
                                });

                                // Save rule for the description pattern
                                this.saveRule(groupKey, result.category);
                            });

                            this.updateDisplay();
                        } catch (batchError) {
                            lastError = batchError.message;
                            console.error(`Batch error:`, batchError);
                            failedGroups.push(...batchDescs);
                        }

                        // Brief delay between batches to avoid rate limits
                        if (i + batchSize < uniqueDescriptions.length) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }

                    // One retry pass for any failures
                    if (failedGroups.length > 0 && failedGroups.length < uniqueDescriptions.length) {
                        this.showAiStatus(`Retrying ${failedGroups.length} failed groups with AI...`, 'processing');
                        await new Promise(resolve => setTimeout(resolve, 1000));

                        const retryBatch = failedGroups.map(desc => grouped[desc][0]);

                        try {
                            const categorizations = await this.callAI(provider, apiKey, retryBatch, false);
                            categorizations.forEach(result => {
                                const groupKey = retryBatch.find(t => t.id === result.id)?.description;
                                if (!groupKey || !result.category || !this.isValidCategory(result.category)) return;

                                grouped[groupKey]?.forEach(t => {
                                    const transaction = this.transactions.find(tx => tx.id === t.id);
                                    if (transaction) {
                                        transaction.category = result.category;
                                        successCount++;
                                    }
                                });
                                this.saveRule(groupKey, result.category);
                            });
                            this.updateDisplay();
                        } catch (retryError) {
                            lastError = retryError.message;
                        }
                    }

                    // Build status message
                    const remaining = this.transactions.filter(t => t.category === 'uncategorized').length;
                    const statusMsg = [];
                    if (successCount > 0) statusMsg.push(`${successCount} categorized`);
                    if (verifiedCount > 0) statusMsg.push(`${verifiedCount} verified`);

                    if (statusMsg.length > 0) {
                        if (remaining > 0) {
                            this.showAiStatus(`${statusMsg.join(', ')}. ${remaining} still uncategorized - click again to retry.`, 'success');
                        } else {
                            this.showAiStatus(`Successfully processed: ${statusMsg.join(', ')}!`, 'success');
                        }
                    } else {
                        this.showAiStatus(`Failed: ${lastError}`, 'error');
                    }
                } catch (error) {
                    console.error('AI categorization error:', error);
                    const partial = successCount + verifiedCount;
                    if (partial > 0) {
                        this.showAiStatus(`Partially completed: ${partial} processed. Error: ${error.message}`, 'error');
                    } else {
                        this.showAiStatus(`Error: ${error.message}`, 'error');
                    }
                } finally {
                    document.getElementById('aiCategorizeBtn').disabled = false;
                    // Save to localStorage for session persistence
                    if (this.transactions.length > 0) {
                        StorageUtils.set('transactionData', this.transactions);
                    }
                }
            }

            // Group transactions by similar descriptions to reduce API calls
            groupSimilarTransactions(transactions) {
                const grouped = {};
                const mapping = {};

                transactions.forEach(t => {
                    // Normalize description for grouping (remove varying numbers, dates)
                    const normalized = t.description
                        .toLowerCase()
                        .replace(/\d{4,}/g, 'XXXX')  // Replace long numbers (card numbers, etc)
                        .replace(/\d{1,2}\/\d{1,2}/g, 'XX/XX')  // Replace dates
                        .replace(/\s+/g, ' ')
                        .trim();

                    // Use original description as key for better rule matching
                    const key = t.description;

                    if (!grouped[key]) {
                        grouped[key] = [];
                    }
                    grouped[key].push(t);
                    mapping[t.id] = key;
                });

                return { grouped, mapping };
            }

            isValidCategory(category) {
                const validCategories = ['fixed-costs', 'short-term', 'long-term', 'guilt-free', 'income'];
                return validCategories.includes(category);
            }

            async callAI(provider, apiKey, transactions, includeVerification = false) {
                const transactionList = transactions.map(t => {
                    const item = {
                        id: t.id,
                        date: t.date,  // Include date for context
                        description: t.description,
                        amount: t.amount
                    };
                    // Include suggested category for verification
                    if (t.suggestedCategory) {
                        item.suggestedCategory = t.suggestedCategory;
                    }
                    return item;
                });

                const prompt = this.getCategorizationPrompt(transactionList, includeVerification);

                switch (provider) {
                    case 'openai':
                        return await this.callOpenAI(apiKey, prompt);
                    case 'gemini':
                        return await this.callGemini(apiKey, prompt);
                    case 'anthropic':
                        return await this.callAnthropic(apiKey, prompt);
                    default:
                        throw new Error('Unknown AI provider');
                }
            }

            async callOpenAI(apiKey, prompt) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [{ role: 'user', content: prompt }],
                            max_tokens: 4096,
                            temperature: 0
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.choices[0].message.content;
                    return this.parseAIResponse(content);
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        throw new Error('OpenAI blocked by browser (CORS). Try Google Gemini instead.');
                    }
                    throw error;
                }
            }

            async callGemini(apiKey, prompt) {
                // Try models from newest to oldest - cache working model for speed
                const models = [
                    'gemini-2.5-flash',      // Stable 2.5 (fast)
                    'gemini-2.0-flash',      // Stable 2.0
                    'gemini-2.0-flash-001',  // Specific version fallback
                ];

                // Use cached model if we found one that works
                const cachedModel = this.workingGeminiModel;
                const modelsToTry = cachedModel ? [cachedModel, ...models.filter(m => m !== cachedModel)] : models;

                let lastError = null;

                for (const model of modelsToTry) {
                    try {
                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0,
                                    maxOutputTokens: 8192
                                }
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            const errorMsg = errorData.error?.message || `Gemini API error: ${response.status}`;

                            // If model not found, try next model
                            if (errorMsg.includes('not found') || errorMsg.includes('not supported')) {
                                console.log(`Model ${model} not available, trying next...`);
                                lastError = new Error(errorMsg);
                                continue;
                            }

                            if (response.status === 400 && errorMsg.includes('API key')) {
                                throw new Error('Invalid Gemini API key. Get one at aistudio.google.com/apikey');
                            }
                            throw new Error(errorMsg);
                        }

                        const data = await response.json();
                        if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]?.text) {
                            console.log(`Model ${model} returned unexpected format, trying next...`);
                            lastError = new Error('Unexpected response format from Gemini');
                            continue;
                        }

                        // Cache the working model for future calls
                        this.workingGeminiModel = model;
                        console.log(`Successfully used Gemini model: ${model}`);
                        const content = data.candidates[0].content.parts[0].text;
                        return this.parseAIResponse(content);
                    } catch (error) {
                        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                            throw new Error('Network error connecting to Gemini. Check your internet connection.');
                        }
                        // If it's an API key error, don't try other models
                        if (error.message.includes('API key')) {
                            throw error;
                        }
                        lastError = error;
                        console.log(`Model ${model} failed: ${error.message}`);
                    }
                }

                // All models failed
                throw lastError || new Error('All Gemini models failed. Try a different provider.');
            }

            async callAnthropic(apiKey, prompt) {
                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-haiku-20240307',
                            max_tokens: 4096,
                            messages: [{ role: 'user', content: prompt }]
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `Anthropic API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.content[0].text;
                    return this.parseAIResponse(content);
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        throw new Error('Anthropic blocked by browser (CORS). Try Google Gemini instead.');
                    }
                    throw error;
                }
            }

            parseAIResponse(content) {
                try {
                    // Extract JSON from response (in case there's extra text)
                    const jsonMatch = content.match(/\[[\s\S]*?\]/);
                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[0]);
                    }
                    throw new Error('No valid JSON array found in response');
                } catch (parseError) {
                    console.error('Failed to parse AI response:', content);
                    throw new Error('Failed to parse AI response');
                }
            }

            showAiStatus(message, type) {
                const status = document.getElementById('aiStatus');
                status.textContent = message;
                status.className = `ai-status show ${type}`;
            }
        }

        // Initialize
        let analyzer;
        DOMUtils.ready(() => {
            analyzer = new TransactionAnalyzer();

            // Load data from Budget Planner if available
            const budgetData = StorageUtils.get('budgetPlannerData');
            if (budgetData) {
                // Update income field
                const incomeInput = document.getElementById('monthlyIncome');
                if (budgetData.monthlyIncome) {
                    incomeInput.value = analyzer.formatCurrencyInput(budgetData.monthlyIncome);
                    analyzer.targets.income = budgetData.monthlyIncome;
                }
                // Update allocation percentages (round to 1 decimal place)
                if (budgetData.fixedCosts !== undefined) {
                    const rounded = parseFloat(budgetData.fixedCosts.toFixed(1));
                    document.getElementById('targetFixed').value = rounded;
                    analyzer.targets.fixedCosts = rounded;
                }
                if (budgetData.shortTerm !== undefined) {
                    const rounded = parseFloat(budgetData.shortTerm.toFixed(1));
                    document.getElementById('targetShortTerm').value = rounded;
                    analyzer.targets.shortTerm = rounded;
                }
                if (budgetData.longTerm !== undefined) {
                    const rounded = parseFloat(budgetData.longTerm.toFixed(1));
                    document.getElementById('targetLongTerm').value = rounded;
                    analyzer.targets.longTerm = rounded;
                }
                if (budgetData.guiltFree !== undefined) {
                    const rounded = parseFloat(budgetData.guiltFree.toFixed(1));
                    document.getElementById('targetGuiltFree').value = rounded;
                    analyzer.targets.guiltFree = rounded;
                }
            }

            const apiKeyInput = document.getElementById('apiKey');
            const providerSelect = document.getElementById('aiProvider');
            const aiCategorizeBtn = document.getElementById('aiCategorizeBtn');

            // Enable AI button when API key is entered
            apiKeyInput.addEventListener('input', (e) => {
                aiCategorizeBtn.disabled = !e.target.value.trim();
            });

            // Load saved provider and API key from localStorage
            const savedProvider = StorageUtils.get('aiProvider', 'gemini');
            providerSelect.value = savedProvider;

            const savedKey = StorageUtils.get(`apiKey_${savedProvider}`);
            if (savedKey) {
                apiKeyInput.value = savedKey;
                aiCategorizeBtn.disabled = false;
            }

            // Update placeholder and load key when provider changes
            providerSelect.addEventListener('change', (e) => {
                const provider = e.target.value;
                StorageUtils.set('aiProvider', provider);

                // Update placeholder
                const placeholders = {
                    'openai': 'sk-...',
                    'gemini': 'AIza...',
                    'anthropic': 'sk-ant-api...'
                };
                apiKeyInput.placeholder = placeholders[provider] || 'Enter API key...';

                // Load saved key for this provider
                const savedProviderKey = StorageUtils.get(`apiKey_${provider}`);
                apiKeyInput.value = savedProviderKey || '';
                aiCategorizeBtn.disabled = !savedProviderKey;
            });

            // Trigger initial placeholder update
            providerSelect.dispatchEvent(new Event('change'));

            // Save API key when changed (per provider)
            apiKeyInput.addEventListener('change', (e) => {
                if (e.target.value.trim()) {
                    const provider = providerSelect.value;
                    StorageUtils.set(`apiKey_${provider}`, e.target.value.trim());
                }
            });

            // Transfers section toggle
            document.getElementById('toggleTransfers').addEventListener('click', () => {
                const panel = document.getElementById('transfersPanel');
                const btn = document.getElementById('toggleTransfers');
                const arrow = btn.querySelector('.arrow');
                const isOpen = panel.style.display !== 'none';
                panel.style.display = isOpen ? 'none' : 'block';
                arrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
            });

            // Load saved transactions if available
            const savedTransactions = StorageUtils.get('transactionData', []);
            if (Array.isArray(savedTransactions) && savedTransactions.length > 0) {
                analyzer.transactions = savedTransactions;
                analyzer.updateDisplay();
                document.getElementById('resultsSection').classList.remove('results-hidden');
            }

            // Initialize session toolbar
            SessionManager.initToolbar(
                // Get current page data for export
                () => {
                    // Save current transactions to localStorage
                    if (analyzer.transactions.length > 0) {
                        StorageUtils.set('transactionData', analyzer.transactions);
                    }

                    return {
                        transactions: analyzer.transactions,
                        bankFormat: analyzer.selectedFormat,
                        targets: analyzer.targets
                    };
                },
                // Handle import
                (result) => {
                    // Reload budget data to update targets (must happen before updateDisplay)
                    const budgetData = StorageUtils.get('budgetPlannerData');
                    if (budgetData) {
                        // Update income
                        if (budgetData.monthlyIncome) {
                            analyzer.targets.income = budgetData.monthlyIncome;
                            document.getElementById('monthlyIncome').value = analyzer.formatCurrencyInput(budgetData.monthlyIncome);
                        }
                        // Update allocation percentages
                        if (budgetData.fixedCosts !== undefined) {
                            const rounded = parseFloat(budgetData.fixedCosts.toFixed(1));
                            analyzer.targets.fixedCosts = rounded;
                            document.getElementById('targetFixed').value = rounded;
                        }
                        if (budgetData.shortTerm !== undefined) {
                            const rounded = parseFloat(budgetData.shortTerm.toFixed(1));
                            analyzer.targets.shortTerm = rounded;
                            document.getElementById('targetShortTerm').value = rounded;
                        }
                        if (budgetData.longTerm !== undefined) {
                            const rounded = parseFloat(budgetData.longTerm.toFixed(1));
                            analyzer.targets.longTerm = rounded;
                            document.getElementById('targetLongTerm').value = rounded;
                        }
                        if (budgetData.guiltFree !== undefined) {
                            const rounded = parseFloat(budgetData.guiltFree.toFixed(1));
                            analyzer.targets.guiltFree = rounded;
                            document.getElementById('targetGuiltFree').value = rounded;
                        }
                    }

                    // Check if we have transaction data in the imported session
                    const transactionData = StorageUtils.get('transactionData', []);
                    if (Array.isArray(transactionData) && transactionData.length > 0) {
                        analyzer.transactions = transactionData;
                        analyzer.updateDisplay();
                        document.getElementById('resultsSection').classList.remove('results-hidden');
                        SessionManager.showToast('Session restored!', 'success');
                    } else if (budgetData) {
                        // Even without transactions, show updated targets
                        SessionManager.showToast('Budget settings restored!', 'success');
                    } else {
                        window.location.reload();
                    }
                }
            );
        });
    </script>
</body>
</html>
