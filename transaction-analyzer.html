<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Transaction Analyzer - See Your Spending Reality</title>
    <script src="shared.js?v=20251229"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f5f7fa;
            border-radius: 8px;
        }

        .section h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        .section h3 {
            margin-bottom: 10px;
            color: #555;
            font-size: 1.1em;
        }

        /* Upload Section */
        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: white;
        }

        .upload-area:hover {
            background: #f0f4ff;
            border-color: #5568d3;
        }

        .upload-area.dragover {
            background: #e8edff;
            border-color: #4455c7;
        }

        .upload-area input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 5px;
        }

        .upload-hint {
            font-size: 0.9em;
            color: #999;
        }

        /* Bank Format Selection */
        .format-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .format-option {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s;
        }

        .format-option:hover {
            border-color: #667eea;
        }

        .format-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* Targets Section */
        .targets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .target-input {
            display: flex;
            flex-direction: column;
        }

        .target-input label {
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .target-input input {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
        }

        .target-input input:focus {
            outline: none;
            border-color: #667eea;
        }

        .target-input select {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .target-input select:focus {
            outline: none;
            border-color: #667eea;
        }

        .target-input select:hover {
            border-color: #bbb;
        }

        /* Results Section */
        .results-hidden {
            display: none;
        }

        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .summary-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border-left: 4px solid;
        }

        .summary-card.fixed-costs { border-left-color: #ef4444; }
        .summary-card.short-term { border-left-color: #f59e0b; }
        .summary-card.long-term { border-left-color: #10b981; }
        .summary-card.guilt-free { border-left-color: #8b5cf6; }
        .summary-card.uncategorized { border-left-color: #6b7280; }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .card-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .card-percentage {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .card-amount {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .card-comparison {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }

        .comparison-target {
            color: #666;
        }

        .comparison-diff {
            font-weight: 600;
        }

        .comparison-diff.over { color: #ef4444; }
        .comparison-diff.under { color: #10b981; }
        .comparison-diff.neutral { color: #6b7280; }

        /* Progress Bar */
        .progress-container {
            margin-top: 10px;
        }

        .progress-bar {
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s;
        }

        .progress-target {
            position: absolute;
            top: -4px;
            width: 2px;
            height: 16px;
            background: #333;
        }

        /* Transactions Table */
        .transactions-container {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .transactions-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-title {
            font-weight: 600;
            font-size: 1.1em;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
        }

        .filter-select {
            padding: 8px 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
        }

        .transactions-table {
            width: 100%;
            border-collapse: collapse;
        }

        .transactions-table th,
        .transactions-table td {
            padding: 12px 20px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }

        .transactions-table th {
            background: #f9fafb;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .transactions-table tr:hover {
            background: #f9fafb;
        }

        .amount-cell {
            font-weight: 600;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .amount-cell.expense { color: #ef4444; }
        .amount-cell.income { color: #10b981; }

        .category-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 500;
        }

        .category-badge.fixed-costs { background: #fee2e2; color: #dc2626; }
        .category-badge.short-term { background: #fef3c7; color: #d97706; }
        .category-badge.long-term { background: #d1fae5; color: #059669; }
        .category-badge.guilt-free { background: #ede9fe; color: #7c3aed; }
        .category-badge.uncategorized { background: #f3f4f6; color: #6b7280; }
        .category-badge.income { background: #dbeafe; color: #2563eb; }

        .category-select {
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* Comparison Chart */
        .chart-container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .chart-title {
            font-weight: 600;
            font-size: 1.1em;
            margin-bottom: 20px;
            text-align: center;
        }

        .comparison-bars {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .comparison-row {
            display: grid;
            grid-template-columns: 150px 1fr 80px;
            gap: 15px;
            align-items: center;
        }

        .comparison-label {
            font-weight: 500;
            text-align: right;
        }

        .comparison-bar-container {
            position: relative;
            height: 30px;
        }

        .comparison-bar {
            position: absolute;
            height: 12px;
            border-radius: 6px;
            transition: width 0.5s;
        }

        .comparison-bar.target {
            top: 0;
            background: #e0e0e0;
        }

        .comparison-bar.actual {
            top: 16px;
        }

        .comparison-bar.actual.fixed-costs { background: #ef4444; }
        .comparison-bar.actual.short-term { background: #f59e0b; }
        .comparison-bar.actual.long-term { background: #10b981; }
        .comparison-bar.actual.guilt-free { background: #8b5cf6; }

        .comparison-value {
            font-weight: 600;
            font-size: 0.9em;
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            border: none;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: white;
            color: #667eea;
            border: 2px solid #667eea;
        }

        .btn-secondary:hover {
            background: #f0f4ff;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }

        /* Footer */
        footer {
            background: #f5f5f5;
            padding: 20px 30px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            color: #666;
            font-size: 0.9em;
        }

        footer a {
            color: #667eea;
            text-decoration: none;
            font-weight: 600;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .workflow-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 20px 0;
            margin-top: 15px;
            border-top: 1px solid #e0e0e0;
        }

        .workflow-nav a {
            text-decoration: none;
            font-weight: 600;
            padding: 10px 20px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .workflow-nav .nav-arrow {
            background: #667eea;
            color: white;
        }

        .workflow-nav .nav-arrow:hover {
            background: #5568d3;
            text-decoration: none;
        }

        .workflow-nav .home-link {
            color: #667eea;
            font-size: 0.95em;
        }

        .workflow-nav .home-link:hover {
            background: #f0f4ff;
            text-decoration: none;
        }

        /* Navigation Tabs */
        .nav-tabs {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            background: transparent;
            gap: 8px;
            padding: 0 20px;
        }

        .nav-tab {
            flex: 1;
            padding: 14px 16px;
            text-align: center;
            text-decoration: none;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 500;
            font-size: 0.95em;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            background: transparent;
        }

        .nav-tab:hover {
            color: rgba(255, 255, 255, 0.95);
        }

        .nav-tab.active {
            color: white;
            border-bottom-color: white;
            font-weight: 600;
        }

        /* Accessibility: Skip link */
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #667eea;
            color: white;
            padding: 8px 16px;
            z-index: 100;
            text-decoration: none;
            font-weight: 600;
            border-radius: 0 0 4px 0;
        }

        .skip-link:focus {
            top: 0;
        }

        /* Info Box */
        .info-box {
            background: #dbeafe;
            border: 1px solid #93c5fd;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #1e40af;
            font-size: 0.95em;
        }

        .info-box strong {
            display: block;
            margin-bottom: 5px;
        }

        /* API Key Section */
        .api-key-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .api-key-input {
            flex: 1;
            min-width: 200px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            font-family: monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .ai-status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            display: none;
        }

        .ai-status.show {
            display: block;
        }

        .ai-status.processing {
            background: #dbeafe;
            color: #1e40af;
        }

        .ai-status.success {
            background: #d1fae5;
            color: #065f46;
        }

        .ai-status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .provider-select {
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            min-width: 180px;
        }

        .provider-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .api-help {
            margin-top: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .api-help a {
            color: #667eea;
            text-decoration: none;
        }

        .api-help a:hover {
            text-decoration: underline;
        }

        .cors-notice {
            background: #fef3c7;
            border: 1px solid #fcd34d;
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 15px;
            color: #92400e;
            font-size: 0.9em;
        }

        /* Upload Guidance */
        .upload-guidance {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .guidance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .guidance-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }

        .guidance-item.essential {
            border-left: 3px solid #10b981;
        }

        .guidance-item.recommended {
            border-left: 3px solid #f59e0b;
        }

        .guidance-icon {
            font-size: 1.2em;
        }

        .guidance-item div {
            display: flex;
            flex-direction: column;
        }

        .guidance-item strong {
            font-size: 0.95em;
            color: #333;
        }

        .guidance-item span:not(.guidance-icon) {
            font-size: 0.85em;
            color: #666;
        }

        .guidance-tip {
            margin-top: 15px;
            font-size: 0.9em;
            color: #0369a1;
            font-style: italic;
        }

        /* Bulk Categorization */
        .bulk-group {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .bulk-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            cursor: pointer;
            background: #f9fafb;
            transition: background 0.2s;
            gap: 10px;
        }

        .bulk-group-header:hover {
            background: #f3f4f6;
        }

        .bulk-group-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            flex: 1;
        }

        .bulk-group-name {
            font-weight: 600;
            color: #333;
            word-break: break-word;
        }

        .bulk-group-count {
            font-size: 0.85em;
            color: #666;
        }

        .bulk-group-actions {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .bulk-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: opacity 0.2s, transform 0.1s;
            font-weight: 500;
        }

        .bulk-btn:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        .bulk-btn:active {
            transform: scale(0.98);
        }

        .bulk-btn.fixed-costs { background: #fee2e2; color: #dc2626; }
        .bulk-btn.short-term { background: #fef3c7; color: #d97706; }
        .bulk-btn.long-term { background: #d1fae5; color: #059669; }
        .bulk-btn.guilt-free { background: #ede9fe; color: #7c3aed; }
        .bulk-btn.income { background: #dbeafe; color: #2563eb; }

        .bulk-group-details {
            display: none;
            padding: 15px;
            border-top: 1px solid #e0e0e0;
            background: white;
            max-height: 200px;
            overflow-y: auto;
        }

        .bulk-group.expanded .bulk-group-details {
            display: block;
        }

        .bulk-transaction {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f3f4f6;
            font-size: 0.9em;
            gap: 10px;
        }

        .bulk-transaction:last-child {
            border-bottom: none;
        }

        .bulk-transaction span:first-child {
            flex: 1;
            min-width: 0;
            word-break: break-word;
        }

        /* Upload Success State */
        .upload-area.success {
            border-color: #10b981;
            background: #d1fae5;
        }

        .upload-success-info {
            margin-top: 15px;
            padding: 12px 15px;
            background: #d1fae5;
            border: 1px solid #6ee7b7;
            border-radius: 6px;
            color: #065f46;
            font-size: 0.95em;
        }

        .upload-success-info strong {
            display: block;
            margin-bottom: 5px;
        }

        /* Mobile Transaction Cards */
        .transaction-cards {
            display: none;
        }

        .transaction-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .transaction-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
            gap: 10px;
        }

        .transaction-card-desc {
            font-weight: 500;
            color: #333;
            word-break: break-word;
            flex: 1;
        }

        .transaction-card-amount {
            font-weight: 700;
            font-family: 'SF Mono', Monaco, monospace;
            white-space: nowrap;
        }

        .transaction-card-amount.expense { color: #ef4444; }
        .transaction-card-amount.income { color: #10b981; }

        .transaction-card-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .transaction-card-date {
            font-size: 0.85em;
            color: #666;
        }

        .transaction-card-category {
            flex: 1;
        }

        .transaction-card-category select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #f9fafb;
            font-size: 0.9em;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .nav-tabs {
                padding: 0 10px;
                gap: 4px;
            }

            .nav-tab {
                padding: 12px 8px;
                font-size: 0.85em;
            }

            header {
                padding: 20px;
            }

            header h1 {
                font-size: 1.5em;
            }

            header p {
                font-size: 0.95em;
            }

            .content {
                padding: 15px;
            }

            .section {
                padding: 15px;
                margin-bottom: 20px;
            }

            .comparison-row {
                grid-template-columns: 1fr;
                gap: 5px;
            }

            .comparison-label {
                text-align: left;
            }

            /* Hide table, show cards on mobile */
            .table-scroll {
                display: none;
            }

            .transaction-cards {
                display: block;
                max-height: 600px;
                overflow-y: auto;
            }

            .transactions-header {
                flex-direction: column;
                gap: 10px;
                align-items: stretch;
            }

            .filter-controls {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .filter-select {
                flex: 1;
                min-width: 120px;
            }

            /* Bulk categorization mobile */
            .bulk-group-header {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .bulk-group-actions {
                justify-content: flex-start;
            }

            .bulk-btn {
                padding: 10px 14px;
                font-size: 0.9em;
            }

            /* Upload area mobile */
            .upload-area {
                padding: 30px 20px;
            }

            .upload-icon {
                font-size: 36px;
            }

            /* Targets grid mobile */
            .targets-grid {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }

            .target-input:first-child {
                grid-column: 1 / -1;
            }

            /* Format grid mobile */
            .format-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            /* Summary cards mobile */
            .summary-cards {
                grid-template-columns: 1fr;
            }

            /* Stats row mobile */
            .stats-row {
                grid-template-columns: repeat(2, 1fr);
            }

            /* API section mobile */
            .api-key-wrapper {
                flex-direction: column;
            }

            .provider-select,
            .api-key-input {
                width: 100%;
            }

            /* Action buttons mobile */
            .action-buttons {
                flex-direction: column;
            }

            .action-buttons .btn {
                width: 100%;
                text-align: center;
            }

            /* Guidance grid mobile */
            .guidance-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .targets-grid {
                grid-template-columns: 1fr;
            }

            .stats-row {
                grid-template-columns: 1fr;
            }

            .bulk-group-actions {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .bulk-btn {
                text-align: center;
            }
        }

        /* Scrollable table container */
        .table-scroll {
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }

        /* Date range display */
        .date-range {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }

        /* Stats row */
        .stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.3em;
            font-weight: 700;
            color: #333;
        }

        .stat-value.expense { color: #ef4444; }
        .stat-value.income { color: #10b981; }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <nav class="nav-tabs" role="navigation" aria-label="Main navigation">
        <a href="income-allocation.html" class="nav-tab">Budget Planner</a>
        <a href="transaction-analyzer.html" class="nav-tab active" aria-current="page">Spending Tracker</a>
        <a href="retirement-simulator.html" class="nav-tab">Retirement Forecast</a>
    </nav>

    <div class="container" role="document">
        <header role="banner">
            <h1><a href="index.html" style="color: inherit; text-decoration: none;">Spending Tracker</a></h1>
            <p>Upload your bank transactions to see your actual spending vs. your goals</p>
            <p style="font-size: 0.75em; color: rgba(255,255,255,0.8); margin-top: 4px;">Code version: 2025-12-29 1:55 PM ET</p>
        </header>

        <main id="main-content" class="content" role="main">
            <!-- Step 1: Set Targets -->
            <div class="section">
                <h2>Step 1: Set Your Target Allocations</h2>
                <p style="color: #666; margin-bottom: 15px;">Enter your monthly take-home pay and how you want to divide it. <a href="income-allocation.html" style="color: #667eea;">Need help deciding? Use the Budget Planner first.</a></p>

                <div class="targets-grid">
                    <div class="target-input">
                        <label for="monthlyIncome">Monthly Income</label>
                        <input type="text" id="monthlyIncome" value="$5,000.00" inputmode="decimal" autocomplete="transaction-amount">
                    </div>
                    <div class="target-input">
                        <label for="targetFixed">Bills & Essentials %</label>
                        <input type="number" id="targetFixed" value="50" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetShortTerm">Savings Goals %</label>
                        <input type="number" id="targetShortTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetLongTerm">Retirement %</label>
                        <input type="number" id="targetLongTerm" value="20" min="0" max="100">
                    </div>
                    <div class="target-input">
                        <label for="targetGuiltFree">Fun Money %</label>
                        <input type="number" id="targetGuiltFree" value="10" min="0" max="100">
                    </div>
                </div>
            </div>

            <!-- Step 2: Upload -->
            <div class="section">
                <h2>Step 2: Upload Your Transactions</h2>

                <div class="upload-guidance">
                    <strong>For an accurate spending picture, upload transactions from:</strong>
                    <div class="guidance-grid">
                        <div class="guidance-item essential">
                            <span class="guidance-icon">&#9989;</span>
                            <div>
                                <strong>Primary Checking Account</strong>
                                <span>Where bills & transfers come from</span>
                            </div>
                        </div>
                        <div class="guidance-item essential">
                            <span class="guidance-icon">&#9989;</span>
                            <div>
                                <strong>Credit Cards</strong>
                                <span>Daily spending & subscriptions</span>
                            </div>
                        </div>
                        <div class="guidance-item recommended">
                            <span class="guidance-icon">&#128161;</span>
                            <div>
                                <strong>Savings Accounts</strong>
                                <span>To track savings transfers</span>
                            </div>
                        </div>
                        <div class="guidance-item recommended">
                            <span class="guidance-icon">&#128161;</span>
                            <div>
                                <strong>Investment Accounts</strong>
                                <span>401k/IRA contributions</span>
                            </div>
                        </div>
                    </div>
                    <p class="guidance-tip">Tip: Export 3-6 months of data for the most accurate monthly averages</p>

                    <div style="background: #fff4e6; border: 1px solid #ffb020; border-radius: 6px; padding: 15px; margin-top: 15px;">
                        <strong style="color: #b45309; display: block; margin-bottom: 8px;">&#128200; How to Export Multiple Statements:</strong>
                        <ul style="color: #92400e; font-size: 0.9em; margin: 0; padding-left: 20px; line-height: 1.6;">
                            <li><strong>Chase:</strong> Log in ‚Üí Activity ‚Üí Select account ‚Üí Download ‚Üí Choose date range ‚Üí CSV format</li>
                            <li><strong>Bank of America:</strong> Accounts ‚Üí Select account ‚Üí Export Transactions ‚Üí CSV</li>
                            <li><strong>Wells Fargo:</strong> Accounts ‚Üí Select account ‚Üí Download Transactions ‚Üí CSV</li>
                            <li><strong>Citi:</strong> Account Activity ‚Üí Download ‚Üí CSV</li>
                            <li><strong>American Express:</strong> Account ‚Üí Statements & Activity ‚Üí Download ‚Üí CSV</li>
                            <li><strong>Capital One:</strong> Transactions ‚Üí Download ‚Üí CSV</li>
                        </ul>
                        <p style="margin: 10px 0 5px 0; color: #b45309; font-size: 0.9em;"><strong>&#10004; Multiple File Upload:</strong> You can select and upload multiple CSV files at once (Ctrl/Cmd+Click to select multiple files)</p>
                        <p style="margin: 5px 0 0 0; color: #b45309; font-size: 0.85em; font-style: italic;">&#9888; Automatic Deduplication: Inter-account transfers (like credit card payments from checking) are automatically detected and excluded from income/spending totals to prevent double-counting.</p>
                    </div>
                </div>

                <div class="upload-area" id="uploadArea">
                    <input type="file" id="fileInput" accept=".csv" multiple>
                    <div class="upload-icon">&#128196;</div>
                    <div class="upload-text">Drop CSV files here or click to upload</div>
                    <div class="upload-hint">You can upload multiple files from different accounts</div>
                </div>
            </div>

            <!-- AI Categorization (Optional) -->
            <div class="section" id="aiSection">
                <h2>AI-Powered Categorization (Optional)</h2>
                <p style="color: #666; margin-bottom: 15px;">Select your AI provider and enter your API key to automatically categorize transactions.</p>

                <div style="background: #fef3c7; border: 1px solid #fcd34d; border-radius: 6px; padding: 12px; margin-bottom: 15px; font-size: 0.9em;">
                    <strong style="color: #92400e;">Privacy Note:</strong>
                    <span style="color: #78350f;">Your API key is stored in your browser's local storage (unencrypted). Only use this on a personal device you trust.</span>
                    <details style="margin-top: 8px;">
                        <summary style="cursor: pointer; color: #92400e; font-weight: 600;">What data is sent to AI?</summary>
                        <p style="margin: 8px 0 0 0; color: #78350f;">Only these fields are sent for each uncategorized transaction: <strong>date</strong>, <strong>description</strong>, and <strong>amount</strong>. No account numbers, balances, or personal identifiers are included. Data is sent directly to the AI provider you select (Google, OpenAI, or Anthropic) ‚Äî it never passes through our servers.</p>
                    </details>
                </div>

                <div class="api-key-wrapper">
                    <select id="aiProvider" class="provider-select">
                        <option value="gemini">Google Gemini</option>
                        <option value="openai">OpenAI (GPT-4o-mini)</option>
                        <option value="anthropic">Anthropic Claude</option>
                    </select>
                    <input type="password" id="apiKey" placeholder="Enter API key..." class="api-key-input">
                    <button class="btn btn-secondary" onclick="analyzer.toggleApiKeyVisibility()">Show</button>
                </div>
                <div style="margin-top: 10px;">
                    <button class="btn btn-primary" id="aiCategorizeBtn" onclick="analyzer.aiCategorize()" disabled>Categorize Remaining Transactions with AI</button>
                </div>
                <div id="aiStatus" class="ai-status"></div>
                <div class="api-help">
                    <strong>Get a free API key:</strong>
                    <a href="https://aistudio.google.com/apikey" target="_blank">Google Gemini (free tier)</a> |
                    <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI</a> |
                    <a href="https://console.anthropic.com/" target="_blank">Anthropic</a>
                </div>
            </div>

            <!-- Results Section (hidden until data uploaded) -->
            <div id="resultsSection" class="results-hidden">
                <!-- Date Range and Stats -->
                <div class="section">
                    <h2>Analysis Summary</h2>
                    <div class="date-range" id="dateRange"></div>
                    <div class="stats-row">
                        <div class="stat-box">
                            <div class="stat-label">Total Transactions</div>
                            <div class="stat-value" id="totalTransactions">0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Income</div>
                            <div class="stat-value income" id="totalIncome">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Total Spending</div>
                            <div class="stat-value expense" id="totalSpending">$0</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">Net</div>
                            <div class="stat-value" id="netAmount">$0</div>
                        </div>
                    </div>
                </div>

                <!-- Comparison Chart -->
                <div class="section">
                    <h2>Goal vs Reality</h2>
                    <div class="chart-container">
                        <div class="chart-title">Target Allocation vs Actual Spending (Monthly Average)</div>
                        <div class="comparison-bars" id="comparisonChart"></div>
                    </div>
                </div>

                <!-- Category Cards -->
                <div class="summary-cards" id="summaryCards"></div>

                <!-- Excluded Transfers Section -->
                <div class="section" id="transfersSection" style="display: none;">
                    <button type="button" id="toggleTransfers" style="width: 100%; background: #f9fafb; border: 1px solid #e5e7eb; padding: 12px 20px; font-size: 1em; font-weight: 600; color: #6b7280; cursor: pointer; display: flex; align-items: center; justify-content: space-between; border-radius: 6px; transition: background 0.2s;">
                        <span><span style="margin-right: 8px;">&#8644;</span> Transfers Detected &amp; Excluded (<span id="transferCount">0</span>)</span>
                        <span class="arrow" style="transition: transform 0.3s;">&#9660;</span>
                    </button>
                    <div id="transfersPanel" style="display: none; margin-top: 10px;">
                        <p style="color: #666; font-size: 0.9em; margin-bottom: 10px;">These transactions were detected as inter-account transfers (matching amounts on same day) and excluded from income/spending totals to prevent double-counting.</p>
                        <div style="overflow-x: auto;">
                            <table class="transactions-table" style="font-size: 0.9em;">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Description</th>
                                        <th>Amount</th>
                                        <th>Matched With</th>
                                        <th>Action</th>
                                    </tr>
                                </thead>
                                <tbody id="transfersTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Bulk Categorization -->
                <div class="section" id="bulkCategorizeSection" style="display: none;">
                    <h2>Quick Categorize</h2>
                    <p style="color: #666; margin-bottom: 15px;">Group similar transactions and categorize them all at once. Click a group to expand and categorize.</p>
                    <div id="bulkGroups"></div>
                    <div id="zeroTotalGroups" style="margin-top: 20px;"></div>
                </div>

                <!-- Transactions Table -->
                <div class="section">
                    <h2>Transaction Details</h2>
                    <div class="transactions-container">
                        <div class="transactions-header">
                            <span class="transactions-title">All Transactions</span>
                            <div class="filter-controls">
                                <select class="filter-select" id="categoryFilter">
                                    <option value="all">All Categories</option>
                                    <option value="fixed-costs">Fixed Costs</option>
                                    <option value="short-term">Short-Term Savings</option>
                                    <option value="long-term">Long-Term Savings</option>
                                    <option value="guilt-free">Guilt-Free Spending</option>
                                    <option value="income">Income</option>
                                    <option value="uncategorized">Uncategorized</option>
                                    <option value="transfers">Transfers (Excluded)</option>
                                </select>
                                <select class="filter-select" id="sortOrder">
                                    <option value="date-desc">Date (Newest)</option>
                                    <option value="date-asc">Date (Oldest)</option>
                                    <option value="amount-desc">Amount (High to Low)</option>
                                    <option value="amount-asc">Amount (Low to High)</option>
                                </select>
                            </div>
                        </div>
                        <!-- Desktop Table View -->
                        <div class="table-scroll">
                            <table class="transactions-table">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Description</th>
                                        <th>Amount</th>
                                        <th>Category</th>
                                    </tr>
                                </thead>
                                <tbody id="transactionsBody"></tbody>
                            </table>
                        </div>
                        <!-- Mobile Card View -->
                        <div class="transaction-cards" id="transactionCards"></div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="action-buttons">
                    <button class="btn btn-secondary" onclick="analyzer.exportSummary()">Export Summary</button>
                    <button class="btn btn-primary" onclick="analyzer.saveRules()">Save Categorization Rules</button>
                    <a href="income-allocation.html" class="btn btn-success">Adjust Your Allocation Plan</a>
                </div>
            </div>
        </main>

        <footer role="contentinfo">
            <nav class="workflow-nav" aria-label="Workflow navigation">
                <a href="income-allocation.html" class="nav-arrow">‚Üê Back to Budget Planner</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="retirement-simulator.html" class="nav-arrow">Continue to Retirement Simulator ‚Üí</a>
            </nav>
        </footer>
    </div>

    <script>
        class TransactionAnalyzer {
            constructor() {
                this.transactions = [];
                this.lastBulkAction = null; // For undo functionality
                this.targets = {
                    income: 5000,
                    fixedCosts: 50,
                    shortTerm: 20,
                    longTerm: 20,
                    guiltFree: 10
                };

                // Category patterns for auto-categorization
                this.categoryPatterns = {
                    'fixed-costs': [
                        // Housing
                        /rent|mortgage|hoa|property.*tax|home.*insurance|landlord|apartment|lease/i,
                        // Utilities
                        /electric|gas.*company|water.*bill|sewage|trash|waste|pge|con.*ed|duke.*energy|xcel|national.*grid|dominion/i,
                        /comcast|xfinity|spectrum|at&t|verizon|t-mobile|sprint|cricket|internet|cable|fiber|broadband/i,
                        // Phone
                        /phone.*bill|wireless|cell.*phone|mobile.*plan/i,
                        // Insurance
                        /geico|allstate|state.*farm|progressive|liberty.*mutual|insurance|health.*plan|aetna|cigna|united.*health|blue.*cross|anthem|kaiser/i,
                        // Car
                        /car.*payment|auto.*loan|toyota.*financial|honda.*financial|ford.*credit|gm.*financial|bmw.*financial|mercedes.*financial/i,
                        // Debt payments
                        /student.*loan|nelnet|navient|fedloan|sofi|earnest|loan.*payment|great.*lakes|mohela/i,
                        /credit.*card.*payment|minimum.*payment|debt.*payment/i,
                        // Groceries (essential)
                        /grocery|safeway|kroger|publix|trader.*joe|whole.*foods|aldi|costco|walmart|target|wegmans|heb|albertsons|giant|stop.*shop|food.*lion|winco|sprouts|meijer|food.*city/i,
                        // Healthcare essentials
                        /pharmacy|cvs|walgreens|rite.*aid|prescription|doctor|medical|copay|hospital|clinic|urgent.*care|lab|quest.*diagnostics|labcorp/i,
                        // Childcare
                        /daycare|childcare|preschool|tuition|school|kindercare|bright.*horizons/i,
                        // Transportation essentials
                        /gas.*station|shell|chevron|exxon|mobil|bp|arco|speedway|wawa|parking|toll|ez.*pass|sunpass|fastrak/i,
                        /uber(?!.*eats)|lyft|transit|metro|subway.*fare|bus.*pass|caltrain|bart|mta|wmata/i,
                        // Bank fees (unfortunately essential)
                        /bank.*fee|monthly.*fee|service.*charge|overdraft/i
                    ],
                    'short-term': [
                        // Savings transfers
                        /transfer.*to.*savings|savings.*deposit|marcus|ally.*savings|hysa/i,
                        /emergency.*fund|vacation.*fund|sinking.*fund/i
                    ],
                    'long-term': [
                        // Retirement & Investments
                        /401k|403b|ira|roth|vanguard|fidelity|schwab|etrade|robinhood|wealthfront|betterment/i,
                        /investment|brokerage|stock.*purchase|dividend/i
                    ],
                    'guilt-free': [
                        // Dining & Drinks
                        /restaurant|cafe|coffee|starbucks|dunkin|mcdonald|burger|pizza|chipotle|taco.*bell|wendy|chick-fil-a|panera|subway|panda.*express/i,
                        /doordash|uber.*eats|grubhub|postmates|instacart|seamless|caviar|gopuff/i,
                        /bar|brewery|pub|tavern|wine|liquor|total.*wine|bevmo/i,
                        // Entertainment & Streaming
                        /netflix|hulu|disney|hbo|max|amazon.*prime|spotify|apple.*music|youtube.*premium|paramount|peacock|crunchyroll|funimation/i,
                        /movie|cinema|amc|regal|concert|ticket|eventbrite|stubhub|ticketmaster|livenation|fandango/i,
                        /gaming|playstation|xbox|nintendo|steam|twitch|epic.*games|riot|blizzard/i,
                        // Apple (subscriptions, App Store, iTunes)
                        /apple\.com|apple\.com\/bill|itunes|app.*store|icloud/i,
                        // Google (Play Store, YouTube, etc)
                        /google.*play|google.*storage|google.*one|youtube/i,
                        // Other Tech Subscriptions
                        /microsoft|office.*365|adobe|creative.*cloud|dropbox|evernote|notion|slack|zoom|canva/i,
                        // Shopping
                        /amazon(?!.*prime.*member)|ebay|etsy|target(?!.*grocery)|walmart(?!.*grocery)|best.*buy|home.*depot|lowes|ikea|wayfair|overstock/i,
                        /nordstrom|macy|kohls|tj.*maxx|marshalls|ross|old.*navy|gap|h&m|zara|uniqlo|shein|asos|fashion.*nova/i,
                        /sephora|ulta|beauty|salon|spa|haircut|barber|nail|massage/i,
                        // Hobbies & Fitness
                        /gym|fitness|peloton|planet.*fitness|orange.*theory|crossfit|yoga|equinox|lifetime/i,
                        /golf|ski|sports|hobby|craft|book|audible|kindle|barnes.*noble/i,
                        // Subscriptions & Memberships
                        /subscription|membership|patreon|substack|medium|onlyfans|twitch.*sub/i,
                        /amazon.*prime.*member|costco.*member|sam.*club.*member/i,
                        // Travel & Leisure
                        /hotel|airbnb|vrbo|airline|flight|united|delta|american.*air|southwest|jetblue|spirit|frontier|expedia|booking|kayak|hotels\.com|tripadvisor/i,
                        // Food delivery & meal kits
                        /hellofresh|blue.*apron|factor|freshly|daily.*harvest/i,
                        // Dating & Social
                        /tinder|bumble|hinge|match\.com|dating/i,
                        // Pet
                        /petco|petsmart|chewy|pet.*supplies/i
                    ],
                    'income': [
                        /payroll|direct.*deposit|salary|wage|employer|paycheck/i,
                        /irs|tax.*refund|refund/i,
                        /dividend|interest.*payment|interest.*earned/i,
                        /venmo.*from|zelle.*from|paypal.*from|cash.*app.*from/i,
                        /reimbursement|expense.*reimburse/i
                    ]
                };

                // Column detection configuration (auto-detects common bank formats)
                this.columnConfig = {
                    dateCol: ['Date', 'Transaction Date', 'Trans Date', 'Trans. Date', 'Posted Date', 'Posting Date'],
                    descCol: ['Description', 'Memo', 'Name', 'Merchant', 'Payee', 'Transaction Description'],
                    amountCol: ['Amount', 'Transaction Amount', 'Debit', 'Credit', 'Value']
                };

                // Load saved rules from localStorage
                this.loadSavedRules();
                this.init();
            }

            init() {
                // File upload
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    this.handleFiles(e.dataTransfer.files);
                });
                fileInput.addEventListener('change', (e) => {
                    this.handleFiles(e.target.files);
                });

                // Target inputs - monthlyIncome with currency formatting
                const incomeInput = document.getElementById('monthlyIncome');
                incomeInput.addEventListener('input', (e) => {
                    this.targets.income = this.parseCurrencyValue(e.target.value);
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                incomeInput.addEventListener('focus', (e) => {
                    const value = this.parseCurrencyValue(e.target.value);
                    e.target.value = value > 0 ? value.toFixed(2) : '';
                });
                incomeInput.addEventListener('blur', (e) => {
                    const value = this.parseCurrencyValue(e.target.value);
                    e.target.value = this.formatCurrencyInput(value);
                });
                document.getElementById('targetFixed').addEventListener('input', (e) => {
                    this.targets.fixedCosts = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetShortTerm').addEventListener('input', (e) => {
                    this.targets.shortTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetLongTerm').addEventListener('input', (e) => {
                    this.targets.longTerm = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });
                document.getElementById('targetGuiltFree').addEventListener('input', (e) => {
                    this.targets.guiltFree = parseFloat(e.target.value) || 0;
                    if (this.transactions.length > 0) this.updateDisplay();
                });

                // Filters
                document.getElementById('categoryFilter').addEventListener('change', () => this.renderTransactions());
                document.getElementById('sortOrder').addEventListener('change', () => this.renderTransactions());
            }

            handleFiles(files) {
                const fileNames = Array.from(files).map(f => f.name);
                const promises = Array.from(files).map(file => this.parseCSV(file));

                Promise.all(promises).then(results => {
                    this.transactions = results.flat();
                    this.transactions.sort((a, b) => new Date(b.date) - new Date(a.date));

                    // Deduplicate inter-account transfers
                    this.deduplicateTransfers();

                    // Auto-categorize
                    this.transactions.forEach(t => {
                        if (!t.category) {
                            t.category = this.categorizeTransaction(t);
                        }
                    });

                    this.updateDisplay();
                    document.getElementById('resultsSection').classList.remove('results-hidden');

                    // Show upload success feedback
                    this.showUploadSuccess(fileNames, this.transactions.length);

                    // Save transactions to localStorage for session persistence
                    StorageUtils.set('transactionData', this.transactions);

                    // Save spending data for Retirement Forecast page
                    this.saveSpendingDataForRetirement();
                }).catch(error => {
                    console.error('Error parsing files:', error);
                    this.showError(error.message || 'Error parsing CSV file. Please check the format and try again.');
                });
            }

            showUploadSuccess(fileNames, transactionCount) {
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.classList.add('success');

                // Remove existing success info if any
                const existingInfo = document.querySelector('.upload-success-info');
                if (existingInfo) existingInfo.remove();

                // Create success message
                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                const successInfo = document.createElement('div');
                successInfo.className = 'upload-success-info';
                let message = `<strong>Successfully loaded ${transactionCount} transactions!</strong>`;
                if (transferCount > 0) {
                    message += `<span style="color: #10b981; font-size: 0.9em; margin-top: 5px; display: block;">&#10004; ${transferCount} inter-account transfers detected and excluded from totals</span>`;
                }
                message += `<span style="margin-top: 5px; display: block;">Files: ${fileNames.map(n => this.escapeHtml(n)).join(', ')}</span>`;
                message += `<div style="background: #f0f9ff; border-left: 3px solid #3b82f6; padding: 10px; margin-top: 10px; font-size: 0.9em;">
                    <strong style="color: #1e40af;">Smart Categorization:</strong>
                    <span style="color: #475569;">Your transactions are first automatically categorized using pattern matching (for example, transactions containing "WALMART" or "GROCERY" are categorized as Fixed Costs). This reduces the need for AI and speeds up the process. Use AI categorization below for any remaining uncategorized transactions.</span>
                </div>`;
                successInfo.innerHTML = message;
                uploadArea.parentNode.insertBefore(successInfo, uploadArea.nextSibling);

                // Update upload area text
                uploadArea.querySelector('.upload-text').textContent = 'Drop more CSV files to add transactions';
            }

            showError(errorMessage) {
                // Remove any existing error messages
                const existingError = document.querySelector('.upload-error-info');
                if (existingError) existingError.remove();

                // Create error message element
                const errorDiv = document.createElement('div');
                errorDiv.className = 'upload-error-info';
                errorDiv.style.cssText = `
                    background: #fef2f2;
                    border: 2px solid #ef4444;
                    border-radius: 8px;
                    padding: 20px;
                    margin: 20px auto;
                    max-width: 800px;
                    box-shadow: 0 2px 8px rgba(239, 68, 68, 0.2);
                `;

                // Format the error message (preserve newlines and structure)
                const formattedMessage = errorMessage
                    .replace(/\n\n/g, '<br><br>')
                    .replace(/\n‚Ä¢/g, '<br>‚Ä¢');

                errorDiv.innerHTML = `
                    <div style="display: flex; align-items: start; gap: 15px;">
                        <div style="font-size: 2em; color: #ef4444;">‚ö†Ô∏è</div>
                        <div style="flex: 1;">
                            <h3 style="margin: 0 0 10px 0; color: #991b1b; font-size: 1.2em;">CSV Upload Error</h3>
                            <div style="color: #7f1d1d; white-space: pre-wrap; font-family: inherit; line-height: 1.6;">${formattedMessage}</div>
                            <button onclick="this.parentElement.parentElement.parentElement.remove()"
                                    style="margin-top: 15px; padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                Dismiss
                            </button>
                        </div>
                    </div>
                `;

                // Insert after upload area
                const uploadArea = document.getElementById('uploadArea');
                uploadArea.parentNode.insertBefore(errorDiv, uploadArea.nextSibling);

                // Scroll to error message
                errorDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

            saveSpendingDataForRetirement() {
                // Calculate monthly averages for Retirement Forecast
                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date)).filter(d => !isNaN(d));

                // Default to 1 month if no valid dates
                let months = 1;
                if (dates.length > 0) {
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));
                }

                const monthlySpending = (categories['fixed-costs']?.total || 0) / months +
                                        (categories['guilt-free']?.total || 0) / months;
                const monthlyLongTermSavings = (categories['long-term']?.total || 0) / months;

                // Save for Retirement Forecast
                StorageUtils.set('spendingTrackerData', {
                    monthlySpending: Math.round(monthlySpending),
                    monthlyRetirementSavings: Math.round(monthlyLongTermSavings),
                    lastUpdated: new Date().toISOString()
                });
            }

            parseCSV(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result;
                            const transactions = this.parseCSVText(text);
                            resolve(transactions);
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            parseCSVText(text) {
                const lines = text.trim().split('\n');
                if (lines.length < 2) {
                    throw new Error('CSV file is empty or has no data rows. Please upload a valid CSV file with at least a header row and one data row.');
                }

                // Parse header
                const header = this.parseCSVLine(lines[0]);

                // Auto-detect columns
                const dateIdx = this.findColumnIndex(header, this.columnConfig.dateCol);
                const descIdx = this.findColumnIndex(header, this.columnConfig.descCol);
                const amountIdx = this.findColumnIndex(header, this.columnConfig.amountCol);

                // Validate that required columns were found
                const missingColumns = [];
                if (dateIdx === -1) {
                    missingColumns.push(`Date column (expected: "${this.columnConfig.dateCol.join('" or "')}")`);
                }
                if (descIdx === -1) {
                    missingColumns.push(`Description column (expected: "${this.columnConfig.descCol.join('" or "')}")`);
                }
                if (amountIdx === -1) {
                    missingColumns.push(`Amount column (expected: "${this.columnConfig.amountCol.join('" or "')}")`);
                }

                if (missingColumns.length > 0) {
                    const foundColumns = header.map(h => `"${h}"`).join(', ');
                    throw new Error(
                        `Could not find required columns in CSV file.\n\n` +
                        `Missing: ${missingColumns.join(', ')}\n\n` +
                        `Found columns: ${foundColumns}\n\n` +
                        `Please ensure your CSV has the correct column headers.`
                    );
                }

                // Parse transactions
                const transactions = [];
                const requiredIdx = Math.max(dateIdx, descIdx, amountIdx);

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const values = this.parseCSVLine(line);

                    // Skip rows that don't have enough columns
                    if (values.length <= requiredIdx) continue;

                    const dateStr = values[dateIdx];
                    const description = values[descIdx];
                    const amount = parseFloat(values[amountIdx]?.replace(/[,$]/g, '')) || 0;

                    const date = this.parseDate(dateStr);
                    if (!date || isNaN(amount)) continue;

                    transactions.push({
                        date: date,
                        description: description,
                        amount: amount,
                        category: null,
                        id: `${date}-${description}-${amount}-${i}`
                    });
                }

                // If no transactions were parsed, throw a helpful error
                if (transactions.length === 0) {
                    throw new Error(
                        'No valid transactions found in CSV file.\n\n' +
                        'This could mean:\n' +
                        '‚Ä¢ The date format is not recognized\n' +
                        '‚Ä¢ The amount values cannot be parsed\n' +
                        '‚Ä¢ All data rows are empty\n\n' +
                        'Please check your CSV file format and try again.'
                    );
                }

                return transactions;
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());

                return result;
            }

            findColumnIndex(header, possibleNames) {
                // Normalize a string for flexible matching
                const normalize = (str) => {
                    return str
                        .toLowerCase()
                        .trim()
                        .replace(/[.\-_]/g, ' ')  // Replace punctuation with spaces
                        .replace(/\s+/g, ' ')      // Normalize multiple spaces to single space
                        .trim();
                };

                const namesToCheck = typeof possibleNames === 'string' ? [possibleNames] : possibleNames;

                // First pass: exact match (case-insensitive)
                for (const name of namesToCheck) {
                    const idx = header.findIndex(h => h.toLowerCase().trim() === name.toLowerCase());
                    if (idx !== -1) return idx;
                }

                // Second pass: normalized match (handles punctuation/spacing differences)
                for (const name of namesToCheck) {
                    const normalizedName = normalize(name);
                    const idx = header.findIndex(h => normalize(h) === normalizedName);
                    if (idx !== -1) return idx;
                }

                // Third pass: partial match (column contains the search term)
                for (const name of namesToCheck) {
                    const normalizedName = normalize(name);
                    const idx = header.findIndex(h => {
                        const normalizedHeader = normalize(h);
                        // Check if header contains the name or name contains the header
                        return normalizedHeader.includes(normalizedName) || normalizedName.includes(normalizedHeader);
                    });
                    if (idx !== -1) return idx;
                }

                return -1;
            }

            parseDate(dateStr) {
                return DateUtils.parseDate(dateStr);
            }

            categorizeTransaction(transaction) {
                const desc = transaction.description.toLowerCase();
                const amount = transaction.amount;

                // Check income first (positive amounts or income patterns)
                if (amount > 0) {
                    for (const pattern of this.categoryPatterns['income']) {
                        if (pattern.test(desc)) {
                            return 'income';
                        }
                    }
                    // If positive but no income pattern, might still be income or refund
                    return 'income';
                }

                // Check expense categories
                for (const [category, patterns] of Object.entries(this.categoryPatterns)) {
                    if (category === 'income') continue;

                    for (const pattern of patterns) {
                        if (pattern.test(desc)) {
                            return category;
                        }
                    }
                }

                return 'uncategorized';
            }

            deduplicateTransfers() {
                // Mark inter-account transfers as duplicates
                // A transfer is detected when:
                // 1. Two transactions have opposite amounts (one positive, one negative)
                // 2. Amounts match exactly or within small tolerance
                // 3. Dates are within a few days
                // 4. At least one description contains strong transfer indicators

                const DAYS_TOLERANCE = 3; // Reduced from 5 for fewer false positives
                const AMOUNT_TOLERANCE = 0.01; // Exact match for most transfers

                // Reset all isTransfer flags (but preserve manual overrides)
                this.transactions.forEach(t => {
                    if (!t.manuallyUnmarkedTransfer) {
                        t.isTransfer = false;
                    }
                });

                // Strong transfer indicators (require at least one)
                const strongTransferKeywords = [
                    'transfer to', 'transfer from', 'online transfer',
                    'credit card payment', 'payment to card', 'card payment',
                    'ach payment', 'electronic payment',
                    'payment thank you', 'autopay'
                ];

                // Account reference patterns (common in inter-account transfers)
                const accountPatterns = [
                    /\*{4}\d{4}/, // ****1234
                    /x{4}\d{4}/i, // xxxx1234
                    /ending in \d{4}/i,
                    /account.*\d{4}/i
                ];

                for (let i = 0; i < this.transactions.length; i++) {
                    const t1 = this.transactions[i];
                    if (t1.isTransfer || t1.manuallyUnmarkedTransfer) continue;

                    for (let j = i + 1; j < this.transactions.length; j++) {
                        const t2 = this.transactions[j];
                        if (t2.isTransfer || t2.manuallyUnmarkedTransfer) continue;

                        // Check if amounts are opposite and match
                        const amountMatch = Math.abs(Math.abs(t1.amount) - Math.abs(t2.amount)) <= AMOUNT_TOLERANCE;
                        const oppositeSign = (t1.amount > 0) !== (t2.amount > 0);

                        if (!amountMatch || !oppositeSign) continue;

                        // Check date proximity
                        const date1 = new Date(t1.date);
                        const date2 = new Date(t2.date);
                        const daysDiff = Math.abs((date1 - date2) / (1000 * 60 * 60 * 24));

                        if (daysDiff > DAYS_TOLERANCE) continue;

                        // Check for strong transfer indicators
                        const desc1 = t1.description.toLowerCase();
                        const desc2 = t2.description.toLowerCase();

                        const hasStrongKeyword = strongTransferKeywords.some(kw =>
                            desc1.includes(kw) || desc2.includes(kw)
                        );

                        const hasAccountRef = accountPatterns.some(pattern =>
                            pattern.test(t1.description) || pattern.test(t2.description)
                        );

                        // Require strong evidence: keyword OR (same day + account reference)
                        if (hasStrongKeyword || (daysDiff === 0 && hasAccountRef)) {
                            t1.isTransfer = true;
                            t2.isTransfer = true;
                            t1.transferMatch = t2.id;
                            t2.transferMatch = t1.id;
                            break;
                        }
                    }
                }

                // Log deduplication results
                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                if (transferCount > 0) {
                    console.log(`Detected and marked ${transferCount} inter-account transfer transactions`);
                }
            }

            updateDisplay() {
                this.updateStats();
                this.updateSummaryCards();
                this.updateComparisonChart();
                this.updateBulkCategorization();
                this.updateTransfersTable();
                this.renderTransactions();
            }

            updateTransfersTable() {
                const transfers = this.transactions.filter(t => t.isTransfer);
                const section = document.getElementById('transfersSection');
                const countEl = document.getElementById('transferCount');
                const tbody = document.getElementById('transfersTableBody');

                if (transfers.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';
                countEl.textContent = transfers.length;

                tbody.innerHTML = transfers.map(t => {
                    const matchedTx = t.transferMatch ? this.transactions.find(tx => tx.id === t.transferMatch) : null;
                    const matchDesc = matchedTx ? this.escapeHtml(matchedTx.description.substring(0, 30)) : 'No match found';
                    return `
                        <tr>
                            <td>${new Date(t.date).toLocaleDateString()}</td>
                            <td>${this.escapeHtml(t.description.substring(0, 40))}${t.description.length > 40 ? '...' : ''}</td>
                            <td class="amount-cell ${t.amount < 0 ? 'expense' : 'income'}">${this.formatCurrency(Math.abs(t.amount))}</td>
                            <td style="font-size: 0.85em; color: #666;">${matchDesc}</td>
                            <td>
                                <button onclick="analyzer.unmarkTransfer('${t.id}')"
                                    style="padding: 4px 10px; background: #f3f4f6; border: 1px solid #d1d5db; border-radius: 4px; cursor: pointer; font-size: 0.8em;"
                                    title="Include this in spending/income totals">
                                    Not a transfer
                                </button>
                            </td>
                        </tr>
                    `;
                }).join('');
            }

            updateBulkCategorization() {
                const uncategorized = this.transactions.filter(t => t.category === 'uncategorized' && !t.isTransfer);
                const section = document.getElementById('bulkCategorizeSection');
                const container = document.getElementById('bulkGroups');

                if (uncategorized.length === 0) {
                    section.style.display = 'none';
                    return;
                }

                section.style.display = 'block';

                // Group by similar description (first 20 chars, normalized)
                const groups = {};
                uncategorized.forEach(t => {
                    const key = t.description
                        .replace(/[0-9#*]+/g, '')
                        .replace(/\s+/g, ' ')
                        .trim()
                        .substring(0, 25)
                        .toLowerCase();

                    if (!groups[key]) {
                        groups[key] = {
                            name: t.description.substring(0, 30),
                            transactions: []
                        };
                    }
                    groups[key].transactions.push(t);
                });

                // Calculate totals for each group and separate $0 groups
                const groupsWithTotals = Object.values(groups).map(group => ({
                    ...group,
                    total: group.transactions.reduce((sum, t) => sum + t.amount, 0)
                }));

                // Separate zero-total groups (refunded/net-zero transactions)
                const zeroGroups = groupsWithTotals.filter(g => Math.abs(g.total) < 0.01);
                const nonZeroGroups = groupsWithTotals.filter(g => Math.abs(g.total) >= 0.01);

                // Sort by count (most frequent first) and take top 20
                const sortedGroups = nonZeroGroups
                    .sort((a, b) => b.transactions.length - a.transactions.length)
                    .slice(0, 20);

                container.innerHTML = '';

                sortedGroups.forEach((group, idx) => {
                    const total = Math.abs(group.total);
                    const groupEl = document.createElement('div');
                    groupEl.className = 'bulk-group';
                    groupEl.innerHTML = `
                        <div class="bulk-group-header" onclick="analyzer.toggleBulkGroup(${idx})">
                            <div class="bulk-group-info">
                                <span class="bulk-group-name">${this.escapeHtml(group.name)}${group.name.length >= 30 ? '...' : ''}</span>
                                <span class="bulk-group-count">${group.transactions.length} transactions ‚Ä¢ ${this.formatCurrency(total)} total</span>
                            </div>
                            <div class="bulk-group-actions">
                                <button class="bulk-btn fixed-costs" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'fixed-costs')">Fixed</button>
                                <button class="bulk-btn guilt-free" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'guilt-free')">Guilt-Free</button>
                                <button class="bulk-btn long-term" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'long-term')">Long-Term</button>
                                <button class="bulk-btn short-term" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'short-term')">Short-Term</button>
                                <button class="bulk-btn income" onclick="event.stopPropagation(); analyzer.bulkCategorize(${idx}, 'income')">Income</button>
                            </div>
                        </div>
                        <div class="bulk-group-details">
                            ${group.transactions.slice(0, 10).map(t => `
                                <div class="bulk-transaction">
                                    <span>${new Date(t.date).toLocaleDateString()} - ${this.escapeHtml(t.description.substring(0, 40))}</span>
                                    <span style="color: ${t.amount < 0 ? '#ef4444' : '#10b981'}">${this.formatCurrency(Math.abs(t.amount))}</span>
                                </div>
                            `).join('')}
                            ${group.transactions.length > 10 ? `<div style="color: #666; font-size: 0.85em; padding-top: 8px;">...and ${group.transactions.length - 10} more</div>` : ''}
                        </div>
                    `;
                    groupEl.dataset.groupIndex = idx;
                    container.appendChild(groupEl);
                });

                // Store groups for later reference
                this.bulkGroups = sortedGroups;

                // Display zero-total groups separately
                const zeroContainer = document.getElementById('zeroTotalGroups');
                if (zeroGroups.length > 0) {
                    zeroContainer.innerHTML = `
                        <div style="background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px; padding: 15px; margin-top: 15px;">
                            <h3 style="color: #0369a1; margin: 0 0 10px 0; font-size: 1em;">Net-Zero Transactions (Not requiring categorization)</h3>
                            <p style="color: #0c4a6e; font-size: 0.9em; margin: 0 0 10px 0;">These transaction groups total $0 and don't impact your budget, so they don't need to be categorized (e.g., refunded purchases, reimbursed expenses).</p>
                            ${zeroGroups.map(group => `
                                <div style="background: white; border-radius: 4px; padding: 10px; margin-bottom: 8px;">
                                    <div style="font-weight: 500; color: #1e293b;">${this.escapeHtml(group.name)}${group.name.length >= 30 ? '...' : ''}</div>
                                    <div style="color: #64748b; font-size: 0.85em;">${group.transactions.length} transaction${group.transactions.length > 1 ? 's' : ''} ‚Ä¢ $0 net total</div>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else {
                    zeroContainer.innerHTML = '';
                }
            }

            toggleBulkGroup(idx) {
                const groups = document.querySelectorAll('.bulk-group');
                groups.forEach((g, i) => {
                    if (i === idx) {
                        g.classList.toggle('expanded');
                    }
                });
            }

            bulkCategorize(groupIdx, category) {
                if (!this.bulkGroups || !this.bulkGroups[groupIdx]) return;

                const group = this.bulkGroups[groupIdx];

                // Save state for undo
                this.lastBulkAction = {
                    groupName: group.name,
                    transactionIds: group.transactions.map(t => t.id),
                    previousCategories: {}
                };

                group.transactions.forEach(t => {
                    const transaction = this.transactions.find(tr => tr.id === t.id);
                    if (transaction) {
                        // Store previous category for undo
                        this.lastBulkAction.previousCategories[t.id] = transaction.category;
                        transaction.category = category;
                        this.saveRule(transaction.description, category);
                    }
                });

                // Save to localStorage for session persistence
                StorageUtils.set('transactionData', this.transactions);

                this.updateDisplay();
                this.showUndoNotification(group.name, category, group.transactions.length);
            }

            showUndoNotification(groupName, category, count) {
                // Remove any existing undo notification
                const existing = document.querySelector('.undo-notification');
                if (existing) existing.remove();

                const notification = document.createElement('div');
                notification.className = 'undo-notification';
                notification.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #1e293b;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    display: flex;
                    align-items: center;
                    gap: 15px;
                    z-index: 1000;
                    font-size: 0.95em;
                `;
                notification.innerHTML = `
                    <span>Categorized ${count} "${this.escapeHtml(groupName.substring(0, 20))}..." transactions as ${category}</span>
                    <button onclick="analyzer.undoLastBulkAction()" style="
                        background: #667eea;
                        color: white;
                        border: none;
                        padding: 6px 12px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-weight: 600;
                    ">Undo</button>
                    <button onclick="this.parentElement.remove()" style="
                        background: transparent;
                        color: #94a3b8;
                        border: none;
                        padding: 4px;
                        cursor: pointer;
                        font-size: 1.2em;
                    ">√ó</button>
                `;
                document.body.appendChild(notification);

                // Auto-dismiss after 10 seconds
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 10000);
            }

            undoLastBulkAction() {
                if (!this.lastBulkAction) return;

                // Restore previous categories
                for (const [id, prevCategory] of Object.entries(this.lastBulkAction.previousCategories)) {
                    const transaction = this.transactions.find(t => t.id === id);
                    if (transaction) {
                        transaction.category = prevCategory;
                    }
                }

                // Save and update
                StorageUtils.set('transactionData', this.transactions);
                this.updateDisplay();

                // Remove notification
                const notification = document.querySelector('.undo-notification');
                if (notification) notification.remove();

                // Clear undo state
                this.lastBulkAction = null;
            }

            updateStats() {
                const dates = this.transactions.map(t => new Date(t.date)).filter(d => !isNaN(d));

                if (dates.length > 0) {
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    document.getElementById('dateRange').textContent =
                        `Showing transactions from ${minDate.toLocaleDateString()} to ${maxDate.toLocaleDateString()}`;
                } else {
                    document.getElementById('dateRange').textContent =
                        `Showing ${this.transactions.length} transactions`;
                }

                // Exclude inter-account transfers from income/spending calculations
                const nonTransferTransactions = this.transactions.filter(t => !t.isTransfer);

                const totalIncome = nonTransferTransactions
                    .filter(t => t.amount > 0)
                    .reduce((sum, t) => sum + t.amount, 0);

                const totalSpending = nonTransferTransactions
                    .filter(t => t.amount < 0)
                    .reduce((sum, t) => sum + Math.abs(t.amount), 0);

                const net = totalIncome - totalSpending;

                const transferCount = this.transactions.filter(t => t.isTransfer).length;
                const displayCount = nonTransferTransactions.length;

                const totalTransactionsEl = document.getElementById('totalTransactions');
                if (transferCount > 0) {
                    totalTransactionsEl.innerHTML = `${displayCount}<br><span style="font-size: 0.7em; color: #64748b; font-weight: normal;">(${transferCount} transfer${transferCount > 1 ? 's' : ''} excluded)</span>`;
                } else {
                    totalTransactionsEl.textContent = displayCount;
                }
                document.getElementById('totalIncome').textContent = this.formatCurrency(totalIncome);
                document.getElementById('totalSpending').textContent = this.formatCurrency(totalSpending);

                const netElement = document.getElementById('netAmount');
                netElement.textContent = this.formatCurrency(net);
                netElement.classList.remove('income', 'expense');
                netElement.classList.add(net >= 0 ? 'income' : 'expense');
            }

            updateSummaryCards() {
                const categories = this.calculateCategoryTotals();
                const totalSpending = Object.entries(categories)
                    .filter(([cat]) => cat !== 'income')
                    .reduce((sum, [, data]) => sum + data.total, 0);

                // Calculate months in data
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const cardsContainer = document.getElementById('summaryCards');
                cardsContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free Spending', targetKey: 'guiltFree' },
                    { key: 'uncategorized', name: 'Uncategorized', targetKey: null }
                ];

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0, count: 0 };
                    const monthlyAvg = data.total / months;
                    const percentage = totalSpending > 0 ? (data.total / totalSpending * 100) : 0;

                    let targetPct = cat.targetKey ? this.targets[cat.targetKey] : 0;
                    let targetAmount = this.targets.income * (targetPct / 100);
                    let diff = monthlyAvg - targetAmount;
                    let diffClass = 'neutral';
                    let diffText = '-';

                    if (cat.targetKey) {
                        if (cat.key === 'short-term' || cat.key === 'long-term') {
                            // For savings, under target is bad
                            diffClass = diff >= 0 ? 'under' : 'over';
                            diffText = diff >= 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        } else {
                            // For spending, over target is bad
                            diffClass = diff <= 0 ? 'under' : 'over';
                            diffText = diff > 0 ? `+${this.formatCurrency(diff)}` : this.formatCurrency(diff);
                        }
                    }

                    const card = document.createElement('div');
                    card.className = `summary-card ${cat.key}`;
                    card.innerHTML = `
                        <div class="card-header">
                            <span class="card-title">${cat.name}</span>
                            <span class="card-percentage">${percentage.toFixed(1)}%</span>
                        </div>
                        <div class="card-amount">${this.formatCurrency(monthlyAvg)}/mo</div>
                        ${cat.targetKey ? `
                            <div class="card-comparison">
                                <span class="comparison-target">Target: ${this.formatCurrency(targetAmount)}/mo</span>
                                <span class="comparison-diff ${diffClass}">${diffText}</span>
                            </div>
                        ` : `
                            <div class="card-comparison">
                                <span class="comparison-target">${data.count} transactions</span>
                            </div>
                        `}
                    `;
                    cardsContainer.appendChild(card);
                });
            }

            updateComparisonChart() {
                const categories = this.calculateCategoryTotals();

                // Calculate months
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                const monthlyIncome = this.targets.income;
                const maxValue = monthlyIncome;

                const chartContainer = document.getElementById('comparisonChart');
                chartContainer.innerHTML = '';

                const categoryConfig = [
                    { key: 'fixed-costs', name: 'Fixed Costs', targetKey: 'fixedCosts' },
                    { key: 'short-term', name: 'Short-Term Savings', targetKey: 'shortTerm' },
                    { key: 'long-term', name: 'Long-Term Savings', targetKey: 'longTerm' },
                    { key: 'guilt-free', name: 'Guilt-Free', targetKey: 'guiltFree' }
                ];

                categoryConfig.forEach(cat => {
                    const data = categories[cat.key] || { total: 0 };
                    const monthlyActual = data.total / months;
                    const targetPct = this.targets[cat.targetKey];
                    const targetAmount = monthlyIncome * (targetPct / 100);

                    const targetWidth = Math.min(100, (targetAmount / maxValue) * 100);
                    const actualWidth = Math.min(100, (monthlyActual / maxValue) * 100);

                    const row = document.createElement('div');
                    row.className = 'comparison-row';
                    row.innerHTML = `
                        <div class="comparison-label">${cat.name}</div>
                        <div class="comparison-bar-container">
                            <div class="comparison-bar target" style="width: ${targetWidth}%"></div>
                            <div class="comparison-bar actual ${cat.key}" style="width: ${actualWidth}%"></div>
                        </div>
                        <div class="comparison-value">
                            <div style="font-size: 0.8em; color: #999;">Target: ${targetPct}%</div>
                            <div>Actual: ${(monthlyActual / monthlyIncome * 100).toFixed(1)}%</div>
                        </div>
                    `;
                    chartContainer.appendChild(row);
                });

                // Add legend
                const legend = document.createElement('div');
                legend.style.cssText = 'display: flex; gap: 20px; justify-content: center; margin-top: 20px; font-size: 0.9em;';
                legend.innerHTML = `
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #e0e0e0; border-radius: 2px; margin-right: 5px;"></span> Target</div>
                    <div><span style="display: inline-block; width: 12px; height: 12px; background: #667eea; border-radius: 2px; margin-right: 5px;"></span> Actual</div>
                `;
                chartContainer.appendChild(legend);
            }

            calculateCategoryTotals() {
                const totals = {};

                // Exclude inter-account transfers from category totals
                this.transactions
                    .filter(t => !t.isTransfer)
                    .forEach(t => {
                        const cat = t.category || 'uncategorized';
                        if (!totals[cat]) {
                            totals[cat] = { total: 0, count: 0 };
                        }
                        totals[cat].total += Math.abs(t.amount);
                        totals[cat].count++;
                    });

                return totals;
            }

            renderTransactions() {
                const categoryFilter = document.getElementById('categoryFilter').value;
                const sortOrder = document.getElementById('sortOrder').value;

                let filtered = [...this.transactions];

                // Apply category filter
                if (categoryFilter === 'transfers') {
                    filtered = filtered.filter(t => t.isTransfer);
                } else if (categoryFilter !== 'all') {
                    filtered = filtered.filter(t => t.category === categoryFilter && !t.isTransfer);
                } else {
                    // For 'all', exclude transfers by default unless specifically viewing them
                    filtered = filtered.filter(t => !t.isTransfer);
                }

                // Apply sort
                switch (sortOrder) {
                    case 'date-desc':
                        filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
                        break;
                    case 'date-asc':
                        filtered.sort((a, b) => new Date(a.date) - new Date(b.date));
                        break;
                    case 'amount-desc':
                        filtered.sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount));
                        break;
                    case 'amount-asc':
                        filtered.sort((a, b) => Math.abs(a.amount) - Math.abs(b.amount));
                        break;
                }

                // Render desktop table
                const tbody = document.getElementById('transactionsBody');
                tbody.innerHTML = '';

                // Render mobile cards with pagination
                const cardsContainer = document.getElementById('transactionCards');
                cardsContainer.innerHTML = '';

                // Mobile pagination settings
                const ITEMS_PER_PAGE = 20;
                this.currentMobilePage = this.currentMobilePage || 1;
                const totalPages = Math.ceil(filtered.length / ITEMS_PER_PAGE);
                const startIdx = (this.currentMobilePage - 1) * ITEMS_PER_PAGE;
                const endIdx = Math.min(startIdx + ITEMS_PER_PAGE, filtered.length);
                const paginatedMobile = filtered.slice(startIdx, endIdx);

                filtered.forEach((t, index) => {
                    const showOnMobile = index >= startIdx && index < endIdx;
                    const isExpense = t.amount < 0;
                    const transferBadge = t.isTransfer ? '<span style="background: #6b7280; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; margin-left: 8px;">TRANSFER</span>' : '';
                    const categoryOptions = `
                        <option value="fixed-costs" ${t.category === 'fixed-costs' ? 'selected' : ''}>Fixed Costs</option>
                        <option value="short-term" ${t.category === 'short-term' ? 'selected' : ''}>Short-Term Savings</option>
                        <option value="long-term" ${t.category === 'long-term' ? 'selected' : ''}>Long-Term Savings</option>
                        <option value="guilt-free" ${t.category === 'guilt-free' ? 'selected' : ''}>Guilt-Free</option>
                        <option value="income" ${t.category === 'income' ? 'selected' : ''}>Income</option>
                        <option value="uncategorized" ${t.category === 'uncategorized' ? 'selected' : ''}>Uncategorized</option>
                    `;

                    // Transfer override button
                    const transferOverride = t.isTransfer ? `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="color: #6b7280; font-style: italic;">Transfer</span>
                            <button onclick="analyzer.unmarkTransfer('${t.id}')"
                                style="background: #fef3c7; color: #92400e; border: 1px solid #fcd34d; border-radius: 4px; padding: 2px 8px; font-size: 0.8em; cursor: pointer;"
                                title="This was incorrectly detected as a transfer. Click to categorize it.">
                                Not a transfer
                            </button>
                        </div>` : '';

                    // Desktop table row
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${new Date(t.date).toLocaleDateString()}</td>
                        <td>${this.escapeHtml(t.description)}${transferBadge}</td>
                        <td class="amount-cell ${isExpense ? 'expense' : 'income'}">
                            ${isExpense ? '-' : '+'}${this.formatCurrency(Math.abs(t.amount))}
                        </td>
                        <td>
                            ${t.isTransfer ? transferOverride : `
                            <select class="category-select" data-id="${t.id}" onchange="analyzer.updateCategory(this)">
                                ${categoryOptions}
                            </select>
                            `}
                        </td>
                    `;
                    tbody.appendChild(row);

                    // Mobile card (only for current page)
                    if (showOnMobile) {
                        const card = document.createElement('div');
                        card.className = 'transaction-card';
                        card.innerHTML = `
                            <div class="transaction-card-header">
                                <span class="transaction-card-desc">${this.escapeHtml(t.description)}${transferBadge}</span>
                                <span class="transaction-card-amount ${isExpense ? 'expense' : 'income'}">
                                    ${isExpense ? '-' : '+'}${this.formatCurrency(Math.abs(t.amount))}
                                </span>
                            </div>
                            <div class="transaction-card-footer">
                                <span class="transaction-card-date">${new Date(t.date).toLocaleDateString()}</span>
                                <div class="transaction-card-category">
                                    ${t.isTransfer ? transferOverride : `
                                    <select data-id="${t.id}" onchange="analyzer.updateCategory(this)">
                                        ${categoryOptions}
                                    </select>
                                    `}
                                </div>
                            </div>
                        `;
                        cardsContainer.appendChild(card);
                    }
                });

                // Add mobile pagination controls
                if (filtered.length > ITEMS_PER_PAGE) {
                    const paginationDiv = document.createElement('div');
                    paginationDiv.className = 'mobile-pagination';
                    paginationDiv.style.cssText = `
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        gap: 10px;
                        padding: 15px;
                        margin-top: 10px;
                    `;
                    paginationDiv.innerHTML = `
                        <button onclick="analyzer.changeMobilePage(-1)" ${this.currentMobilePage <= 1 ? 'disabled' : ''}
                            style="padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: ${this.currentMobilePage <= 1 ? '#f5f5f5' : 'white'}; cursor: ${this.currentMobilePage <= 1 ? 'not-allowed' : 'pointer'};">
                            ‚Üê Prev
                        </button>
                        <span style="color: #666;">Page ${this.currentMobilePage} of ${totalPages}</span>
                        <button onclick="analyzer.changeMobilePage(1)" ${this.currentMobilePage >= totalPages ? 'disabled' : ''}
                            style="padding: 8px 16px; border: 1px solid #ddd; border-radius: 4px; background: ${this.currentMobilePage >= totalPages ? '#f5f5f5' : 'white'}; cursor: ${this.currentMobilePage >= totalPages ? 'not-allowed' : 'pointer'};">
                            Next ‚Üí
                        </button>
                    `;
                    cardsContainer.appendChild(paginationDiv);
                }
            }

            changeMobilePage(delta) {
                this.currentMobilePage = Math.max(1, this.currentMobilePage + delta);
                this.renderTransactions();
            }

            updateCategory(select) {
                const id = select.dataset.id;
                const newCategory = select.value;

                const transaction = this.transactions.find(t => t.id === id);
                if (transaction) {
                    transaction.category = newCategory;

                    // Save the rule for this merchant
                    this.saveRule(transaction.description, newCategory);

                    // Save to localStorage for session persistence
                    StorageUtils.set('transactionData', this.transactions);

                    // Update display
                    this.updateStats();
                    this.updateSummaryCards();
                    this.updateComparisonChart();
                }
            }

            unmarkTransfer(id) {
                const transaction = this.transactions.find(t => t.id === id);
                if (transaction) {
                    // Unmark this transaction and its matched pair
                    transaction.isTransfer = false;
                    transaction.manuallyUnmarkedTransfer = true; // Prevent re-detection
                    transaction.category = this.categorizeTransaction(transaction);

                    // Also unmark the matched transfer if it exists
                    if (transaction.transferMatch) {
                        const matchedTx = this.transactions.find(t => t.id === transaction.transferMatch);
                        if (matchedTx) {
                            matchedTx.isTransfer = false;
                            matchedTx.manuallyUnmarkedTransfer = true;
                            matchedTx.category = this.categorizeTransaction(matchedTx);
                            delete matchedTx.transferMatch;
                        }
                        delete transaction.transferMatch;
                    }

                    // Save and update display
                    StorageUtils.set('transactionData', this.transactions);
                    this.updateDisplay();
                }
            }

            saveRule(description, category) {
                // Extract merchant name (first few words, cleaned up)
                const merchantPattern = description
                    .replace(/[0-9#*]+/g, '')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .split(' ')
                    .slice(0, 3)
                    .join(' ')
                    .toLowerCase();

                if (merchantPattern.length < 3) return;

                // Save to localStorage
                const rules = StorageUtils.get('transactionRules', {});
                rules[merchantPattern] = category;
                StorageUtils.set('transactionRules', rules);
            }

            loadSavedRules() {
                const rules = StorageUtils.get('transactionRules', {});

                // Add saved rules to category patterns
                for (const [pattern, category] of Object.entries(rules)) {
                    if (this.categoryPatterns[category]) {
                        const regex = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');
                        this.categoryPatterns[category].unshift(regex);
                    }
                }
            }

            saveRules() {
                const rules = StorageUtils.get('transactionRules', {});
                DOMUtils.downloadFile(JSON.stringify(rules, null, 2), 'transaction-rules.json', 'application/json');
            }

            exportSummary() {
                const categories = this.calculateCategoryTotals();
                const dates = this.transactions.map(t => new Date(t.date));
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                const months = Math.max(1, (maxDate - minDate) / (1000 * 60 * 60 * 24 * 30));

                let summary = `Transaction Analysis Summary\n`;
                summary += `============================\n\n`;
                summary += `Date Range: ${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}\n`;
                summary += `Total Transactions: ${this.transactions.length}\n\n`;

                summary += `Monthly Spending by Category:\n`;
                summary += `-----------------------------\n`;

                const categoryNames = {
                    'fixed-costs': 'Fixed Costs',
                    'short-term': 'Short-Term Savings',
                    'long-term': 'Long-Term Savings',
                    'guilt-free': 'Guilt-Free Spending',
                    'income': 'Income',
                    'uncategorized': 'Uncategorized'
                };

                for (const [key, name] of Object.entries(categoryNames)) {
                    const data = categories[key] || { total: 0, count: 0 };
                    const monthly = data.total / months;
                    summary += `${name}: ${this.formatCurrency(monthly)}/month (${data.count} transactions)\n`;
                }

                DOMUtils.downloadFile(summary, 'spending-summary.txt');
            }

            formatCurrency(value) {
                return FinanceUtils.formatCurrency(value);
            }

            parseCurrencyValue(value) {
                // Remove all non-numeric characters except decimal point
                const cleaned = String(value).replace(/[^0-9.]/g, '');
                return parseFloat(cleaned) || 0;
            }

            formatCurrencyInput(value) {
                // Format as currency with commas and 2 decimal places
                return '$' + value.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            }

            escapeHtml(text) {
                return DOMUtils.escapeHtml(text);
            }

            // AI Categorization Methods
            toggleApiKeyVisibility() {
                const input = document.getElementById('apiKey');
                const btn = event.target;
                if (input.type === 'password') {
                    input.type = 'text';
                    btn.textContent = 'Hide';
                } else {
                    input.type = 'password';
                    btn.textContent = 'Show';
                }
            }

            getCategorizationPrompt(transactionList) {
                return `You are a financial transaction categorizer. Categorize each transaction into exactly one of these categories:

- fixed-costs: Essential expenses (rent, mortgage, utilities, insurance, groceries, gas, pharmacy, childcare, minimum debt payments)
- short-term: Transfers to savings accounts, emergency fund deposits
- long-term: Retirement contributions (401k, IRA), investment transfers, brokerage deposits
- guilt-free: Discretionary spending (restaurants, entertainment, shopping, subscriptions, travel, hobbies)
- income: Salary, refunds, reimbursements, interest earned

Here are the transactions to categorize (negative amounts are expenses, positive are income):

${JSON.stringify(transactionList, null, 2)}

Respond with ONLY a JSON array in this exact format, no other text:
[{"id": "transaction-id-here", "category": "category-name-here"}, ...]`;
            }

            async aiCategorize() {
                const apiKey = document.getElementById('apiKey').value.trim();
                const provider = document.getElementById('aiProvider').value;

                if (!apiKey) {
                    this.showAiStatus('Please enter your API key', 'error');
                    return;
                }

                const uncategorized = this.transactions.filter(t => t.category === 'uncategorized');
                if (uncategorized.length === 0) {
                    this.showAiStatus('No uncategorized transactions to process!', 'success');
                    return;
                }

                this.showAiStatus(`Processing ${uncategorized.length} uncategorized transactions with AI (${provider})...`, 'processing');
                document.getElementById('aiCategorizeBtn').disabled = true;

                let successCount = 0;
                let errorCount = 0;
                let lastError = '';

                try {
                    // Process in larger batches for speed (modern models handle 40+ easily)
                    const batchSize = 40;
                    const failedTransactions = [];

                    for (let i = 0; i < uncategorized.length; i += batchSize) {
                        const batch = uncategorized.slice(i, i + batchSize);
                        const batchEnd = Math.min(i + batchSize, uncategorized.length);
                        this.showAiStatus(`Processing uncategorized transactions ${i + 1}-${batchEnd} of ${uncategorized.length} with AI...`, 'processing');

                        try {
                            const categorizations = await this.callAI(provider, apiKey, batch);

                            // Apply categorizations
                            categorizations.forEach(result => {
                                const transaction = this.transactions.find(t => t.id === result.id);
                                if (transaction && result.category && this.isValidCategory(result.category)) {
                                    transaction.category = result.category;
                                    this.saveRule(transaction.description, result.category);
                                    successCount++;
                                }
                            });

                            this.updateDisplay();
                        } catch (batchError) {
                            lastError = batchError.message;
                            console.error(`Batch error:`, batchError);
                            failedTransactions.push(...batch);
                        }

                        // Brief delay between batches to avoid rate limits
                        if (i + batchSize < uncategorized.length) {
                            await new Promise(resolve => setTimeout(resolve, 200));
                        }
                    }

                    // One retry pass for any failures (smaller batches)
                    if (failedTransactions.length > 0 && failedTransactions.length < uncategorized.length) {
                        this.showAiStatus(`Retrying ${failedTransactions.length} failed uncategorized transactions with AI...`, 'processing');
                        await new Promise(resolve => setTimeout(resolve, 1000));

                        try {
                            const categorizations = await this.callAI(provider, apiKey, failedTransactions);
                            categorizations.forEach(result => {
                                const transaction = this.transactions.find(t => t.id === result.id);
                                if (transaction && result.category && this.isValidCategory(result.category)) {
                                    transaction.category = result.category;
                                    this.saveRule(transaction.description, result.category);
                                    successCount++;
                                }
                            });
                            this.updateDisplay();
                        } catch (retryError) {
                            errorCount = failedTransactions.length;
                            lastError = retryError.message;
                        }
                    } else if (failedTransactions.length === uncategorized.length) {
                        errorCount = failedTransactions.length;
                    }

                    if (successCount > 0) {
                        const remaining = this.transactions.filter(t => t.category === 'uncategorized').length;
                        if (remaining > 0) {
                            this.showAiStatus(`Categorized ${successCount}. ${remaining} still uncategorized - click again to retry. Last error: ${lastError}`, 'success');
                        } else {
                            this.showAiStatus(`Successfully categorized all ${successCount} transactions!`, 'success');
                        }
                    } else {
                        this.showAiStatus(`Failed: ${lastError}`, 'error');
                    }
                } catch (error) {
                    console.error('AI categorization error:', error);
                    if (successCount > 0) {
                        this.showAiStatus(`Partially completed: ${successCount} categorized. Error: ${error.message}`, 'error');
                    } else {
                        this.showAiStatus(`Error: ${error.message}`, 'error');
                    }
                } finally {
                    document.getElementById('aiCategorizeBtn').disabled = false;
                    // Save to localStorage for session persistence
                    if (this.transactions.length > 0) {
                        StorageUtils.set('transactionData', this.transactions);
                    }
                }
            }

            isValidCategory(category) {
                const validCategories = ['fixed-costs', 'short-term', 'long-term', 'guilt-free', 'income'];
                return validCategories.includes(category);
            }

            async callAI(provider, apiKey, transactions) {
                const transactionList = transactions.map(t => ({
                    id: t.id,
                    description: t.description,
                    amount: t.amount
                }));

                const prompt = this.getCategorizationPrompt(transactionList);

                switch (provider) {
                    case 'openai':
                        return await this.callOpenAI(apiKey, prompt);
                    case 'gemini':
                        return await this.callGemini(apiKey, prompt);
                    case 'anthropic':
                        return await this.callAnthropic(apiKey, prompt);
                    default:
                        throw new Error('Unknown AI provider');
                }
            }

            async callOpenAI(apiKey, prompt) {
                try {
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4o-mini',
                            messages: [{ role: 'user', content: prompt }],
                            max_tokens: 4096,
                            temperature: 0
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `OpenAI API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.choices[0].message.content;
                    return this.parseAIResponse(content);
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        throw new Error('OpenAI blocked by browser (CORS). Try Google Gemini instead.');
                    }
                    throw error;
                }
            }

            async callGemini(apiKey, prompt) {
                // Try models from newest to oldest - cache working model for speed
                const models = [
                    'gemini-2.5-flash',      // Stable 2.5 (fast)
                    'gemini-2.5-pro',        // Stable 2.5 (powerful)
                    'gemini-2.0-flash',      // Fallback
                    'gemini-1.5-flash',      // Legacy fallback
                ];

                // Use cached model if we found one that works
                const cachedModel = this.workingGeminiModel;
                const modelsToTry = cachedModel ? [cachedModel, ...models.filter(m => m !== cachedModel)] : models;

                let lastError = null;

                for (const model of modelsToTry) {
                    try {
                        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                generationConfig: {
                                    temperature: 0,
                                    maxOutputTokens: 8192
                                }
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            const errorMsg = errorData.error?.message || `Gemini API error: ${response.status}`;

                            // If model not found, try next model
                            if (errorMsg.includes('not found') || errorMsg.includes('not supported')) {
                                console.log(`Model ${model} not available, trying next...`);
                                lastError = new Error(errorMsg);
                                continue;
                            }

                            if (response.status === 400 && errorMsg.includes('API key')) {
                                throw new Error('Invalid Gemini API key. Get one at aistudio.google.com/apikey');
                            }
                            throw new Error(errorMsg);
                        }

                        const data = await response.json();
                        if (!data.candidates || !data.candidates[0]?.content?.parts?.[0]?.text) {
                            console.log(`Model ${model} returned unexpected format, trying next...`);
                            lastError = new Error('Unexpected response format from Gemini');
                            continue;
                        }

                        // Cache the working model for future calls
                        this.workingGeminiModel = model;
                        console.log(`Successfully used Gemini model: ${model}`);
                        const content = data.candidates[0].content.parts[0].text;
                        return this.parseAIResponse(content);
                    } catch (error) {
                        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                            throw new Error('Network error connecting to Gemini. Check your internet connection.');
                        }
                        // If it's an API key error, don't try other models
                        if (error.message.includes('API key')) {
                            throw error;
                        }
                        lastError = error;
                        console.log(`Model ${model} failed: ${error.message}`);
                    }
                }

                // All models failed
                throw lastError || new Error('All Gemini models failed. Try a different provider.');
            }

            async callAnthropic(apiKey, prompt) {
                try {
                    const response = await fetch('https://api.anthropic.com/v1/messages', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01',
                            'anthropic-dangerous-direct-browser-access': 'true'
                        },
                        body: JSON.stringify({
                            model: 'claude-3-haiku-20240307',
                            max_tokens: 4096,
                            messages: [{ role: 'user', content: prompt }]
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error?.message || `Anthropic API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const content = data.content[0].text;
                    return this.parseAIResponse(content);
                } catch (error) {
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        throw new Error('Anthropic blocked by browser (CORS). Try Google Gemini instead.');
                    }
                    throw error;
                }
            }

            parseAIResponse(content) {
                try {
                    // Extract JSON from response (in case there's extra text)
                    const jsonMatch = content.match(/\[[\s\S]*?\]/);
                    if (jsonMatch) {
                        return JSON.parse(jsonMatch[0]);
                    }
                    throw new Error('No valid JSON array found in response');
                } catch (parseError) {
                    console.error('Failed to parse AI response:', content);
                    throw new Error('Failed to parse AI response');
                }
            }

            showAiStatus(message, type) {
                const status = document.getElementById('aiStatus');
                status.textContent = message;
                status.className = `ai-status show ${type}`;
            }
        }

        // Initialize
        let analyzer;
        DOMUtils.ready(() => {
            analyzer = new TransactionAnalyzer();

            // Load data from Budget Planner if available
            const budgetData = StorageUtils.get('budgetPlannerData');
            if (budgetData) {
                // Update income field
                const incomeInput = document.getElementById('monthlyIncome');
                if (budgetData.monthlyIncome) {
                    incomeInput.value = analyzer.formatCurrencyInput(budgetData.monthlyIncome);
                    analyzer.targets.income = budgetData.monthlyIncome;
                }
                // Update allocation percentages (round to 1 decimal place)
                if (budgetData.fixedCosts !== undefined) {
                    const rounded = parseFloat(budgetData.fixedCosts.toFixed(1));
                    document.getElementById('targetFixed').value = rounded;
                    analyzer.targets.fixedCosts = rounded;
                }
                if (budgetData.shortTerm !== undefined) {
                    const rounded = parseFloat(budgetData.shortTerm.toFixed(1));
                    document.getElementById('targetShortTerm').value = rounded;
                    analyzer.targets.shortTerm = rounded;
                }
                if (budgetData.longTerm !== undefined) {
                    const rounded = parseFloat(budgetData.longTerm.toFixed(1));
                    document.getElementById('targetLongTerm').value = rounded;
                    analyzer.targets.longTerm = rounded;
                }
                if (budgetData.guiltFree !== undefined) {
                    const rounded = parseFloat(budgetData.guiltFree.toFixed(1));
                    document.getElementById('targetGuiltFree').value = rounded;
                    analyzer.targets.guiltFree = rounded;
                }
            }

            const apiKeyInput = document.getElementById('apiKey');
            const providerSelect = document.getElementById('aiProvider');
            const aiCategorizeBtn = document.getElementById('aiCategorizeBtn');

            // Enable AI button when API key is entered
            apiKeyInput.addEventListener('input', (e) => {
                aiCategorizeBtn.disabled = !e.target.value.trim();
            });

            // Load saved provider and API key from localStorage
            const savedProvider = StorageUtils.get('aiProvider', 'gemini');
            providerSelect.value = savedProvider;

            const savedKey = StorageUtils.get(`apiKey_${savedProvider}`);
            if (savedKey) {
                apiKeyInput.value = savedKey;
                aiCategorizeBtn.disabled = false;
            }

            // Update placeholder and load key when provider changes
            providerSelect.addEventListener('change', (e) => {
                const provider = e.target.value;
                StorageUtils.set('aiProvider', provider);

                // Update placeholder
                const placeholders = {
                    'openai': 'sk-...',
                    'gemini': 'AIza...',
                    'anthropic': 'sk-ant-api...'
                };
                apiKeyInput.placeholder = placeholders[provider] || 'Enter API key...';

                // Load saved key for this provider
                const savedProviderKey = StorageUtils.get(`apiKey_${provider}`);
                apiKeyInput.value = savedProviderKey || '';
                aiCategorizeBtn.disabled = !savedProviderKey;
            });

            // Trigger initial placeholder update
            providerSelect.dispatchEvent(new Event('change'));

            // Save API key when changed (per provider)
            apiKeyInput.addEventListener('change', (e) => {
                if (e.target.value.trim()) {
                    const provider = providerSelect.value;
                    StorageUtils.set(`apiKey_${provider}`, e.target.value.trim());
                }
            });

            // Transfers section toggle
            document.getElementById('toggleTransfers').addEventListener('click', () => {
                const panel = document.getElementById('transfersPanel');
                const btn = document.getElementById('toggleTransfers');
                const arrow = btn.querySelector('.arrow');
                const isOpen = panel.style.display !== 'none';
                panel.style.display = isOpen ? 'none' : 'block';
                arrow.style.transform = isOpen ? 'rotate(0deg)' : 'rotate(180deg)';
            });

            // Load saved transactions if available
            const savedTransactions = StorageUtils.get('transactionData', []);
            if (Array.isArray(savedTransactions) && savedTransactions.length > 0) {
                analyzer.transactions = savedTransactions;
                analyzer.updateDisplay();
                document.getElementById('resultsSection').classList.remove('results-hidden');
            }

            // Initialize session toolbar
            SessionManager.initToolbar(
                // Get current page data for export
                () => {
                    // Save current transactions to localStorage
                    if (analyzer.transactions.length > 0) {
                        StorageUtils.set('transactionData', analyzer.transactions);
                    }

                    return {
                        transactions: analyzer.transactions,
                        bankFormat: analyzer.selectedFormat,
                        targets: analyzer.targets
                    };
                },
                // Handle import
                (result) => {
                    // Reload budget data to update targets (must happen before updateDisplay)
                    const budgetData = StorageUtils.get('budgetPlannerData');
                    if (budgetData) {
                        // Update income
                        if (budgetData.monthlyIncome) {
                            analyzer.targets.income = budgetData.monthlyIncome;
                            document.getElementById('monthlyIncome').value = analyzer.formatCurrencyInput(budgetData.monthlyIncome);
                        }
                        // Update allocation percentages
                        if (budgetData.fixedCosts !== undefined) {
                            const rounded = parseFloat(budgetData.fixedCosts.toFixed(1));
                            analyzer.targets.fixedCosts = rounded;
                            document.getElementById('targetFixed').value = rounded;
                        }
                        if (budgetData.shortTerm !== undefined) {
                            const rounded = parseFloat(budgetData.shortTerm.toFixed(1));
                            analyzer.targets.shortTerm = rounded;
                            document.getElementById('targetShortTerm').value = rounded;
                        }
                        if (budgetData.longTerm !== undefined) {
                            const rounded = parseFloat(budgetData.longTerm.toFixed(1));
                            analyzer.targets.longTerm = rounded;
                            document.getElementById('targetLongTerm').value = rounded;
                        }
                        if (budgetData.guiltFree !== undefined) {
                            const rounded = parseFloat(budgetData.guiltFree.toFixed(1));
                            analyzer.targets.guiltFree = rounded;
                            document.getElementById('targetGuiltFree').value = rounded;
                        }
                    }

                    // Check if we have transaction data in the imported session
                    const transactionData = StorageUtils.get('transactionData', []);
                    if (Array.isArray(transactionData) && transactionData.length > 0) {
                        analyzer.transactions = transactionData;
                        analyzer.updateDisplay();
                        document.getElementById('resultsSection').classList.remove('results-hidden');
                        SessionManager.showToast('Session restored!', 'success');
                    } else if (budgetData) {
                        // Even without transactions, show updated targets
                        SessionManager.showToast('Budget settings restored!', 'success');
                    } else {
                        window.location.reload();
                    }
                }
            );
        });
    </script>
</body>
</html>
